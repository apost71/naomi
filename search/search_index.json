{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>NAOMI (Numerical Astrodynamics and Orbital Mechanics Interface) is a general purpose library for astrodynamics. It has been designed from the ground up to support distributed, high fidelity, and interactive simulations.  Additionally, there is support for symbolic math through the use of Symengine.</p> <p>Warning</p> <p>This project is under active development and subject to significant change without warning. It has currently only been tested with gcc on Ubuntu Linux 22.04</p>"},{"location":"#installation","title":"Installation","text":"<p>First install the submodules</p> <pre><code>git submodule init &amp;&amp; git submodule update\n</code></pre> <p>Then install the dependencies.</p> <pre><code>sudo apt-get update\nsudo apt-get install libfmt-dev libeigen3-dev libboost-all-dev libopenblas-dev \\\n    liblapack-dev libarpack2-dev libsuperlu-dev libarmadillo-dev libgtest-dev \\\n    libgmp-dev libflint-dev libmpc-dev libomp-dev llvm\n</code></pre> <p>Next build Symengine</p> <pre><code>cd symengine &amp;&amp; mkdir build &amp;&amp; cd build\ncmake WITH_GMP=on WITH_MPFR=on WITH_MPC=on INTEGER_CLASS=flint WITH_LLVM=on WITH_SYMENGINE_THREAD_SAFE=on WITH_OPENMP=on ..\nmake install\ncd ..\n</code></pre> <p>Finally, build Naomi</p> <pre><code>mkdir build &amp;&amp; cd build\ncmake ..\nmake install\ncd ..\n</code></pre> <p>Now the tests can be run from the <code>build/tests</code> directory</p> <pre><code>cd build/tests\nctest\n</code></pre>"},{"location":"#build-and-run-examples","title":"Build and Run Examples","text":"<p>To build the examples set <code>BUILD_EXAMPLES=ON</code> in the build</p> <pre><code>cmake -DBUILD_EXAMPLES=ON ..\n</code></pre> <p>In the build directory there will now be an <code>examples</code> directory containing the example executables.  To run the simulation examples:</p> <pre><code>cd build\n./examples/simulation/naomi-simulation\n</code></pre>"},{"location":"propagation/","title":"Propagation","text":"<p>This is a page for propagation.</p>"},{"location":"propagation/#subsection","title":"Subsection","text":"<p>This is a subsection</p>"},{"location":"naomi/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class angular_coordinates </li> <li>class integrated_provider </li> <li>namespace naomi </li> <li>namespace attitude <ul> <li>class additional_state_provider </li> <li>class attitude_provider </li> <li>class constant_attitude_provider </li> <li>class euler_angles </li> <li>class rotation </li> <li>class torque_free_eoms </li> </ul> </li> <li>namespace bodies <ul> <li>class celestial_body </li> <li>class earth </li> </ul> </li> <li>namespace constants </li> <li>namespace control <ul> <li>class control_input </li> <li>class controller </li> <li>class nadir_pointing_pid_controller </li> <li>class pid_controller </li> </ul> </li> <li>namespace events <ul> <li>class apside_detector </li> <li>struct event </li> <li>class event_detector </li> <li>struct event_detector_condition </li> <li>class event_handler </li> <li>class time_detector </li> </ul> </li> <li>namespace forces <ul> <li>class equations_of_motion </li> <li>class force_model </li> <li>class two_body_force_model </li> <li>class two_body_force_model_eoms </li> <li>class two_body_rot_force_model </li> </ul> </li> <li>namespace frames <ul> <li>class frame </li> </ul> </li> <li>namespace geometry <ul> <li>class body_shape </li> <li>struct face </li> </ul> </li> <li>namespace maneuvers <ul> <li>class bielliptic_hohmann_transfer </li> <li>class hohmann_transfer A class to compute the optimal burns for a Hohmann Transfer using equations as described by orbital-mechanics.space . </li> <li>class maneuver </li> <li>class maneuver_plan </li> <li>class no_such_maneuver_exception </li> </ul> </li> <li>class mass_provider </li> <li>namespace math <ul> <li>namespace quaternion </li> </ul> </li> <li>namespace numeric <ul> <li>class integrator </li> <li>class numerical_propagator </li> </ul> </li> <li>namespace observers <ul> <li>class results_csv_writer_observer </li> <li>class simulation_observer </li> </ul> </li> <li>namespace orbits <ul> <li>class cartesian_orbit </li> <li>struct eccentric_anomaly_functor </li> <li>class keplerian_orbit </li> </ul> </li> <li>class physical_system A <code>physical_system</code> contains the force model definitions of the system to be simulated, the spacecrafts that exist within the system, and the propagator that will be used to integrate the dynamics. </li> <li>class simulation </li> <li>class simulation_component </li> <li>class spacecraft </li> <li>class spacecraft_state </li> <li>class pv_coordinates </li> <li>class pv_coordinates_provider </li> <li>class spacecraft_attitude_subsystem </li> <li>class spacecraft_subsystem </li> <li>class spacecraft_subsystem_state </li> <li>class state_provider </li> <li>class torque_free_attitude_provider </li> </ul>"},{"location":"naomi/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir include <ul> <li>file constants.h </li> <li>dir attitude <ul> <li>file angular_coordinates.h </li> <li>file attitude_provider.h </li> <li>file constant_attitude_provider.h </li> <li>file euler_angles.h </li> <li>file rotation.h </li> <li>file spacecraft_attitude_subsystem.h </li> <li>file torque_free.h </li> <li>file torque_free_provider.h </li> </ul> </li> <li>dir bodies <ul> <li>file celestial_body.h </li> <li>file earth.h </li> </ul> </li> <li>dir control <ul> <li>file controller.h </li> <li>file pid_controller.h </li> </ul> </li> <li>dir forces <ul> <li>file force_model.h </li> <li>file two_body_force_model.h </li> <li>file two_body_rot_force_model.h </li> </ul> </li> <li>dir frames <ul> <li>file frame.h </li> <li>file transforms.h </li> </ul> </li> <li>dir integrators <ul> <li>file integrator.h </li> </ul> </li> <li>dir maneuvers <ul> <li>file hohmann_transfer.h </li> <li>file maneuver.h </li> <li>file maneuver_plan.h </li> </ul> </li> <li>dir math <ul> <li>file quaternion.h </li> <li>file transport_theorem.h </li> <li>file vector_utils.h </li> <li>file volume_integrals.h </li> </ul> </li> <li>dir observers <ul> <li>file simulation_observer.h </li> </ul> </li> <li>dir orbits <ul> <li>file cartesian.h </li> <li>file keplerian.h </li> <li>file orbits.h </li> </ul> </li> <li>dir propagators <ul> <li>file event_detector.h </li> <li>file event_handler.h </li> <li>file numerical_propagator.h </li> </ul> </li> <li>dir simulation <ul> <li>file simulation.h </li> </ul> </li> <li>dir spacecraft <ul> <li>file body_shape.h </li> <li>file pv_coordinates.h </li> <li>file pv_coordinates_provider.h </li> <li>file spacecraft.h </li> <li>file spacecraft_state.h </li> <li>file spacecraft_subsystem.h </li> <li>file state_provider.h </li> </ul> </li> <li>dir systems <ul> <li>file system.h </li> <li>file two_body.h </li> </ul> </li> <li>file naomi.h </li> </ul> </li> </ul>"},{"location":"naomi/classangular__coordinates/","title":"Class angular_coordinates","text":"<p>ClassList &gt; angular_coordinates</p> <ul> <li><code>#include &lt;angular_coordinates.h&gt;</code></li> </ul>"},{"location":"naomi/classangular__coordinates/#public-functions","title":"Public Functions","text":"Type Name angular_coordinates (const quaternion_type &amp; rotation)  auto get_rotation ()  auto to_vec ()"},{"location":"naomi/classangular__coordinates/#public-static-functions","title":"Public Static Functions","text":"Type Name angular_coordinates identity ()"},{"location":"naomi/classangular__coordinates/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classangular__coordinates/#function-angular_coordinates","title":"function angular_coordinates","text":"<pre><code>inline explicit angular_coordinates::angular_coordinates (\n    const quaternion_type &amp; rotation\n) \n</code></pre>"},{"location":"naomi/classangular__coordinates/#function-get_rotation","title":"function get_rotation","text":"<pre><code>inline auto angular_coordinates::get_rotation () \n</code></pre>"},{"location":"naomi/classangular__coordinates/#function-to_vec","title":"function to_vec","text":"<pre><code>inline auto angular_coordinates::to_vec () \n</code></pre>"},{"location":"naomi/classangular__coordinates/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"naomi/classangular__coordinates/#function-identity","title":"function identity","text":"<pre><code>static inline angular_coordinates angular_coordinates::identity () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/attitude/angular_coordinates.h</code></p>"},{"location":"naomi/classintegrated__provider/","title":"Class integrated_provider","text":"<p>ClassList &gt; integrated_provider</p> <ul> <li><code>#include &lt;state_provider.h&gt;</code></li> </ul> <p>Inherited by the following classes: pv_coordinates_provider,  torque_free_attitude_provider</p>"},{"location":"naomi/classintegrated__provider/#public-functions","title":"Public Functions","text":"Type Name virtual std::shared_ptr&lt; naomi::forces::equations_of_motion &gt; get_eoms () = 0 virtual naomi::vector_type get_integrated_state () = 0 virtual std::size_t get_size () = 0 virtual void set_integrated_state (const naomi::vector_type &amp; state) = 0 virtual ~integrated_provider () = default"},{"location":"naomi/classintegrated__provider/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classintegrated__provider/#function-get_eoms","title":"function get_eoms","text":"<pre><code>virtual std::shared_ptr&lt; naomi::forces::equations_of_motion &gt; integrated_provider::get_eoms () = 0\n</code></pre>"},{"location":"naomi/classintegrated__provider/#function-get_integrated_state","title":"function get_integrated_state","text":"<pre><code>virtual naomi::vector_type integrated_provider::get_integrated_state () = 0\n</code></pre>"},{"location":"naomi/classintegrated__provider/#function-get_size","title":"function get_size","text":"<pre><code>virtual std::size_t integrated_provider::get_size () = 0\n</code></pre>"},{"location":"naomi/classintegrated__provider/#function-set_integrated_state","title":"function set_integrated_state","text":"<pre><code>virtual void integrated_provider::set_integrated_state (\n    const naomi::vector_type &amp; state\n) = 0\n</code></pre>"},{"location":"naomi/classintegrated__provider/#function-integrated_provider","title":"function ~integrated_provider","text":"<pre><code>virtual integrated_provider::~integrated_provider () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/spacecraft/state_provider.h</code></p>"},{"location":"naomi/namespacenaomi/","title":"Namespace naomi","text":"<p>Namespace List &gt; naomi</p>"},{"location":"naomi/namespacenaomi/#namespaces","title":"Namespaces","text":"Type Name namespace attitude namespace bodies namespace constants namespace control namespace events namespace forces namespace frames namespace geometry namespace maneuvers namespace math namespace numeric namespace observers namespace orbits"},{"location":"naomi/namespacenaomi/#classes","title":"Classes","text":"Type Name class mass_provider class physical_system &lt;typename Propagator&gt;A <code>physical_system</code> contains the force model definitions of the system to be simulated, the spacecrafts that exist within the system, and the propagator that will be used to integrate the dynamics. class simulation &lt;typename system_t&gt; class simulation_component &lt;typename state_t&gt; class spacecraft class spacecraft_state"},{"location":"naomi/namespacenaomi/#public-types","title":"Public Types","text":"Type Name typedef arma::vec::fixed&lt; 10 &gt; pv_rot_state_type typedef arma::vec6 pv_state_type typedef arma::vec::fixed&lt; 13 &gt; pva_rot_state_type typedef arma::vec9 pva_state_type typedef arma::vec4 quaternion_type typedef arma::vec vector_type"},{"location":"naomi/namespacenaomi/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"naomi/namespacenaomi/#typedef-pv_rot_state_type","title":"typedef pv_rot_state_type","text":"<pre><code>typedef arma::vec::fixed&lt;10&gt; naomi::pv_rot_state_type;\n</code></pre>"},{"location":"naomi/namespacenaomi/#typedef-pv_state_type","title":"typedef pv_state_type","text":"<pre><code>typedef arma::vec6 naomi::pv_state_type;\n</code></pre>"},{"location":"naomi/namespacenaomi/#typedef-pva_rot_state_type","title":"typedef pva_rot_state_type","text":"<pre><code>typedef arma::vec::fixed&lt;13&gt; naomi::pva_rot_state_type;\n</code></pre>"},{"location":"naomi/namespacenaomi/#typedef-pva_state_type","title":"typedef pva_state_type","text":"<pre><code>typedef arma::vec9 naomi::pva_state_type;\n</code></pre>"},{"location":"naomi/namespacenaomi/#typedef-quaternion_type","title":"typedef quaternion_type","text":"<pre><code>typedef arma::vec4 naomi::quaternion_type;\n</code></pre>"},{"location":"naomi/namespacenaomi/#typedef-vector_type","title":"typedef vector_type","text":"<pre><code>typedef arma::vec naomi::vector_type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/attitude/attitude_provider.h</code></p>"},{"location":"naomi/namespacenaomi_1_1attitude/","title":"Namespace naomi::attitude","text":"<p>Namespace List &gt; naomi &gt; attitude</p>"},{"location":"naomi/namespacenaomi_1_1attitude/#classes","title":"Classes","text":"Type Name class additional_state_provider class attitude_provider class constant_attitude_provider class euler_angles class rotation class torque_free_eoms"},{"location":"naomi/namespacenaomi_1_1attitude/#public-types","title":"Public Types","text":"Type Name enum rotation_order"},{"location":"naomi/namespacenaomi_1_1attitude/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"naomi/namespacenaomi_1_1attitude/#enum-rotation_order","title":"enum rotation_order","text":"<pre><code>enum naomi::attitude::rotation_order {\n    XYZ,\n    XYX,\n    XZY,\n    XZX,\n    YXZ,\n    YXY,\n    YZX,\n    YZY,\n    ZXY,\n    ZXZ,\n    ZYX,\n    ZYZ\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/attitude/attitude_provider.h</code></p>"},{"location":"naomi/classnaomi_1_1attitude_1_1additional__state__provider/","title":"Class naomi::attitude::additional_state_provider","text":"<p>ClassList &gt; naomi &gt; attitude &gt; additional_state_provider</p> <ul> <li><code>#include &lt;attitude_provider.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1attitude_1_1additional__state__provider/#public-functions","title":"Public Functions","text":"Type Name additional_state_provider (std::string name, vector_type state)  virtual vector_type get_derivative (const vector_type &amp; state) const = 0 virtual std::string get_name () const virtual std::size_t get_size ()  virtual vector_type get_state () const virtual ~additional_state_provider () = default"},{"location":"naomi/classnaomi_1_1attitude_1_1additional__state__provider/#protected-attributes","title":"Protected Attributes","text":"Type Name std::string _name vector_type m_state"},{"location":"naomi/classnaomi_1_1attitude_1_1additional__state__provider/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1attitude_1_1additional__state__provider/#function-additional_state_provider","title":"function additional_state_provider","text":"<pre><code>inline explicit naomi::attitude::additional_state_provider::additional_state_provider (\n    std::string name,\n    vector_type state\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1additional__state__provider/#function-get_derivative","title":"function get_derivative","text":"<pre><code>virtual vector_type naomi::attitude::additional_state_provider::get_derivative (\n    const vector_type &amp; state\n) const = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1additional__state__provider/#function-get_name","title":"function get_name","text":"<pre><code>inline virtual std::string naomi::attitude::additional_state_provider::get_name () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1additional__state__provider/#function-get_size","title":"function get_size","text":"<pre><code>inline virtual std::size_t naomi::attitude::additional_state_provider::get_size () \n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1additional__state__provider/#function-get_state","title":"function get_state","text":"<pre><code>inline virtual vector_type naomi::attitude::additional_state_provider::get_state () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1additional__state__provider/#function-additional_state_provider_1","title":"function ~additional_state_provider","text":"<pre><code>virtual naomi::attitude::additional_state_provider::~additional_state_provider () = default\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1additional__state__provider/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"naomi/classnaomi_1_1attitude_1_1additional__state__provider/#variable-_name","title":"variable _name","text":"<pre><code>std::string naomi::attitude::additional_state_provider::_name;\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1additional__state__provider/#variable-m_state","title":"variable m_state","text":"<pre><code>vector_type naomi::attitude::additional_state_provider::m_state;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/attitude/attitude_provider.h</code></p>"},{"location":"naomi/classnaomi_1_1attitude_1_1attitude__provider/","title":"Class naomi::attitude::attitude_provider","text":"<p>ClassList &gt; naomi &gt; attitude &gt; attitude_provider</p> <ul> <li><code>#include &lt;attitude_provider.h&gt;</code></li> </ul> <p>Inherited by the following classes: naomi::attitude::constant_attitude_provider,  torque_free_attitude_provider</p>"},{"location":"naomi/classnaomi_1_1attitude_1_1attitude__provider/#public-functions","title":"Public Functions","text":"Type Name virtual void apply_force (const arma::vec3 &amp; forces) = 0 virtual vector_type get_angular_momentum () = 0 virtual vector_type get_angular_velocity () = 0 virtual quaternion_type get_rotation () = 0 virtual ~attitude_provider () = default"},{"location":"naomi/classnaomi_1_1attitude_1_1attitude__provider/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1attitude_1_1attitude__provider/#function-apply_force","title":"function apply_force","text":"<pre><code>virtual void naomi::attitude::attitude_provider::apply_force (\n    const arma::vec3 &amp; forces\n) = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1attitude__provider/#function-get_angular_momentum","title":"function get_angular_momentum","text":"<pre><code>virtual vector_type naomi::attitude::attitude_provider::get_angular_momentum () = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1attitude__provider/#function-get_angular_velocity","title":"function get_angular_velocity","text":"<pre><code>virtual vector_type naomi::attitude::attitude_provider::get_angular_velocity () = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1attitude__provider/#function-get_rotation","title":"function get_rotation","text":"<pre><code>virtual quaternion_type naomi::attitude::attitude_provider::get_rotation () = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1attitude__provider/#function-attitude_provider","title":"function ~attitude_provider","text":"<pre><code>virtual naomi::attitude::attitude_provider::~attitude_provider () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/attitude/attitude_provider.h</code></p>"},{"location":"naomi/classnaomi_1_1attitude_1_1constant__attitude__provider/","title":"Class naomi::attitude::constant_attitude_provider","text":"<p>ClassList &gt; naomi &gt; attitude &gt; constant_attitude_provider</p> <ul> <li><code>#include &lt;constant_attitude_provider.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::attitude::attitude_provider</p>"},{"location":"naomi/classnaomi_1_1attitude_1_1constant__attitude__provider/#public-functions","title":"Public Functions","text":"Type Name virtual void apply_force (const arma::vec3 &amp; forces) override constant_attitude_provider () = default constant_attitude_provider (const quaternion_type &amp; q)  virtual vector_type get_angular_momentum () override virtual vector_type get_angular_velocity () override virtual quaternion_type get_rotation () override ~constant_attitude_provider () override"},{"location":"naomi/classnaomi_1_1attitude_1_1constant__attitude__provider/#public-functions-inherited-from-naomiattitudeattitude_provider","title":"Public Functions inherited from naomi::attitude::attitude_provider","text":"<p>See naomi::attitude::attitude_provider</p> Type Name virtual void apply_force (const arma::vec3 &amp; forces) = 0 virtual vector_type get_angular_momentum () = 0 virtual vector_type get_angular_velocity () = 0 virtual quaternion_type get_rotation () = 0 virtual ~attitude_provider () = default"},{"location":"naomi/classnaomi_1_1attitude_1_1constant__attitude__provider/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1attitude_1_1constant__attitude__provider/#function-apply_force","title":"function apply_force","text":"<pre><code>inline virtual void naomi::attitude::constant_attitude_provider::apply_force (\n    const arma::vec3 &amp; forces\n) override\n</code></pre> <p>Implements naomi::attitude::attitude_provider::apply_force</p>"},{"location":"naomi/classnaomi_1_1attitude_1_1constant__attitude__provider/#function-constant_attitude_provider-12","title":"function constant_attitude_provider [1/2]","text":"<pre><code>naomi::attitude::constant_attitude_provider::constant_attitude_provider () = default\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1constant__attitude__provider/#function-constant_attitude_provider-22","title":"function constant_attitude_provider [2/2]","text":"<pre><code>inline explicit naomi::attitude::constant_attitude_provider::constant_attitude_provider (\n    const quaternion_type &amp; q\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1constant__attitude__provider/#function-get_angular_momentum","title":"function get_angular_momentum","text":"<pre><code>inline virtual vector_type naomi::attitude::constant_attitude_provider::get_angular_momentum () override\n</code></pre> <p>Implements naomi::attitude::attitude_provider::get_angular_momentum</p>"},{"location":"naomi/classnaomi_1_1attitude_1_1constant__attitude__provider/#function-get_angular_velocity","title":"function get_angular_velocity","text":"<pre><code>inline virtual vector_type naomi::attitude::constant_attitude_provider::get_angular_velocity () override\n</code></pre> <p>Implements naomi::attitude::attitude_provider::get_angular_velocity</p>"},{"location":"naomi/classnaomi_1_1attitude_1_1constant__attitude__provider/#function-get_rotation","title":"function get_rotation","text":"<pre><code>inline virtual quaternion_type naomi::attitude::constant_attitude_provider::get_rotation () override\n</code></pre> <p>Implements naomi::attitude::attitude_provider::get_rotation</p>"},{"location":"naomi/classnaomi_1_1attitude_1_1constant__attitude__provider/#function-constant_attitude_provider","title":"function ~constant_attitude_provider","text":"<pre><code>naomi::attitude::constant_attitude_provider::~constant_attitude_provider () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/attitude/constant_attitude_provider.h</code></p>"},{"location":"naomi/classnaomi_1_1attitude_1_1euler__angles/","title":"Class naomi::attitude::euler_angles","text":"<p>ClassList &gt; naomi &gt; attitude &gt; euler_angles</p> <ul> <li><code>#include &lt;euler_angles.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::attitude::rotation</p>"},{"location":"naomi/classnaomi_1_1attitude_1_1euler__angles/#public-functions","title":"Public Functions","text":"Type Name virtual std::shared_ptr&lt; rotation &gt; apply_to (const std::shared_ptr&lt; rotation &gt; &amp; r) override virtual arma::vec3 apply_to (const arma::vec3 &amp; r) override euler_angles (const double alpha, const double beta, const double gamma, const rotation_order order) Radians. virtual arma::mat33 get_dcm () override ~euler_angles () override"},{"location":"naomi/classnaomi_1_1attitude_1_1euler__angles/#public-functions-inherited-from-naomiattituderotation","title":"Public Functions inherited from naomi::attitude::rotation","text":"<p>See naomi::attitude::rotation</p> Type Name virtual std::shared_ptr&lt; rotation &gt; apply_to (const std::shared_ptr&lt; rotation &gt; &amp; r) = 0 virtual arma::vec3 apply_to (const arma::vec3 &amp; r) = 0 virtual arma::mat33 get_dcm () = 0 virtual ~rotation () = default"},{"location":"naomi/classnaomi_1_1attitude_1_1euler__angles/#public-static-functions","title":"Public Static Functions","text":"Type Name arma::mat33 get_axis_rotation (int axis, double th)"},{"location":"naomi/classnaomi_1_1attitude_1_1euler__angles/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1attitude_1_1euler__angles/#function-apply_to-12","title":"function apply_to [1/2]","text":"<pre><code>inline virtual std::shared_ptr&lt; rotation &gt; naomi::attitude::euler_angles::apply_to (\n    const std::shared_ptr&lt; rotation &gt; &amp; r\n) override\n</code></pre> <p>Implements naomi::attitude::rotation::apply_to</p>"},{"location":"naomi/classnaomi_1_1attitude_1_1euler__angles/#function-apply_to-22","title":"function apply_to [2/2]","text":"<pre><code>inline virtual arma::vec3 naomi::attitude::euler_angles::apply_to (\n    const arma::vec3 &amp; r\n) override\n</code></pre> <p>Implements naomi::attitude::rotation::apply_to</p>"},{"location":"naomi/classnaomi_1_1attitude_1_1euler__angles/#function-euler_angles","title":"function euler_angles","text":"<p>Radians. <pre><code>inline naomi::attitude::euler_angles::euler_angles (\n    const double alpha,\n    const double beta,\n    const double gamma,\n    const rotation_order order\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>alpha</code> </li> <li><code>beta</code> </li> <li><code>gamma</code> </li> <li><code>order</code> </li> </ul>"},{"location":"naomi/classnaomi_1_1attitude_1_1euler__angles/#function-get_dcm","title":"function get_dcm","text":"<pre><code>inline virtual arma::mat33 naomi::attitude::euler_angles::get_dcm () override\n</code></pre> <p>Implements naomi::attitude::rotation::get_dcm</p>"},{"location":"naomi/classnaomi_1_1attitude_1_1euler__angles/#function-euler_angles_1","title":"function ~euler_angles","text":"<pre><code>naomi::attitude::euler_angles::~euler_angles () override\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1euler__angles/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1attitude_1_1euler__angles/#function-get_axis_rotation","title":"function get_axis_rotation","text":"<pre><code>static inline arma::mat33 naomi::attitude::euler_angles::get_axis_rotation (\n    int axis,\n    double th\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/attitude/euler_angles.h</code></p>"},{"location":"naomi/classnaomi_1_1attitude_1_1rotation/","title":"Class naomi::attitude::rotation","text":"<p>ClassList &gt; naomi &gt; attitude &gt; rotation</p> <ul> <li><code>#include &lt;rotation.h&gt;</code></li> </ul> <p>Inherited by the following classes: naomi::attitude::euler_angles</p>"},{"location":"naomi/classnaomi_1_1attitude_1_1rotation/#public-functions","title":"Public Functions","text":"Type Name virtual std::shared_ptr&lt; rotation &gt; apply_to (const std::shared_ptr&lt; rotation &gt; &amp; r) = 0 virtual arma::vec3 apply_to (const arma::vec3 &amp; r) = 0 virtual arma::mat33 get_dcm () = 0 virtual ~rotation () = default"},{"location":"naomi/classnaomi_1_1attitude_1_1rotation/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1attitude_1_1rotation/#function-apply_to-12","title":"function apply_to [1/2]","text":"<pre><code>virtual std::shared_ptr&lt; rotation &gt; naomi::attitude::rotation::apply_to (\n    const std::shared_ptr&lt; rotation &gt; &amp; r\n) = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1rotation/#function-apply_to-22","title":"function apply_to [2/2]","text":"<pre><code>virtual arma::vec3 naomi::attitude::rotation::apply_to (\n    const arma::vec3 &amp; r\n) = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1rotation/#function-get_dcm","title":"function get_dcm","text":"<pre><code>virtual arma::mat33 naomi::attitude::rotation::get_dcm () = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1rotation/#function-rotation","title":"function ~rotation","text":"<pre><code>virtual naomi::attitude::rotation::~rotation () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/attitude/rotation.h</code></p>"},{"location":"naomi/classnaomi_1_1attitude_1_1torque__free__eoms/","title":"Class naomi::attitude::torque_free_eoms","text":"<p>ClassList &gt; naomi &gt; attitude &gt; torque_free_eoms</p> <ul> <li><code>#include &lt;torque_free.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::forces::equations_of_motion</p>"},{"location":"naomi/classnaomi_1_1attitude_1_1torque__free__eoms/#public-functions","title":"Public Functions","text":"Type Name virtual vector_type get_derivative (const vector_type &amp; state, double t) override const torque_free_eoms (const arma::mat33 &amp; inertia_matrix)  ~torque_free_eoms () override"},{"location":"naomi/classnaomi_1_1attitude_1_1torque__free__eoms/#public-functions-inherited-from-naomiforcesequations_of_motion","title":"Public Functions inherited from naomi::forces::equations_of_motion","text":"<p>See naomi::forces::equations_of_motion</p> Type Name virtual vector_type get_derivative (const vector_type &amp; state, double t) const = 0 virtual ~equations_of_motion () = default"},{"location":"naomi/classnaomi_1_1attitude_1_1torque__free__eoms/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1attitude_1_1torque__free__eoms/#function-get_derivative","title":"function get_derivative","text":"<pre><code>inline virtual vector_type naomi::attitude::torque_free_eoms::get_derivative (\n    const vector_type &amp; state,\n    double t\n) override const\n</code></pre> <p>Implements naomi::forces::equations_of_motion::get_derivative</p>"},{"location":"naomi/classnaomi_1_1attitude_1_1torque__free__eoms/#function-torque_free_eoms","title":"function torque_free_eoms","text":"<pre><code>inline explicit naomi::attitude::torque_free_eoms::torque_free_eoms (\n    const arma::mat33 &amp; inertia_matrix\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1attitude_1_1torque__free__eoms/#function-torque_free_eoms_1","title":"function ~torque_free_eoms","text":"<pre><code>naomi::attitude::torque_free_eoms::~torque_free_eoms () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/attitude/torque_free.h</code></p>"},{"location":"naomi/namespacenaomi_1_1bodies/","title":"Namespace naomi::bodies","text":"<p>Namespace List &gt; naomi &gt; bodies</p>"},{"location":"naomi/namespacenaomi_1_1bodies/#classes","title":"Classes","text":"Type Name class celestial_body class earth <p>The documentation for this class was generated from the following file <code>include/bodies/celestial_body.h</code></p>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/","title":"Class naomi::bodies::celestial_body","text":"<p>ClassList &gt; naomi &gt; bodies &gt; celestial_body</p> <ul> <li><code>#include &lt;celestial_body.h&gt;</code></li> </ul> <p>Inherited by the following classes: naomi::bodies::earth</p>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#public-functions","title":"Public Functions","text":"Type Name celestial_body (const double mu, const double soi, const double eq_radius, const std::initializer_list&lt; double &gt; higher_order_terms={})  auto get_mu () const virtual SymEngine::Expression get_potential ()  virtual double get_potential (arma::vec &amp; pos)  virtual arma::vec get_potential_partial (arma::vec &amp; pos)  virtual Eigen::Vector3d get_potential_partial_derivative (Eigen::Vector3d position) = 0 virtual arma::vec get_potential_partial_derivative (arma::vec position) = 0 auto get_sphere_of_influence () const virtual ~celestial_body () = default"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#protected-attributes","title":"Protected Attributes","text":"Type Name double m_eq_radius std::vector&lt; double &gt; m_higher_order_terms double m_mu SymEngine::Expression m_potential_exp SymEngine::RCP&lt; const SymEngine::Basic &gt; m_potential_partial_x SymEngine::LLVMDoubleVisitor m_potential_partial_x_visitor SymEngine::RCP&lt; const SymEngine::Basic &gt; m_potential_partial_y SymEngine::LLVMDoubleVisitor m_potential_partial_y_visitor SymEngine::RCP&lt; const SymEngine::Basic &gt; m_potential_partial_z SymEngine::LLVMDoubleVisitor m_potential_partial_z_visitor double m_soi"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#function-celestial_body","title":"function celestial_body","text":"<pre><code>inline explicit naomi::bodies::celestial_body::celestial_body (\n    const double mu,\n    const double soi,\n    const double eq_radius,\n    const std::initializer_list&lt; double &gt; higher_order_terms={}\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#function-get_mu","title":"function get_mu","text":"<pre><code>inline auto naomi::bodies::celestial_body::get_mu () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#function-get_potential-12","title":"function get_potential [1/2]","text":"<pre><code>inline virtual SymEngine::Expression naomi::bodies::celestial_body::get_potential () \n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#function-get_potential-22","title":"function get_potential [2/2]","text":"<pre><code>inline virtual double naomi::bodies::celestial_body::get_potential (\n    arma::vec &amp; pos\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#function-get_potential_partial","title":"function get_potential_partial","text":"<pre><code>inline virtual arma::vec naomi::bodies::celestial_body::get_potential_partial (\n    arma::vec &amp; pos\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#function-get_potential_partial_derivative-12","title":"function get_potential_partial_derivative [1/2]","text":"<pre><code>virtual Eigen::Vector3d naomi::bodies::celestial_body::get_potential_partial_derivative (\n    Eigen::Vector3d position\n) = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#function-get_potential_partial_derivative-22","title":"function get_potential_partial_derivative [2/2]","text":"<pre><code>virtual arma::vec naomi::bodies::celestial_body::get_potential_partial_derivative (\n    arma::vec position\n) = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#function-get_sphere_of_influence","title":"function get_sphere_of_influence","text":"<pre><code>inline auto naomi::bodies::celestial_body::get_sphere_of_influence () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#function-celestial_body_1","title":"function ~celestial_body","text":"<pre><code>virtual naomi::bodies::celestial_body::~celestial_body () = default\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#variable-m_eq_radius","title":"variable m_eq_radius","text":"<pre><code>double naomi::bodies::celestial_body::m_eq_radius;\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#variable-m_higher_order_terms","title":"variable m_higher_order_terms","text":"<pre><code>std::vector&lt;double&gt; naomi::bodies::celestial_body::m_higher_order_terms;\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#variable-m_mu","title":"variable m_mu","text":"<pre><code>double naomi::bodies::celestial_body::m_mu;\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#variable-m_potential_exp","title":"variable m_potential_exp","text":"<pre><code>SymEngine::Expression naomi::bodies::celestial_body::m_potential_exp;\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#variable-m_potential_partial_x","title":"variable m_potential_partial_x","text":"<pre><code>SymEngine::RCP&lt;const SymEngine::Basic&gt; naomi::bodies::celestial_body::m_potential_partial_x;\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#variable-m_potential_partial_x_visitor","title":"variable m_potential_partial_x_visitor","text":"<pre><code>SymEngine::LLVMDoubleVisitor naomi::bodies::celestial_body::m_potential_partial_x_visitor;\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#variable-m_potential_partial_y","title":"variable m_potential_partial_y","text":"<pre><code>SymEngine::RCP&lt;const SymEngine::Basic&gt; naomi::bodies::celestial_body::m_potential_partial_y;\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#variable-m_potential_partial_y_visitor","title":"variable m_potential_partial_y_visitor","text":"<pre><code>SymEngine::LLVMDoubleVisitor naomi::bodies::celestial_body::m_potential_partial_y_visitor;\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#variable-m_potential_partial_z","title":"variable m_potential_partial_z","text":"<pre><code>SymEngine::RCP&lt;const SymEngine::Basic&gt; naomi::bodies::celestial_body::m_potential_partial_z;\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#variable-m_potential_partial_z_visitor","title":"variable m_potential_partial_z_visitor","text":"<pre><code>SymEngine::LLVMDoubleVisitor naomi::bodies::celestial_body::m_potential_partial_z_visitor;\n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1celestial__body/#variable-m_soi","title":"variable m_soi","text":"<pre><code>double naomi::bodies::celestial_body::m_soi;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/bodies/celestial_body.h</code></p>"},{"location":"naomi/classnaomi_1_1bodies_1_1earth/","title":"Class naomi::bodies::earth","text":"<p>ClassList &gt; naomi &gt; bodies &gt; earth</p> <ul> <li><code>#include &lt;earth.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::bodies::celestial_body</p>"},{"location":"naomi/classnaomi_1_1bodies_1_1earth/#public-functions","title":"Public Functions","text":"Type Name earth ()  virtual auto get_potential_partial_derivative (Eigen::Vector3d position) override virtual auto get_potential_partial_derivative (arma::vec position) override ~earth () override"},{"location":"naomi/classnaomi_1_1bodies_1_1earth/#public-functions-inherited-from-naomibodiescelestial_body","title":"Public Functions inherited from naomi::bodies::celestial_body","text":"<p>See naomi::bodies::celestial_body</p> Type Name celestial_body (const double mu, const double soi, const double eq_radius, const std::initializer_list&lt; double &gt; higher_order_terms={})  auto get_mu () const virtual SymEngine::Expression get_potential ()  virtual double get_potential (arma::vec &amp; pos)  virtual arma::vec get_potential_partial (arma::vec &amp; pos)  virtual Eigen::Vector3d get_potential_partial_derivative (Eigen::Vector3d position) = 0 virtual arma::vec get_potential_partial_derivative (arma::vec position) = 0 auto get_sphere_of_influence () const virtual ~celestial_body () = default"},{"location":"naomi/classnaomi_1_1bodies_1_1earth/#protected-attributes-inherited-from-naomibodiescelestial_body","title":"Protected Attributes inherited from naomi::bodies::celestial_body","text":"<p>See naomi::bodies::celestial_body</p> Type Name double m_eq_radius std::vector&lt; double &gt; m_higher_order_terms double m_mu SymEngine::Expression m_potential_exp SymEngine::RCP&lt; const SymEngine::Basic &gt; m_potential_partial_x SymEngine::LLVMDoubleVisitor m_potential_partial_x_visitor SymEngine::RCP&lt; const SymEngine::Basic &gt; m_potential_partial_y SymEngine::LLVMDoubleVisitor m_potential_partial_y_visitor SymEngine::RCP&lt; const SymEngine::Basic &gt; m_potential_partial_z SymEngine::LLVMDoubleVisitor m_potential_partial_z_visitor double m_soi"},{"location":"naomi/classnaomi_1_1bodies_1_1earth/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1bodies_1_1earth/#function-earth","title":"function earth","text":"<pre><code>inline naomi::bodies::earth::earth () \n</code></pre>"},{"location":"naomi/classnaomi_1_1bodies_1_1earth/#function-get_potential_partial_derivative-12","title":"function get_potential_partial_derivative [1/2]","text":"<pre><code>inline virtual auto naomi::bodies::earth::get_potential_partial_derivative (\n    Eigen::Vector3d position\n) override\n</code></pre> <p>Implements naomi::bodies::celestial_body::get_potential_partial_derivative</p>"},{"location":"naomi/classnaomi_1_1bodies_1_1earth/#function-get_potential_partial_derivative-22","title":"function get_potential_partial_derivative [2/2]","text":"<pre><code>inline virtual auto naomi::bodies::earth::get_potential_partial_derivative (\n    arma::vec position\n) override\n</code></pre> <p>Implements naomi::bodies::celestial_body::get_potential_partial_derivative</p>"},{"location":"naomi/classnaomi_1_1bodies_1_1earth/#function-earth_1","title":"function ~earth","text":"<pre><code>naomi::bodies::earth::~earth () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/bodies/earth.h</code></p>"},{"location":"naomi/namespacenaomi_1_1constants/","title":"Namespace naomi::constants","text":"<p>Namespace List &gt; naomi &gt; constants</p>"},{"location":"naomi/namespacenaomi_1_1constants/#public-attributes","title":"Public Attributes","text":"Type Name constexpr double EARTH_MU   = = 3.986004418*1e14 constexpr double EARTH_MU_KM   = = 3.986004418*1e5"},{"location":"naomi/namespacenaomi_1_1constants/#public-functions","title":"Public Functions","text":"Type Name const arma::vec3 MINUS_I ({-1, 0, 0})  const arma::vec3 MINUS_J ({0, -1, 0})  const arma::vec3 MINUS_K ({0, 0, -1})  const arma::vec3 PLUS_I ({1, 0, 0})  const arma::vec3 PLUS_J ({0, 1, 0})  const arma::vec3 PLUS_K ({0, 0, 1})"},{"location":"naomi/namespacenaomi_1_1constants/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"naomi/namespacenaomi_1_1constants/#variable-earth_mu","title":"variable EARTH_MU","text":"<pre><code>constexpr double naomi::constants::EARTH_MU;\n</code></pre>"},{"location":"naomi/namespacenaomi_1_1constants/#variable-earth_mu_km","title":"variable EARTH_MU_KM","text":"<pre><code>constexpr double naomi::constants::EARTH_MU_KM;\n</code></pre>"},{"location":"naomi/namespacenaomi_1_1constants/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/namespacenaomi_1_1constants/#function-minus_i","title":"function MINUS_I","text":"<pre><code>const arma::vec3 naomi::constants::MINUS_I (\n    {-1, 0, 0}\n) \n</code></pre>"},{"location":"naomi/namespacenaomi_1_1constants/#function-minus_j","title":"function MINUS_J","text":"<pre><code>const arma::vec3 naomi::constants::MINUS_J (\n    {0, -1, 0}\n) \n</code></pre>"},{"location":"naomi/namespacenaomi_1_1constants/#function-minus_k","title":"function MINUS_K","text":"<pre><code>const arma::vec3 naomi::constants::MINUS_K (\n    {0, 0, -1}\n) \n</code></pre>"},{"location":"naomi/namespacenaomi_1_1constants/#function-plus_i","title":"function PLUS_I","text":"<pre><code>const arma::vec3 naomi::constants::PLUS_I (\n    {1, 0, 0}\n) \n</code></pre>"},{"location":"naomi/namespacenaomi_1_1constants/#function-plus_j","title":"function PLUS_J","text":"<pre><code>const arma::vec3 naomi::constants::PLUS_J (\n    {0, 1, 0}\n) \n</code></pre>"},{"location":"naomi/namespacenaomi_1_1constants/#function-plus_k","title":"function PLUS_K","text":"<pre><code>const arma::vec3 naomi::constants::PLUS_K (\n    {0, 0, 1}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/constants.h</code></p>"},{"location":"naomi/namespacenaomi_1_1control/","title":"Namespace naomi::control","text":"<p>Namespace List &gt; naomi &gt; control</p>"},{"location":"naomi/namespacenaomi_1_1control/#classes","title":"Classes","text":"Type Name class control_input class controller class nadir_pointing_pid_controller class pid_controller <p>The documentation for this class was generated from the following file <code>include/control/controller.h</code></p>"},{"location":"naomi/classnaomi_1_1control_1_1control__input/","title":"Class naomi::control::control_input","text":"<p>ClassList &gt; naomi &gt; control &gt; control_input</p> <ul> <li><code>#include &lt;controller.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1control_1_1control__input/#public-functions","title":"Public Functions","text":"Type Name control_input (const arma::vec3 &amp; position_control_input, const quaternion_type &amp; attitude_control_input)"},{"location":"naomi/classnaomi_1_1control_1_1control__input/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1control_1_1control__input/#function-control_input","title":"function control_input","text":"<pre><code>inline naomi::control::control_input::control_input (\n    const arma::vec3 &amp; position_control_input,\n    const quaternion_type &amp; attitude_control_input\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/control/controller.h</code></p>"},{"location":"naomi/classnaomi_1_1control_1_1controller/","title":"Class naomi::control::controller","text":"<p>ClassList &gt; naomi &gt; control &gt; controller</p> <ul> <li><code>#include &lt;controller.h&gt;</code></li> </ul> <p>Inherited by the following classes: naomi::control::pid_controller</p>"},{"location":"naomi/classnaomi_1_1control_1_1controller/#public-functions","title":"Public Functions","text":"Type Name virtual control_input get_control_input (const vector_type &amp; state, const vector_type &amp; attitude, double t) = 0 virtual vector_type get_desired_state (const vector_type &amp; state, const vector_type &amp; attitude, double t) = 0 virtual void initialize (const vector_type &amp; state, const vector_type &amp; attitude, double t) = 0 virtual ~controller () = default"},{"location":"naomi/classnaomi_1_1control_1_1controller/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1control_1_1controller/#function-get_control_input","title":"function get_control_input","text":"<pre><code>virtual control_input naomi::control::controller::get_control_input (\n    const vector_type &amp; state,\n    const vector_type &amp; attitude,\n    double t\n) = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1control_1_1controller/#function-get_desired_state","title":"function get_desired_state","text":"<pre><code>virtual vector_type naomi::control::controller::get_desired_state (\n    const vector_type &amp; state,\n    const vector_type &amp; attitude,\n    double t\n) = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>state</code> Spacecraft state in a stacked vector with state in the inertial frame and attitude represented as a quaternion </li> <li><code>attitude</code> The spacecraft attitude in quaternion form </li> <li><code>t</code> current time </li> </ul> <p>Returns:</p> <p>control input </p>"},{"location":"naomi/classnaomi_1_1control_1_1controller/#function-initialize","title":"function initialize","text":"<pre><code>virtual void naomi::control::controller::initialize (\n    const vector_type &amp; state,\n    const vector_type &amp; attitude,\n    double t\n) = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1control_1_1controller/#function-controller","title":"function ~controller","text":"<pre><code>virtual naomi::control::controller::~controller () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/control/controller.h</code></p>"},{"location":"naomi/classnaomi_1_1control_1_1nadir__pointing__pid__controller/","title":"Class naomi::control::nadir_pointing_pid_controller","text":"<p>ClassList &gt; naomi &gt; control &gt; nadir_pointing_pid_controller</p> <ul> <li><code>#include &lt;pid_controller.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::control::pid_controller</p>"},{"location":"naomi/classnaomi_1_1control_1_1nadir__pointing__pid__controller/#public-functions","title":"Public Functions","text":"Type Name virtual vector_type get_desired_state (const vector_type &amp; state, const vector_type &amp; attitude, double t) override nadir_pointing_pid_controller (const arma::mat &amp; Kp, const arma::mat &amp; Ki, const arma::mat &amp; Kd)"},{"location":"naomi/classnaomi_1_1control_1_1nadir__pointing__pid__controller/#public-functions-inherited-from-naomicontrolpid_controller","title":"Public Functions inherited from naomi::control::pid_controller","text":"<p>See naomi::control::pid_controller</p> Type Name virtual control_input get_control_input (const vector_type &amp; state, const vector_type &amp; attitude, const double t) override virtual void initialize (const vector_type &amp; state, const vector_type &amp; attitude, const double t) override pid_controller (arma::mat Kp, arma::mat Ki, arma::mat Kd)  ~pid_controller () override"},{"location":"naomi/classnaomi_1_1control_1_1nadir__pointing__pid__controller/#public-functions-inherited-from-naomicontrolcontroller","title":"Public Functions inherited from naomi::control::controller","text":"<p>See naomi::control::controller</p> Type Name virtual control_input get_control_input (const vector_type &amp; state, const vector_type &amp; attitude, double t) = 0 virtual vector_type get_desired_state (const vector_type &amp; state, const vector_type &amp; attitude, double t) = 0 virtual void initialize (const vector_type &amp; state, const vector_type &amp; attitude, double t) = 0 virtual ~controller () = default"},{"location":"naomi/classnaomi_1_1control_1_1nadir__pointing__pid__controller/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1control_1_1nadir__pointing__pid__controller/#function-get_desired_state","title":"function get_desired_state","text":"<pre><code>inline virtual vector_type naomi::control::nadir_pointing_pid_controller::get_desired_state (\n    const vector_type &amp; state,\n    const vector_type &amp; attitude,\n    double t\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>state</code> Spacecraft state in a stacked vector with state in the inertial frame and attitude represented as a quaternion </li> <li><code>attitude</code> The spacecraft attitude in quaternion form </li> <li><code>t</code> current time </li> </ul> <p>Returns:</p> <p>control input </p> <p>Implements naomi::control::controller::get_desired_state</p>"},{"location":"naomi/classnaomi_1_1control_1_1nadir__pointing__pid__controller/#function-nadir_pointing_pid_controller","title":"function nadir_pointing_pid_controller","text":"<pre><code>inline naomi::control::nadir_pointing_pid_controller::nadir_pointing_pid_controller (\n    const arma::mat &amp; Kp,\n    const arma::mat &amp; Ki,\n    const arma::mat &amp; Kd\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/control/pid_controller.h</code></p>"},{"location":"naomi/classnaomi_1_1control_1_1pid__controller/","title":"Class naomi::control::pid_controller","text":"<p>ClassList &gt; naomi &gt; control &gt; pid_controller</p> <ul> <li><code>#include &lt;pid_controller.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::control::controller</p> <p>Inherited by the following classes: naomi::control::nadir_pointing_pid_controller</p>"},{"location":"naomi/classnaomi_1_1control_1_1pid__controller/#public-functions","title":"Public Functions","text":"Type Name virtual control_input get_control_input (const vector_type &amp; state, const vector_type &amp; attitude, const double t) override virtual void initialize (const vector_type &amp; state, const vector_type &amp; attitude, const double t) override pid_controller (arma::mat Kp, arma::mat Ki, arma::mat Kd)  ~pid_controller () override"},{"location":"naomi/classnaomi_1_1control_1_1pid__controller/#public-functions-inherited-from-naomicontrolcontroller","title":"Public Functions inherited from naomi::control::controller","text":"<p>See naomi::control::controller</p> Type Name virtual control_input get_control_input (const vector_type &amp; state, const vector_type &amp; attitude, double t) = 0 virtual vector_type get_desired_state (const vector_type &amp; state, const vector_type &amp; attitude, double t) = 0 virtual void initialize (const vector_type &amp; state, const vector_type &amp; attitude, double t) = 0 virtual ~controller () = default"},{"location":"naomi/classnaomi_1_1control_1_1pid__controller/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1control_1_1pid__controller/#function-get_control_input","title":"function get_control_input","text":"<pre><code>inline virtual control_input naomi::control::pid_controller::get_control_input (\n    const vector_type &amp; state,\n    const vector_type &amp; attitude,\n    const double t\n) override\n</code></pre> <p>Implements naomi::control::controller::get_control_input</p>"},{"location":"naomi/classnaomi_1_1control_1_1pid__controller/#function-initialize","title":"function initialize","text":"<pre><code>inline virtual void naomi::control::pid_controller::initialize (\n    const vector_type &amp; state,\n    const vector_type &amp; attitude,\n    const double t\n) override\n</code></pre> <p>Implements naomi::control::controller::initialize</p>"},{"location":"naomi/classnaomi_1_1control_1_1pid__controller/#function-pid_controller","title":"function pid_controller","text":"<pre><code>inline naomi::control::pid_controller::pid_controller (\n    arma::mat Kp,\n    arma::mat Ki,\n    arma::mat Kd\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1control_1_1pid__controller/#function-pid_controller_1","title":"function ~pid_controller","text":"<pre><code>naomi::control::pid_controller::~pid_controller () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/control/pid_controller.h</code></p>"},{"location":"naomi/namespacenaomi_1_1events/","title":"Namespace naomi::events","text":"<p>Namespace List &gt; naomi &gt; events</p>"},{"location":"naomi/namespacenaomi_1_1events/#classes","title":"Classes","text":"Type Name class apside_detector struct event class event_detector struct event_detector_condition class event_handler class time_detector"},{"location":"naomi/namespacenaomi_1_1events/#public-types","title":"Public Types","text":"Type Name enum EventDetectorTrigger typedef std::pair&lt; vector_type, double &gt; state_and_time_type"},{"location":"naomi/namespacenaomi_1_1events/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"naomi/namespacenaomi_1_1events/#enum-eventdetectortrigger","title":"enum EventDetectorTrigger","text":"<pre><code>enum naomi::events::EventDetectorTrigger {\n    INCREASING,\n    DECREASING,\n    ALL\n};\n</code></pre>"},{"location":"naomi/namespacenaomi_1_1events/#typedef-state_and_time_type","title":"typedef state_and_time_type","text":"<pre><code>typedef std::pair&lt;vector_type, double&gt; naomi::events::state_and_time_type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/propagators/event_detector.h</code></p>"},{"location":"naomi/classnaomi_1_1events_1_1apside__detector/","title":"Class naomi::events::apside_detector","text":"<p>ClassList &gt; naomi &gt; events &gt; apside_detector</p> <ul> <li><code>#include &lt;event_detector.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::events::event_detector</p>"},{"location":"naomi/classnaomi_1_1events_1_1apside__detector/#public-functions","title":"Public Functions","text":"Type Name apside_detector (const EventDetectorTrigger trigger)  virtual double g (const state_and_time_type &amp; sv) override const"},{"location":"naomi/classnaomi_1_1events_1_1apside__detector/#public-functions-inherited-from-naomieventsevent_detector","title":"Public Functions inherited from naomi::events::event_detector","text":"<p>See naomi::events::event_detector</p> Type Name event_detector (const EventDetectorTrigger trigger)  event_detector (const EventDetectorTrigger trigger, const double max_check_interval)  event_detector (const EventDetectorTrigger trigger, const double max_check_interval, const double abs_tol)  event_detector (const EventDetectorTrigger trigger, const double max_check_interval, const double abs_tol, const double rel_tol)  virtual double g (const state_and_time_type &amp; sv) const = 0 virtual void handle_event (const std::shared_ptr&lt; spacecraft &gt; &amp; sc, double t)  bool operator() (const state_and_time_type &amp; initial, const state_and_time_type &amp; final) const virtual ~event_detector () = default"},{"location":"naomi/classnaomi_1_1events_1_1apside__detector/#protected-attributes-inherited-from-naomieventsevent_detector","title":"Protected Attributes inherited from naomi::events::event_detector","text":"<p>See naomi::events::event_detector</p> Type Name bool m_is_active   = = true"},{"location":"naomi/classnaomi_1_1events_1_1apside__detector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1events_1_1apside__detector/#function-apside_detector","title":"function apside_detector","text":"<pre><code>inline explicit naomi::events::apside_detector::apside_detector (\n    const EventDetectorTrigger trigger\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1events_1_1apside__detector/#function-g","title":"function g","text":"<pre><code>inline virtual double naomi::events::apside_detector::g (\n    const state_and_time_type &amp; sv\n) override const\n</code></pre> <p>Implements naomi::events::event_detector::g</p> <p>The documentation for this class was generated from the following file <code>include/propagators/event_detector.h</code></p>"},{"location":"naomi/structnaomi_1_1events_1_1event/","title":"Struct naomi::events::event","text":"<p>ClassList &gt; naomi &gt; events &gt; event</p> <ul> <li><code>#include &lt;event_detector.h&gt;</code></li> </ul>"},{"location":"naomi/structnaomi_1_1events_1_1event/#public-attributes","title":"Public Attributes","text":"Type Name std::shared_ptr&lt; event_detector &gt; detector double time_occurred"},{"location":"naomi/structnaomi_1_1events_1_1event/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"naomi/structnaomi_1_1events_1_1event/#variable-detector","title":"variable detector","text":"<pre><code>std::shared_ptr&lt;event_detector&gt; naomi::events::event::detector;\n</code></pre>"},{"location":"naomi/structnaomi_1_1events_1_1event/#variable-time_occurred","title":"variable time_occurred","text":"<pre><code>double naomi::events::event::time_occurred;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/propagators/event_detector.h</code></p>"},{"location":"naomi/classnaomi_1_1events_1_1event__detector/","title":"Class naomi::events::event_detector","text":"<p>ClassList &gt; naomi &gt; events &gt; event_detector</p> <ul> <li><code>#include &lt;event_detector.h&gt;</code></li> </ul> <p>Inherited by the following classes: naomi::events::apside_detector,  naomi::events::time_detector,  naomi::maneuvers::maneuver_plan</p>"},{"location":"naomi/classnaomi_1_1events_1_1event__detector/#public-functions","title":"Public Functions","text":"Type Name event_detector (const EventDetectorTrigger trigger)  event_detector (const EventDetectorTrigger trigger, const double max_check_interval)  event_detector (const EventDetectorTrigger trigger, const double max_check_interval, const double abs_tol)  event_detector (const EventDetectorTrigger trigger, const double max_check_interval, const double abs_tol, const double rel_tol)  virtual double g (const state_and_time_type &amp; sv) const = 0 virtual void handle_event (const std::shared_ptr&lt; spacecraft &gt; &amp; sc, double t)  bool operator() (const state_and_time_type &amp; initial, const state_and_time_type &amp; final) const virtual ~event_detector () = default"},{"location":"naomi/classnaomi_1_1events_1_1event__detector/#protected-attributes","title":"Protected Attributes","text":"Type Name bool m_is_active   = = true"},{"location":"naomi/classnaomi_1_1events_1_1event__detector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1events_1_1event__detector/#function-event_detector-14","title":"function event_detector [1/4]","text":"<pre><code>inline explicit naomi::events::event_detector::event_detector (\n    const EventDetectorTrigger trigger\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1events_1_1event__detector/#function-event_detector-24","title":"function event_detector [2/4]","text":"<pre><code>inline naomi::events::event_detector::event_detector (\n    const EventDetectorTrigger trigger,\n    const double max_check_interval\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1events_1_1event__detector/#function-event_detector-34","title":"function event_detector [3/4]","text":"<pre><code>inline naomi::events::event_detector::event_detector (\n    const EventDetectorTrigger trigger,\n    const double max_check_interval,\n    const double abs_tol\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1events_1_1event__detector/#function-event_detector-44","title":"function event_detector [4/4]","text":"<pre><code>inline naomi::events::event_detector::event_detector (\n    const EventDetectorTrigger trigger,\n    const double max_check_interval,\n    const double abs_tol,\n    const double rel_tol\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1events_1_1event__detector/#function-g","title":"function g","text":"<pre><code>virtual double naomi::events::event_detector::g (\n    const state_and_time_type &amp; sv\n) const = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1events_1_1event__detector/#function-handle_event","title":"function handle_event","text":"<pre><code>inline virtual void naomi::events::event_detector::handle_event (\n    const std::shared_ptr&lt; spacecraft &gt; &amp; sc,\n    double t\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1events_1_1event__detector/#function-operator","title":"function operator()","text":"<pre><code>inline bool naomi::events::event_detector::operator() (\n    const state_and_time_type &amp; initial,\n    const state_and_time_type &amp; final\n) const\n</code></pre>"},{"location":"naomi/classnaomi_1_1events_1_1event__detector/#function-event_detector","title":"function ~event_detector","text":"<pre><code>virtual naomi::events::event_detector::~event_detector () = default\n</code></pre>"},{"location":"naomi/classnaomi_1_1events_1_1event__detector/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"naomi/classnaomi_1_1events_1_1event__detector/#variable-m_is_active","title":"variable m_is_active","text":"<pre><code>bool naomi::events::event_detector::m_is_active;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/propagators/event_detector.h</code></p>"},{"location":"naomi/structnaomi_1_1events_1_1event__detector__condition/","title":"Struct naomi::events::event_detector_condition","text":"<p>ClassList &gt; naomi &gt; events &gt; event_detector_condition</p> <ul> <li><code>#include &lt;event_detector.h&gt;</code></li> </ul>"},{"location":"naomi/structnaomi_1_1events_1_1event__detector__condition/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; double &gt; m_detector_g std::vector&lt; apside_detector &gt; m_detectors"},{"location":"naomi/structnaomi_1_1events_1_1event__detector__condition/#public-functions","title":"Public Functions","text":"Type Name event_detector_condition (apside_detector &amp; ad)"},{"location":"naomi/structnaomi_1_1events_1_1event__detector__condition/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"naomi/structnaomi_1_1events_1_1event__detector__condition/#variable-m_detector_g","title":"variable m_detector_g","text":"<pre><code>std::vector&lt;double&gt; naomi::events::event_detector_condition::m_detector_g;\n</code></pre>"},{"location":"naomi/structnaomi_1_1events_1_1event__detector__condition/#variable-m_detectors","title":"variable m_detectors","text":"<pre><code>std::vector&lt;apside_detector&gt; naomi::events::event_detector_condition::m_detectors;\n</code></pre>"},{"location":"naomi/structnaomi_1_1events_1_1event__detector__condition/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/structnaomi_1_1events_1_1event__detector__condition/#function-event_detector_condition","title":"function event_detector_condition","text":"<pre><code>inline explicit naomi::events::event_detector_condition::event_detector_condition (\n    apside_detector &amp; ad\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/propagators/event_detector.h</code></p>"},{"location":"naomi/classnaomi_1_1events_1_1event__handler/","title":"Class naomi::events::event_handler","text":"<p>ClassList &gt; naomi &gt; events &gt; event_handler</p> <ul> <li><code>#include &lt;event_handler.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1events_1_1event__handler/#public-functions","title":"Public Functions","text":"Type Name virtual void handle_event (const std::shared_ptr&lt; spacecraft &gt; &amp; sc, double t) = 0 virtual ~event_handler () = default"},{"location":"naomi/classnaomi_1_1events_1_1event__handler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1events_1_1event__handler/#function-handle_event","title":"function handle_event","text":"<pre><code>virtual void naomi::events::event_handler::handle_event (\n    const std::shared_ptr&lt; spacecraft &gt; &amp; sc,\n    double t\n) = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1events_1_1event__handler/#function-event_handler","title":"function ~event_handler","text":"<pre><code>virtual naomi::events::event_handler::~event_handler () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/propagators/event_handler.h</code></p>"},{"location":"naomi/classnaomi_1_1events_1_1time__detector/","title":"Class naomi::events::time_detector","text":"<p>ClassList &gt; naomi &gt; events &gt; time_detector</p> <ul> <li><code>#include &lt;event_detector.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::events::event_detector</p>"},{"location":"naomi/classnaomi_1_1events_1_1time__detector/#public-functions","title":"Public Functions","text":"Type Name virtual double g (const state_and_time_type &amp; sv) override const time_detector (double time)"},{"location":"naomi/classnaomi_1_1events_1_1time__detector/#public-functions-inherited-from-naomieventsevent_detector","title":"Public Functions inherited from naomi::events::event_detector","text":"<p>See naomi::events::event_detector</p> Type Name event_detector (const EventDetectorTrigger trigger)  event_detector (const EventDetectorTrigger trigger, const double max_check_interval)  event_detector (const EventDetectorTrigger trigger, const double max_check_interval, const double abs_tol)  event_detector (const EventDetectorTrigger trigger, const double max_check_interval, const double abs_tol, const double rel_tol)  virtual double g (const state_and_time_type &amp; sv) const = 0 virtual void handle_event (const std::shared_ptr&lt; spacecraft &gt; &amp; sc, double t)  bool operator() (const state_and_time_type &amp; initial, const state_and_time_type &amp; final) const virtual ~event_detector () = default"},{"location":"naomi/classnaomi_1_1events_1_1time__detector/#protected-attributes-inherited-from-naomieventsevent_detector","title":"Protected Attributes inherited from naomi::events::event_detector","text":"<p>See naomi::events::event_detector</p> Type Name bool m_is_active   = = true"},{"location":"naomi/classnaomi_1_1events_1_1time__detector/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1events_1_1time__detector/#function-g","title":"function g","text":"<pre><code>inline virtual double naomi::events::time_detector::g (\n    const state_and_time_type &amp; sv\n) override const\n</code></pre> <p>Implements naomi::events::event_detector::g</p>"},{"location":"naomi/classnaomi_1_1events_1_1time__detector/#function-time_detector","title":"function time_detector","text":"<pre><code>inline explicit naomi::events::time_detector::time_detector (\n    double time\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/propagators/event_detector.h</code></p>"},{"location":"naomi/namespacenaomi_1_1forces/","title":"Namespace naomi::forces","text":"<p>Namespace List &gt; naomi &gt; forces</p>"},{"location":"naomi/namespacenaomi_1_1forces/#classes","title":"Classes","text":"Type Name class equations_of_motion class force_model class two_body_force_model class two_body_force_model_eoms class two_body_rot_force_model <p>The documentation for this class was generated from the following file <code>include/forces/force_model.h</code></p>"},{"location":"naomi/classnaomi_1_1forces_1_1equations__of__motion/","title":"Class naomi::forces::equations_of_motion","text":"<p>ClassList &gt; naomi &gt; forces &gt; equations_of_motion</p> <ul> <li><code>#include &lt;force_model.h&gt;</code></li> </ul> <p>Inherited by the following classes: naomi::attitude::torque_free_eoms,  naomi::forces::two_body_force_model_eoms</p>"},{"location":"naomi/classnaomi_1_1forces_1_1equations__of__motion/#public-functions","title":"Public Functions","text":"Type Name virtual vector_type get_derivative (const vector_type &amp; state, double t) const = 0 virtual ~equations_of_motion () = default"},{"location":"naomi/classnaomi_1_1forces_1_1equations__of__motion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1forces_1_1equations__of__motion/#function-get_derivative","title":"function get_derivative","text":"<pre><code>virtual vector_type naomi::forces::equations_of_motion::get_derivative (\n    const vector_type &amp; state,\n    double t\n) const = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1forces_1_1equations__of__motion/#function-equations_of_motion","title":"function ~equations_of_motion","text":"<pre><code>virtual naomi::forces::equations_of_motion::~equations_of_motion () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/forces/force_model.h</code></p>"},{"location":"naomi/classnaomi_1_1forces_1_1force__model/","title":"Class naomi::forces::force_model","text":"<p>ClassList &gt; naomi &gt; forces &gt; force_model</p> <ul> <li><code>#include &lt;force_model.h&gt;</code></li> </ul> <p>Inherited by the following classes: naomi::forces::two_body_force_model,  naomi::forces::two_body_rot_force_model</p>"},{"location":"naomi/classnaomi_1_1forces_1_1force__model/#public-functions","title":"Public Functions","text":"Type Name virtual void operator() (const vector_type &amp; x, vector_type &amp; dxdt, double t) const = 0 virtual ~force_model () = default"},{"location":"naomi/classnaomi_1_1forces_1_1force__model/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1forces_1_1force__model/#function-operator","title":"function operator()","text":"<pre><code>virtual void naomi::forces::force_model::operator() (\n    const vector_type &amp; x,\n    vector_type &amp; dxdt,\n    double t\n) const = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1forces_1_1force__model/#function-force_model","title":"function ~force_model","text":"<pre><code>virtual naomi::forces::force_model::~force_model () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/forces/force_model.h</code></p>"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model/","title":"Class naomi::forces::two_body_force_model","text":"<p>ClassList &gt; naomi &gt; forces &gt; two_body_force_model</p> <ul> <li><code>#include &lt;two_body_force_model.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::forces::force_model</p>"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model/#public-functions","title":"Public Functions","text":"Type Name virtual void operator() (const vector_type &amp; x, vector_type &amp; dxdt, double t) override const two_body_force_model (const std::shared_ptr&lt; celestial_body &gt; &amp; central_body)  ~two_body_force_model () override"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model/#public-functions-inherited-from-naomiforcesforce_model","title":"Public Functions inherited from naomi::forces::force_model","text":"<p>See naomi::forces::force_model</p> Type Name virtual void operator() (const vector_type &amp; x, vector_type &amp; dxdt, double t) const = 0 virtual ~force_model () = default"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model/#function-operator","title":"function operator()","text":"<pre><code>inline virtual void naomi::forces::two_body_force_model::operator() (\n    const vector_type &amp; x,\n    vector_type &amp; dxdt,\n    double t\n) override const\n</code></pre> <p>Implements naomi::forces::force_model::operator()</p>"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model/#function-two_body_force_model","title":"function two_body_force_model","text":"<pre><code>inline explicit naomi::forces::two_body_force_model::two_body_force_model (\n    const std::shared_ptr&lt; celestial_body &gt; &amp; central_body\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model/#function-two_body_force_model_1","title":"function ~two_body_force_model","text":"<pre><code>naomi::forces::two_body_force_model::~two_body_force_model () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/forces/two_body_force_model.h</code></p>"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model__eoms/","title":"Class naomi::forces::two_body_force_model_eoms","text":"<p>ClassList &gt; naomi &gt; forces &gt; two_body_force_model_eoms</p> <ul> <li><code>#include &lt;two_body_force_model.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::forces::equations_of_motion</p>"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model__eoms/#public-functions","title":"Public Functions","text":"Type Name virtual vector_type get_derivative (const vector_type &amp; state, double t) override const two_body_force_model_eoms (const std::shared_ptr&lt; celestial_body &gt; &amp; central_body)  ~two_body_force_model_eoms () override"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model__eoms/#public-functions-inherited-from-naomiforcesequations_of_motion","title":"Public Functions inherited from naomi::forces::equations_of_motion","text":"<p>See naomi::forces::equations_of_motion</p> Type Name virtual vector_type get_derivative (const vector_type &amp; state, double t) const = 0 virtual ~equations_of_motion () = default"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model__eoms/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model__eoms/#function-get_derivative","title":"function get_derivative","text":"<pre><code>inline virtual vector_type naomi::forces::two_body_force_model_eoms::get_derivative (\n    const vector_type &amp; state,\n    double t\n) override const\n</code></pre> <p>Implements naomi::forces::equations_of_motion::get_derivative</p>"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model__eoms/#function-two_body_force_model_eoms","title":"function two_body_force_model_eoms","text":"<pre><code>inline explicit naomi::forces::two_body_force_model_eoms::two_body_force_model_eoms (\n    const std::shared_ptr&lt; celestial_body &gt; &amp; central_body\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__force__model__eoms/#function-two_body_force_model_eoms_1","title":"function ~two_body_force_model_eoms","text":"<pre><code>naomi::forces::two_body_force_model_eoms::~two_body_force_model_eoms () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/forces/two_body_force_model.h</code></p>"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__rot__force__model/","title":"Class naomi::forces::two_body_rot_force_model","text":"<p>ClassList &gt; naomi &gt; forces &gt; two_body_rot_force_model</p> <ul> <li><code>#include &lt;two_body_rot_force_model.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::forces::force_model</p>"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__rot__force__model/#public-functions","title":"Public Functions","text":"Type Name virtual void operator() (const vector_type &amp; x, vector_type &amp; dxdt, double t) override const two_body_rot_force_model (const std::shared_ptr&lt; celestial_body &gt; &amp; central_body)  ~two_body_rot_force_model () override"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__rot__force__model/#public-functions-inherited-from-naomiforcesforce_model","title":"Public Functions inherited from naomi::forces::force_model","text":"<p>See naomi::forces::force_model</p> Type Name virtual void operator() (const vector_type &amp; x, vector_type &amp; dxdt, double t) const = 0 virtual ~force_model () = default"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__rot__force__model/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1forces_1_1two__body__rot__force__model/#function-operator","title":"function operator()","text":"<pre><code>inline virtual void naomi::forces::two_body_rot_force_model::operator() (\n    const vector_type &amp; x,\n    vector_type &amp; dxdt,\n    double t\n) override const\n</code></pre> <p>Implements naomi::forces::force_model::operator()</p>"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__rot__force__model/#function-two_body_rot_force_model","title":"function two_body_rot_force_model","text":"<pre><code>inline explicit naomi::forces::two_body_rot_force_model::two_body_rot_force_model (\n    const std::shared_ptr&lt; celestial_body &gt; &amp; central_body\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1forces_1_1two__body__rot__force__model/#function-two_body_rot_force_model_1","title":"function ~two_body_rot_force_model","text":"<pre><code>naomi::forces::two_body_rot_force_model::~two_body_rot_force_model () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/forces/two_body_rot_force_model.h</code></p>"},{"location":"naomi/namespacenaomi_1_1frames/","title":"Namespace naomi::frames","text":"<p>Namespace List &gt; naomi &gt; frames</p>"},{"location":"naomi/namespacenaomi_1_1frames/#classes","title":"Classes","text":"Type Name class frame <p>The documentation for this class was generated from the following file <code>include/frames/frame.h</code></p>"},{"location":"naomi/classnaomi_1_1frames_1_1frame/","title":"Class naomi::frames::frame","text":"<p>ClassList &gt; naomi &gt; frames &gt; frame</p> <ul> <li><code>#include &lt;frame.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1frames_1_1frame/#public-functions","title":"Public Functions","text":"Type Name virtual vector_type get_transform_to (const frame &amp; other) = 0"},{"location":"naomi/classnaomi_1_1frames_1_1frame/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1frames_1_1frame/#function-get_transform_to","title":"function get_transform_to","text":"<pre><code>virtual vector_type naomi::frames::frame::get_transform_to (\n    const frame &amp; other\n) = 0\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/frames/frame.h</code></p>"},{"location":"naomi/namespacenaomi_1_1geometry/","title":"Namespace naomi::geometry","text":"<p>Namespace List &gt; naomi &gt; geometry</p>"},{"location":"naomi/namespacenaomi_1_1geometry/#classes","title":"Classes","text":"Type Name class body_shape struct face <p>The documentation for this class was generated from the following file <code>include/spacecraft/body_shape.h</code></p>"},{"location":"naomi/classnaomi_1_1geometry_1_1body__shape/","title":"Class naomi::geometry::body_shape","text":"<p>ClassList &gt; naomi &gt; geometry &gt; body_shape</p> <ul> <li><code>#include &lt;body_shape.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1geometry_1_1body__shape/#public-functions","title":"Public Functions","text":"Type Name body_shape (const std::vector&lt; arma::vec3 &gt; &amp; verts, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp; faces, const double mass, const double density=1.0)  arma::vec3 get_center_of_mass () const arma::mat33 get_inertia_tensor ()"},{"location":"naomi/classnaomi_1_1geometry_1_1body__shape/#public-static-functions","title":"Public Static Functions","text":"Type Name body_shape make_rectangle (double l, double w, double h, const double mass, const arma::vec3 &amp; origin={0, 0, 0})"},{"location":"naomi/classnaomi_1_1geometry_1_1body__shape/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1geometry_1_1body__shape/#function-body_shape","title":"function body_shape","text":"<pre><code>inline naomi::geometry::body_shape::body_shape (\n    const std::vector&lt; arma::vec3 &gt; &amp; verts,\n    const std::vector&lt; std::vector&lt; int &gt; &gt; &amp; faces,\n    const double mass,\n    const double density=1.0\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1geometry_1_1body__shape/#function-get_center_of_mass","title":"function get_center_of_mass","text":"<pre><code>inline arma::vec3 naomi::geometry::body_shape::get_center_of_mass () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1geometry_1_1body__shape/#function-get_inertia_tensor","title":"function get_inertia_tensor","text":"<pre><code>inline arma::mat33 naomi::geometry::body_shape::get_inertia_tensor () \n</code></pre>"},{"location":"naomi/classnaomi_1_1geometry_1_1body__shape/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1geometry_1_1body__shape/#function-make_rectangle","title":"function make_rectangle","text":"<pre><code>static inline body_shape naomi::geometry::body_shape::make_rectangle (\n    double l,\n    double w,\n    double h,\n    const double mass,\n    const arma::vec3 &amp; origin={0, 0, 0}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/spacecraft/body_shape.h</code></p>"},{"location":"naomi/structnaomi_1_1geometry_1_1face/","title":"Struct naomi::geometry::face","text":"<p>ClassList &gt; naomi &gt; geometry &gt; face</p> <ul> <li><code>#include &lt;body_shape.h&gt;</code></li> </ul>"},{"location":"naomi/structnaomi_1_1geometry_1_1face/#public-attributes","title":"Public Attributes","text":"Type Name arma::vec3 norm std::vector&lt; int &gt; verts double w"},{"location":"naomi/structnaomi_1_1geometry_1_1face/#public-functions","title":"Public Functions","text":"Type Name face (std::vector&lt; int &gt; v, const double w, const arma::vec3 &amp; normal)"},{"location":"naomi/structnaomi_1_1geometry_1_1face/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"naomi/structnaomi_1_1geometry_1_1face/#variable-norm","title":"variable norm","text":"<pre><code>arma::vec3 naomi::geometry::face::norm;\n</code></pre>"},{"location":"naomi/structnaomi_1_1geometry_1_1face/#variable-verts","title":"variable verts","text":"<pre><code>std::vector&lt;int&gt; naomi::geometry::face::verts;\n</code></pre>"},{"location":"naomi/structnaomi_1_1geometry_1_1face/#variable-w","title":"variable w","text":"<pre><code>double naomi::geometry::face::w;\n</code></pre>"},{"location":"naomi/structnaomi_1_1geometry_1_1face/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/structnaomi_1_1geometry_1_1face/#function-face","title":"function face","text":"<pre><code>inline naomi::geometry::face::face (\n    std::vector&lt; int &gt; v,\n    const double w,\n    const arma::vec3 &amp; normal\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/spacecraft/body_shape.h</code></p>"},{"location":"naomi/namespacenaomi_1_1maneuvers/","title":"Namespace naomi::maneuvers","text":"<p>Namespace List &gt; naomi &gt; maneuvers</p>"},{"location":"naomi/namespacenaomi_1_1maneuvers/#classes","title":"Classes","text":"Type Name class bielliptic_hohmann_transfer class hohmann_transfer A class to compute the optimal burns for a Hohmann Transfer using equations as described by orbital-mechanics.space . class maneuver class maneuver_plan class no_such_maneuver_exception <p>The documentation for this class was generated from the following file <code>include/maneuvers/hohmann_transfer.h</code></p>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1bielliptic__hohmann__transfer/","title":"Class naomi::maneuvers::bielliptic_hohmann_transfer","text":"<p>ClassList &gt; naomi &gt; maneuvers &gt; bielliptic_hohmann_transfer</p> <ul> <li><code>#include &lt;hohmann_transfer.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1bielliptic__hohmann__transfer/#public-functions","title":"Public Functions","text":"Type Name bielliptic_hohmann_transfer (vector_type &amp; initial_state, double target_sma, double transfer_magnitude)  bielliptic_hohmann_transfer (const double initial_sma, const double target_sma, const double transfer_radius)  auto get_dvs () const auto get_maneuver_plan (double start_time=0.0) const auto get_total_dv () const auto get_transit_time () const"},{"location":"naomi/classnaomi_1_1maneuvers_1_1bielliptic__hohmann__transfer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1maneuvers_1_1bielliptic__hohmann__transfer/#function-bielliptic_hohmann_transfer-12","title":"function bielliptic_hohmann_transfer [1/2]","text":"<pre><code>inline naomi::maneuvers::bielliptic_hohmann_transfer::bielliptic_hohmann_transfer (\n    vector_type &amp; initial_state,\n    double target_sma,\n    double transfer_magnitude\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1bielliptic__hohmann__transfer/#function-bielliptic_hohmann_transfer-22","title":"function bielliptic_hohmann_transfer [2/2]","text":"<pre><code>inline naomi::maneuvers::bielliptic_hohmann_transfer::bielliptic_hohmann_transfer (\n    const double initial_sma,\n    const double target_sma,\n    const double transfer_radius\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1bielliptic__hohmann__transfer/#function-get_dvs","title":"function get_dvs","text":"<pre><code>inline auto naomi::maneuvers::bielliptic_hohmann_transfer::get_dvs () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1bielliptic__hohmann__transfer/#function-get_maneuver_plan","title":"function get_maneuver_plan","text":"<pre><code>inline auto naomi::maneuvers::bielliptic_hohmann_transfer::get_maneuver_plan (\n    double start_time=0.0\n) const\n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1bielliptic__hohmann__transfer/#function-get_total_dv","title":"function get_total_dv","text":"<pre><code>inline auto naomi::maneuvers::bielliptic_hohmann_transfer::get_total_dv () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1bielliptic__hohmann__transfer/#function-get_transit_time","title":"function get_transit_time","text":"<pre><code>inline auto naomi::maneuvers::bielliptic_hohmann_transfer::get_transit_time () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/maneuvers/hohmann_transfer.h</code></p>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1hohmann__transfer/","title":"Class naomi::maneuvers::hohmann_transfer","text":"<p>ClassList &gt; naomi &gt; maneuvers &gt; hohmann_transfer</p> <p>A class to compute the optimal burns for a Hohmann Transfer using equations as described by orbital-mechanics.space .More...</p> <ul> <li><code>#include &lt;hohmann_transfer.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1hohmann__transfer/#public-functions","title":"Public Functions","text":"Type Name auto get_dvs () constGet the \\(\\Delta{v}\\) for each maneuver ordered by the sequence of the maneuvers. auto get_maneuver_plan (double start_time=0) Generate a maneuver plan that can be used in simulations to perform a Hohmann Transfer. auto get_total_dv () constGet the combined \\(\\Delta{v}\\) of all maneuvers. auto get_transit_time () constGet the duration of the transit from the initial orbit to the target orbit. hohmann_transfer (vector_type initial_state, double target_radius) Constructor with provided state vector. hohmann_transfer (const double initial_radius, const double target_radius) Constructor only requiring the radius of initial and target orbits."},{"location":"naomi/classnaomi_1_1maneuvers_1_1hohmann__transfer/#detailed-description","title":"Detailed Description","text":"<p>The initial and target orbits for a Hohmann Transfer must be circular, as such the initial velocity (\\(v\\\\_i\\)) and final velocity (\\(v\\\\_f\\)) are computed with</p> \\[ v\\\\_{circular} = \\sqrt{\\frac{\\mu}{r}} \\] <p>The velocity of the transfer orbit apoapsis (\\(v\\_{ta}\\)) and periapsis (\\(v\\_{tp}\\)) are computed using the vis-viva equation.</p> \\[ v\\\\_{tp} = \\sqrt{\\mu\\left(\\frac{2}{r\\\\_{tp}} - \\frac{1}{a\\\\_{t}}\\right)} \\] \\[ v\\\\_{ta} = \\sqrt{\\mu\\left(\\frac{2}{r\\\\_{ta}} - \\frac{1}{a\\\\_{t}}\\right)} \\] <p>And the \\(\\Delta{v}\\) is computed from the differences between those velocities</p> \\[ \\Delta{v}= \\begin{cases} \\left\\|v\\\\_f - v\\\\_{ta}\\right\\| + \\left\\|v\\\\_i - v\\\\_{tp}\\right\\|,&amp; \\text{if} \\left(r\\\\_i &lt; r\\\\_f\\right) \\\\ \\left\\|v\\\\_f - v\\\\_{tp}\\right\\| + \\left\\|v\\\\_i - v\\\\_{ta}\\right\\|,&amp; \\text{if} \\left(r\\\\_f &lt; r\\\\_i\\right) \\end{cases} \\]"},{"location":"naomi/classnaomi_1_1maneuvers_1_1hohmann__transfer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1maneuvers_1_1hohmann__transfer/#function-get_dvs","title":"function get_dvs","text":"<p>Get the \\(\\Delta{v}\\) for each maneuver ordered by the sequence of the maneuvers. <pre><code>inline auto naomi::maneuvers::hohmann_transfer::get_dvs () const\n</code></pre></p> <p>Returns:</p> <p>A vector of doubles containing the \\(\\Delta{v}\\) of each maneuver </p>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1hohmann__transfer/#function-get_maneuver_plan","title":"function get_maneuver_plan","text":"<p>Generate a maneuver plan that can be used in simulations to perform a Hohmann Transfer. <pre><code>inline auto naomi::maneuvers::hohmann_transfer::get_maneuver_plan (\n    double start_time=0\n) \n</code></pre></p> <p>TODO: Is start time relative to simulation start the right argument here? </p> <p>Parameters:</p> <ul> <li><code>start_time</code> Time at which to start the maneuver relative to the beginning of a simulation </li> </ul> <p>Returns:</p> <p>Shared pointer to a maneuver plan </p>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1hohmann__transfer/#function-get_total_dv","title":"function get_total_dv","text":"<p>Get the combined \\(\\Delta{v}\\) of all maneuvers. <pre><code>inline auto naomi::maneuvers::hohmann_transfer::get_total_dv () const\n</code></pre></p> <p>Returns:</p> <p>The total \\(\\Delta{v}\\) </p>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1hohmann__transfer/#function-get_transit_time","title":"function get_transit_time","text":"<p>Get the duration of the transit from the initial orbit to the target orbit. <pre><code>inline auto naomi::maneuvers::hohmann_transfer::get_transit_time () const\n</code></pre></p> <p>Returns:</p> <p>The transit time in seconds </p>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1hohmann__transfer/#function-hohmann_transfer-12","title":"function hohmann_transfer [1/2]","text":"<p>Constructor with provided state vector. <pre><code>inline naomi::maneuvers::hohmann_transfer::hohmann_transfer (\n    vector_type initial_state,\n    double target_radius\n) \n</code></pre></p> <p>Given the current state of a spacecraft, create a Hohmann Transfer trajectory to reach an orbit with the desired radius. This assumes the current orbit is circular and will throw an exception if it is not.</p> <p>Parameters:</p> <ul> <li><code>initial_state</code> The initial state as a 6-dimensional state vector with position and velocity in the ECI frame </li> <li><code>target_radius</code> The radius of the desired orbit in meters </li> </ul>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1hohmann__transfer/#function-hohmann_transfer-22","title":"function hohmann_transfer [2/2]","text":"<p>Constructor only requiring the radius of initial and target orbits. <pre><code>inline naomi::maneuvers::hohmann_transfer::hohmann_transfer (\n    const double initial_radius,\n    const double target_radius\n) \n</code></pre></p> <p>Given the radius of an initial orbit, create a Hohmann Transfer trajectory to reach an orbit with the desired radius. This requires both initial and target orbits are circular so this will generate orbital velocities for circular orbits.</p> <p>Parameters:</p> <ul> <li><code>initial_radius</code> The radius of the initial orbit in meters </li> <li><code>target_radius</code> The radius of the target orbit in meters </li> </ul> <p>The documentation for this class was generated from the following file <code>include/maneuvers/hohmann_transfer.h</code></p>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver/","title":"Class naomi::maneuvers::maneuver","text":"<p>ClassList &gt; naomi &gt; maneuvers &gt; maneuver</p> <ul> <li><code>#include &lt;maneuver.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver/#public-functions","title":"Public Functions","text":"Type Name vector_type get_control_input (double dt, spacecraft_state &amp; state) const auto get_delta_v () const auto get_delta_v_mag () const auto get_direction () const auto get_trigger () const maneuver (const double dv, const arma::vec3 &amp; dir, std::shared_ptr&lt; event_detector &gt; &amp; rt)"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver/#function-get_control_input","title":"function get_control_input","text":"<pre><code>inline vector_type naomi::maneuvers::maneuver::get_control_input (\n    double dt,\n    spacecraft_state &amp; state\n) const\n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver/#function-get_delta_v","title":"function get_delta_v","text":"<pre><code>inline auto naomi::maneuvers::maneuver::get_delta_v () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver/#function-get_delta_v_mag","title":"function get_delta_v_mag","text":"<pre><code>inline auto naomi::maneuvers::maneuver::get_delta_v_mag () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver/#function-get_direction","title":"function get_direction","text":"<pre><code>inline auto naomi::maneuvers::maneuver::get_direction () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver/#function-get_trigger","title":"function get_trigger","text":"<pre><code>inline auto naomi::maneuvers::maneuver::get_trigger () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver/#function-maneuver","title":"function maneuver","text":"<pre><code>inline naomi::maneuvers::maneuver::maneuver (\n    const double dv,\n    const arma::vec3 &amp; dir,\n    std::shared_ptr&lt; event_detector &gt; &amp; rt\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver/#friends-documentation","title":"Friends Documentation","text":""},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline auto naomi::maneuvers::maneuver::operator&lt;&lt; (\n    std::ostream &amp; output,\n    const maneuver &amp; maneuver\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/maneuvers/maneuver.h</code></p>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/","title":"Class naomi::maneuvers::maneuver_plan","text":"<p>ClassList &gt; naomi &gt; maneuvers &gt; maneuver_plan</p> <ul> <li><code>#include &lt;maneuver_plan.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::events::event_detector</p>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#public-functions","title":"Public Functions","text":"Type Name void execute_maneuver (const std::shared_ptr&lt; spacecraft &gt; &amp; sc)  virtual double g (const state_and_time_type &amp; sv) override const vector_type get_control_input (const double dt, spacecraft_state &amp; state)  auto get_maneuvers ()  auto get_total_delta_v () const virtual void handle_event (const std::shared_ptr&lt; spacecraft &gt; &amp; sc, double t) override maneuver_plan (const std::vector&lt; maneuver &gt; &amp; maneuvers)  maneuver_plan (const maneuver_plan &amp; other)  maneuver_plan (maneuver_plan &amp;&amp; other) noexcept maneuver_plan &amp; operator= (const maneuver_plan &amp; other)  maneuver_plan &amp; operator= (maneuver_plan &amp;&amp; other) noexcept auto pop_stage ()"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#public-functions-inherited-from-naomieventsevent_detector","title":"Public Functions inherited from naomi::events::event_detector","text":"<p>See naomi::events::event_detector</p> Type Name event_detector (const EventDetectorTrigger trigger)  event_detector (const EventDetectorTrigger trigger, const double max_check_interval)  event_detector (const EventDetectorTrigger trigger, const double max_check_interval, const double abs_tol)  event_detector (const EventDetectorTrigger trigger, const double max_check_interval, const double abs_tol, const double rel_tol)  virtual double g (const state_and_time_type &amp; sv) const = 0 virtual void handle_event (const std::shared_ptr&lt; spacecraft &gt; &amp; sc, double t)  bool operator() (const state_and_time_type &amp; initial, const state_and_time_type &amp; final) const virtual ~event_detector () = default"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#protected-attributes-inherited-from-naomieventsevent_detector","title":"Protected Attributes inherited from naomi::events::event_detector","text":"<p>See naomi::events::event_detector</p> Type Name bool m_is_active   = = true"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#function-execute_maneuver","title":"function execute_maneuver","text":"<pre><code>void naomi::maneuvers::maneuver_plan::execute_maneuver (\n    const std::shared_ptr&lt; spacecraft &gt; &amp; sc\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#function-g","title":"function g","text":"<pre><code>inline virtual double naomi::maneuvers::maneuver_plan::g (\n    const state_and_time_type &amp; sv\n) override const\n</code></pre> <p>Implements naomi::events::event_detector::g</p>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#function-get_control_input","title":"function get_control_input","text":"<pre><code>inline vector_type naomi::maneuvers::maneuver_plan::get_control_input (\n    const double dt,\n    spacecraft_state &amp; state\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#function-get_maneuvers","title":"function get_maneuvers","text":"<pre><code>inline auto naomi::maneuvers::maneuver_plan::get_maneuvers () \n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#function-get_total_delta_v","title":"function get_total_delta_v","text":"<pre><code>inline auto naomi::maneuvers::maneuver_plan::get_total_delta_v () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#function-handle_event","title":"function handle_event","text":"<pre><code>inline virtual void naomi::maneuvers::maneuver_plan::handle_event (\n    const std::shared_ptr&lt; spacecraft &gt; &amp; sc,\n    double t\n) override\n</code></pre> <p>Implements naomi::events::event_detector::handle_event</p>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#function-maneuver_plan-13","title":"function maneuver_plan [1/3]","text":"<pre><code>inline explicit naomi::maneuvers::maneuver_plan::maneuver_plan (\n    const std::vector&lt; maneuver &gt; &amp; maneuvers\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#function-maneuver_plan-23","title":"function maneuver_plan [2/3]","text":"<pre><code>inline naomi::maneuvers::maneuver_plan::maneuver_plan (\n    const maneuver_plan &amp; other\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#function-maneuver_plan-33","title":"function maneuver_plan [3/3]","text":"<pre><code>inline naomi::maneuvers::maneuver_plan::maneuver_plan (\n    maneuver_plan &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#function-operator","title":"function operator=","text":"<pre><code>inline maneuver_plan &amp; naomi::maneuvers::maneuver_plan::operator= (\n    const maneuver_plan &amp; other\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#function-operator_1","title":"function operator=","text":"<pre><code>inline maneuver_plan &amp; naomi::maneuvers::maneuver_plan::operator= (\n    maneuver_plan &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#function-pop_stage","title":"function pop_stage","text":"<pre><code>inline auto naomi::maneuvers::maneuver_plan::pop_stage () \n</code></pre>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#friends-documentation","title":"Friends Documentation","text":""},{"location":"naomi/classnaomi_1_1maneuvers_1_1maneuver__plan/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>inline auto naomi::maneuvers::maneuver_plan::operator&lt;&lt; (\n    std::ostream &amp; output,\n    const maneuver_plan &amp; mp\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/maneuvers/maneuver_plan.h</code></p>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1no__such__maneuver__exception/","title":"Class naomi::maneuvers::no_such_maneuver_exception","text":"<p>ClassList &gt; naomi &gt; maneuvers &gt; no_such_maneuver_exception</p> <ul> <li><code>#include &lt;maneuver_plan.h&gt;</code></li> </ul> <p>Inherits the following classes: std::exception</p>"},{"location":"naomi/classnaomi_1_1maneuvers_1_1no__such__maneuver__exception/#public-functions","title":"Public Functions","text":"Type Name const char * what ()"},{"location":"naomi/classnaomi_1_1maneuvers_1_1no__such__maneuver__exception/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1maneuvers_1_1no__such__maneuver__exception/#function-what","title":"function what","text":"<pre><code>inline const char * naomi::maneuvers::no_such_maneuver_exception::what () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/maneuvers/maneuver_plan.h</code></p>"},{"location":"naomi/classnaomi_1_1mass__provider/","title":"Class naomi::mass_provider","text":"<p>ClassList &gt; naomi &gt; mass_provider</p> <ul> <li><code>#include &lt;spacecraft_state.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>include/spacecraft/spacecraft_state.h</code></p>"},{"location":"naomi/namespacenaomi_1_1math/","title":"Namespace naomi::math","text":"<p>Namespace List &gt; naomi &gt; math</p>"},{"location":"naomi/namespacenaomi_1_1math/#namespaces","title":"Namespaces","text":"Type Name namespace quaternion"},{"location":"naomi/namespacenaomi_1_1math/#public-functions","title":"Public Functions","text":"Type Name arma::mat44 q_skew (const quaternion_type &amp; q)  arma::mat44 skew (const arma::vec3 &amp; x)"},{"location":"naomi/namespacenaomi_1_1math/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/namespacenaomi_1_1math/#function-q_skew","title":"function q_skew","text":"<pre><code>inline arma::mat44 naomi::math::q_skew (\n    const quaternion_type &amp; q\n) \n</code></pre>"},{"location":"naomi/namespacenaomi_1_1math/#function-skew","title":"function skew","text":"<pre><code>inline arma::mat44 naomi::math::skew (\n    const arma::vec3 &amp; x\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/math/quaternion.h</code></p>"},{"location":"naomi/namespacenaomi_1_1math_1_1quaternion/","title":"Namespace naomi::math::quaternion","text":"<p>Namespace List &gt; naomi &gt; math &gt; quaternion</p>"},{"location":"naomi/namespacenaomi_1_1math_1_1quaternion/#public-types","title":"Public Types","text":"Type Name typedef arma::vec4 quaternion_type"},{"location":"naomi/namespacenaomi_1_1math_1_1quaternion/#public-functions","title":"Public Functions","text":"Type Name quaternion_type conjugate (const quaternion_type &amp; q)  quaternion_type product (const quaternion_type &amp; q1, const quaternion_type &amp; q2) Taken from https://public.websites.umich.edu/~jbreeden/Quaternions.pdf ."},{"location":"naomi/namespacenaomi_1_1math_1_1quaternion/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"naomi/namespacenaomi_1_1math_1_1quaternion/#typedef-quaternion_type","title":"typedef quaternion_type","text":"<pre><code>typedef arma::vec4 naomi::math::quaternion::quaternion_type;\n</code></pre>"},{"location":"naomi/namespacenaomi_1_1math_1_1quaternion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/namespacenaomi_1_1math_1_1quaternion/#function-conjugate","title":"function conjugate","text":"<pre><code>inline quaternion_type naomi::math::quaternion::conjugate (\n    const quaternion_type &amp; q\n) \n</code></pre>"},{"location":"naomi/namespacenaomi_1_1math_1_1quaternion/#function-product","title":"function product","text":"<p>Taken from https://public.websites.umich.edu/~jbreeden/Quaternions.pdf . <pre><code>inline quaternion_type naomi::math::quaternion::product (\n    const quaternion_type &amp; q1,\n    const quaternion_type &amp; q2\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>q1</code> </li> <li><code>q2</code> </li> </ul> <p>Returns:</p> <p>The documentation for this class was generated from the following file <code>include/math/quaternion.h</code></p>"},{"location":"naomi/namespacenaomi_1_1numeric/","title":"Namespace naomi::numeric","text":"<p>Namespace List &gt; naomi &gt; numeric</p>"},{"location":"naomi/namespacenaomi_1_1numeric/#classes","title":"Classes","text":"Type Name class integrator &lt;class Stepper&gt; class numerical_propagator &lt;typename Stepper&gt;"},{"location":"naomi/namespacenaomi_1_1numeric/#public-types","title":"Public Types","text":"Type Name typedef boost::numeric::odeint::runge_kutta_dopri5&lt; vector_type, double, vector_type, double, boost::numeric::odeint::vector_space_algebra &gt; rk_dopri5_stepper typedef std::function&lt; void(const vector_type &amp;, vector_type &amp;, double)&gt; system_t"},{"location":"naomi/namespacenaomi_1_1numeric/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"naomi/namespacenaomi_1_1numeric/#typedef-rk_dopri5_stepper","title":"typedef rk_dopri5_stepper","text":"<pre><code>typedef boost::numeric::odeint::runge_kutta_dopri5&lt; vector_type, double, vector_type, double, boost::numeric::odeint::vector_space_algebra&gt; naomi::numeric::rk_dopri5_stepper;\n</code></pre>"},{"location":"naomi/namespacenaomi_1_1numeric/#typedef-system_t","title":"typedef system_t","text":"<pre><code>typedef std::function&lt;void(const vector_type&amp;, vector_type&amp;, double)&gt; naomi::numeric::system_t;\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/integrators/integrator.h</code></p>"},{"location":"naomi/classnaomi_1_1numeric_1_1integrator/","title":"Class naomi::numeric::integrator","text":"<p>template &lt;class Stepper&gt;</p> <p>ClassList &gt; naomi &gt; numeric &gt; integrator</p> <ul> <li><code>#include &lt;integrator.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1numeric_1_1integrator/#public-functions","title":"Public Functions","text":"Type Name std::pair&lt; double, vector_type &gt; find_event_time (const system_t &amp; system, double start_time, double end_time, std::shared_ptr&lt; event_detector &gt; e, state_and_time_type state, double step_size)  double integrate (const system_t &amp; system, vector_type &amp; state, double start_time, double end_time, double step_size)  integrator (const integrator &amp; other)  integrator (integrator &amp;&amp; other) noexcept integrator () = default integrator &amp; operator= (const integrator &amp; other)  integrator &amp; operator= (integrator &amp;&amp; other) noexcept ~integrator () = default"},{"location":"naomi/classnaomi_1_1numeric_1_1integrator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1numeric_1_1integrator/#function-find_event_time","title":"function find_event_time","text":"<pre><code>inline std::pair&lt; double, vector_type &gt; naomi::numeric::integrator::find_event_time (\n    const system_t &amp; system,\n    double start_time,\n    double end_time,\n    std::shared_ptr&lt; event_detector &gt; e,\n    state_and_time_type state,\n    double step_size\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1integrator/#function-integrate","title":"function integrate","text":"<pre><code>inline double naomi::numeric::integrator::integrate (\n    const system_t &amp; system,\n    vector_type &amp; state,\n    double start_time,\n    double end_time,\n    double step_size\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1integrator/#function-integrator-13","title":"function integrator [1/3]","text":"<pre><code>inline naomi::numeric::integrator::integrator (\n    const integrator &amp; other\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1integrator/#function-integrator-23","title":"function integrator [2/3]","text":"<pre><code>inline naomi::numeric::integrator::integrator (\n    integrator &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1integrator/#function-integrator-33","title":"function integrator [3/3]","text":"<pre><code>naomi::numeric::integrator::integrator () = default\n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1integrator/#function-operator","title":"function operator=","text":"<pre><code>inline integrator &amp; naomi::numeric::integrator::operator= (\n    const integrator &amp; other\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1integrator/#function-operator_1","title":"function operator=","text":"<pre><code>inline integrator &amp; naomi::numeric::integrator::operator= (\n    integrator &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1integrator/#function-integrator","title":"function ~integrator","text":"<pre><code>naomi::numeric::integrator::~integrator () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/integrators/integrator.h</code></p>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/","title":"Class naomi::numeric::numerical_propagator","text":"<p>template &lt;typename Stepper&gt;</p> <p>ClassList &gt; naomi &gt; numeric &gt; numerical_propagator</p> <ul> <li><code>#include &lt;numerical_propagator.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; std::shared_ptr&lt; event_detector &gt; &gt; check_events (const state_and_time_type &amp; prev, const state_and_time_type &amp; curr, double t)  void initialize (const std::shared_ptr&lt; equations_of_motion &gt; &amp; system_eoms, const std::map&lt; std::string, std::shared_ptr&lt; spacecraft &gt; &gt; &amp; spacecrafts)  auto make_system (const std::shared_ptr&lt; force_model &gt; &amp; force_model, const std::shared_ptr&lt; spacecraft &gt; &amp; spacecraft)  std::vector&lt; std::pair&lt; arma::span, std::shared_ptr&lt; additional_state_provider &gt; &gt; &gt; map_providers (const std::vector&lt; std::shared_ptr&lt; additional_state_provider &gt; &gt; &amp; additional_providers)  numerical_propagator (const numerical_propagator &amp; other)  numerical_propagator (numerical_propagator &amp;&amp; other) noexcept numerical_propagator () = default numerical_propagator &amp; operator= (const numerical_propagator &amp; other)  numerical_propagator &amp; operator= (numerical_propagator &amp;&amp; other) noexcept void propagate_by (const std::shared_ptr&lt; spacecraft &gt; &amp; spacecraft, double dt)  double propagate_by (const double dt)  void propagate_to (const std::shared_ptr&lt; spacecraft &gt; &amp; spacecraft, double dt)  double propagate_to (const double dt)  ~numerical_propagator () = default"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#public-static-functions","title":"Public Static Functions","text":"Type Name std::vector&lt; double &gt; get_integration_times (const double t_start, const double t_end)"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-check_events","title":"function check_events","text":"<pre><code>inline std::vector&lt; std::shared_ptr&lt; event_detector &gt; &gt; naomi::numeric::numerical_propagator::check_events (\n    const state_and_time_type &amp; prev,\n    const state_and_time_type &amp; curr,\n    double t\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-initialize","title":"function initialize","text":"<pre><code>inline void naomi::numeric::numerical_propagator::initialize (\n    const std::shared_ptr&lt; equations_of_motion &gt; &amp; system_eoms,\n    const std::map&lt; std::string, std::shared_ptr&lt; spacecraft &gt; &gt; &amp; spacecrafts\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-make_system","title":"function make_system","text":"<pre><code>inline auto naomi::numeric::numerical_propagator::make_system (\n    const std::shared_ptr&lt; force_model &gt; &amp; force_model,\n    const std::shared_ptr&lt; spacecraft &gt; &amp; spacecraft\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-map_providers","title":"function map_providers","text":"<pre><code>inline std::vector&lt; std::pair&lt; arma::span, std::shared_ptr&lt; additional_state_provider &gt; &gt; &gt; naomi::numeric::numerical_propagator::map_providers (\n    const std::vector&lt; std::shared_ptr&lt; additional_state_provider &gt; &gt; &amp; additional_providers\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-numerical_propagator-13","title":"function numerical_propagator [1/3]","text":"<pre><code>inline naomi::numeric::numerical_propagator::numerical_propagator (\n    const numerical_propagator &amp; other\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-numerical_propagator-23","title":"function numerical_propagator [2/3]","text":"<pre><code>inline naomi::numeric::numerical_propagator::numerical_propagator (\n    numerical_propagator &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-numerical_propagator-33","title":"function numerical_propagator [3/3]","text":"<pre><code>naomi::numeric::numerical_propagator::numerical_propagator () = default\n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-operator","title":"function operator=","text":"<pre><code>inline numerical_propagator &amp; naomi::numeric::numerical_propagator::operator= (\n    const numerical_propagator &amp; other\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-operator_1","title":"function operator=","text":"<pre><code>inline numerical_propagator &amp; naomi::numeric::numerical_propagator::operator= (\n    numerical_propagator &amp;&amp; other\n) noexcept\n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-propagate_by-12","title":"function propagate_by [1/2]","text":"<pre><code>inline void naomi::numeric::numerical_propagator::propagate_by (\n    const std::shared_ptr&lt; spacecraft &gt; &amp; spacecraft,\n    double dt\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-propagate_by-22","title":"function propagate_by [2/2]","text":"<pre><code>inline double naomi::numeric::numerical_propagator::propagate_by (\n    const double dt\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-propagate_to-12","title":"function propagate_to [1/2]","text":"<pre><code>inline void naomi::numeric::numerical_propagator::propagate_to (\n    const std::shared_ptr&lt; spacecraft &gt; &amp; spacecraft,\n    double dt\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-propagate_to-22","title":"function propagate_to [2/2]","text":"<pre><code>inline double naomi::numeric::numerical_propagator::propagate_to (\n    const double dt\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-numerical_propagator","title":"function ~numerical_propagator","text":"<pre><code>naomi::numeric::numerical_propagator::~numerical_propagator () = default\n</code></pre>"},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1numeric_1_1numerical__propagator/#function-get_integration_times","title":"function get_integration_times","text":"<pre><code>static inline std::vector&lt; double &gt; naomi::numeric::numerical_propagator::get_integration_times (\n    const double t_start,\n    const double t_end\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/propagators/numerical_propagator.h</code></p>"},{"location":"naomi/namespacenaomi_1_1observers/","title":"Namespace naomi::observers","text":"<p>Namespace List &gt; naomi &gt; observers</p>"},{"location":"naomi/namespacenaomi_1_1observers/#classes","title":"Classes","text":"Type Name class results_csv_writer_observer &lt;class system_t&gt; class simulation_observer &lt;typename system_t&gt; <p>The documentation for this class was generated from the following file <code>include/observers/simulation_observer.h</code></p>"},{"location":"naomi/classnaomi_1_1observers_1_1results__csv__writer__observer/","title":"Class naomi::observers::results_csv_writer_observer","text":"<p>template &lt;class system_t&gt;</p> <p>ClassList &gt; naomi &gt; observers &gt; results_csv_writer_observer</p> <ul> <li><code>#include &lt;simulation_observer.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::observers::simulation_observer</p>"},{"location":"naomi/classnaomi_1_1observers_1_1results__csv__writer__observer/#public-functions","title":"Public Functions","text":"Type Name virtual void handle_observe_state (const std::shared_ptr&lt; system_t &gt; &amp; system) override virtual void initialize (const std::shared_ptr&lt; system_t &gt; &amp; system) override results_csv_writer_observer (const double obs_interval, std::string filepath)  results_csv_writer_observer (const double obs_interval, std::string filepath, std::fstream::openmode openmode)  virtual void terminate (const std::shared_ptr&lt; system_t &gt; &amp; system) override"},{"location":"naomi/classnaomi_1_1observers_1_1results__csv__writer__observer/#public-functions-inherited-from-naomiobserverssimulation_observer","title":"Public Functions inherited from naomi::observers::simulation_observer","text":"<p>See naomi::observers::simulation_observer</p> Type Name double get_next_update () const virtual void handle_observe_state (const std::shared_ptr&lt; system_t &gt; &amp; system) = 0 virtual void initialize (const std::shared_ptr&lt; system_t &gt; &amp; system)  virtual void observe_event (const std::shared_ptr&lt; event_detector &gt; &amp; event)  void observe_state (const std::shared_ptr&lt; system_t &gt; &amp; system)  simulation_observer (const double obs_interval)  virtual void terminate (const std::shared_ptr&lt; system_t &gt; &amp; system)  virtual ~simulation_observer () = default"},{"location":"naomi/classnaomi_1_1observers_1_1results__csv__writer__observer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1observers_1_1results__csv__writer__observer/#function-handle_observe_state","title":"function handle_observe_state","text":"<pre><code>inline virtual void naomi::observers::results_csv_writer_observer::handle_observe_state (\n    const std::shared_ptr&lt; system_t &gt; &amp; system\n) override\n</code></pre> <p>Implements naomi::observers::simulation_observer::handle_observe_state</p>"},{"location":"naomi/classnaomi_1_1observers_1_1results__csv__writer__observer/#function-initialize","title":"function initialize","text":"<pre><code>inline virtual void naomi::observers::results_csv_writer_observer::initialize (\n    const std::shared_ptr&lt; system_t &gt; &amp; system\n) override\n</code></pre> <p>Implements naomi::observers::simulation_observer::initialize</p>"},{"location":"naomi/classnaomi_1_1observers_1_1results__csv__writer__observer/#function-results_csv_writer_observer-12","title":"function results_csv_writer_observer [1/2]","text":"<pre><code>inline naomi::observers::results_csv_writer_observer::results_csv_writer_observer (\n    const double obs_interval,\n    std::string filepath\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1observers_1_1results__csv__writer__observer/#function-results_csv_writer_observer-22","title":"function results_csv_writer_observer [2/2]","text":"<pre><code>inline naomi::observers::results_csv_writer_observer::results_csv_writer_observer (\n    const double obs_interval,\n    std::string filepath,\n    std::fstream::openmode openmode\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1observers_1_1results__csv__writer__observer/#function-terminate","title":"function terminate","text":"<pre><code>inline virtual void naomi::observers::results_csv_writer_observer::terminate (\n    const std::shared_ptr&lt; system_t &gt; &amp; system\n) override\n</code></pre> <p>Implements naomi::observers::simulation_observer::terminate</p> <p>The documentation for this class was generated from the following file <code>include/observers/simulation_observer.h</code></p>"},{"location":"naomi/classnaomi_1_1observers_1_1simulation__observer/","title":"Class naomi::observers::simulation_observer","text":"<p>template &lt;typename system_t&gt;</p> <p>ClassList &gt; naomi &gt; observers &gt; simulation_observer</p> <ul> <li><code>#include &lt;simulation_observer.h&gt;</code></li> </ul> <p>Inherited by the following classes: naomi::observers::results_csv_writer_observer</p>"},{"location":"naomi/classnaomi_1_1observers_1_1simulation__observer/#public-functions","title":"Public Functions","text":"Type Name double get_next_update () const virtual void handle_observe_state (const std::shared_ptr&lt; system_t &gt; &amp; system) = 0 virtual void initialize (const std::shared_ptr&lt; system_t &gt; &amp; system)  virtual void observe_event (const std::shared_ptr&lt; event_detector &gt; &amp; event)  void observe_state (const std::shared_ptr&lt; system_t &gt; &amp; system)  simulation_observer (const double obs_interval)  virtual void terminate (const std::shared_ptr&lt; system_t &gt; &amp; system)  virtual ~simulation_observer () = default"},{"location":"naomi/classnaomi_1_1observers_1_1simulation__observer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1observers_1_1simulation__observer/#function-get_next_update","title":"function get_next_update","text":"<pre><code>inline double naomi::observers::simulation_observer::get_next_update () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1observers_1_1simulation__observer/#function-handle_observe_state","title":"function handle_observe_state","text":"<pre><code>virtual void naomi::observers::simulation_observer::handle_observe_state (\n    const std::shared_ptr&lt; system_t &gt; &amp; system\n) = 0\n</code></pre>"},{"location":"naomi/classnaomi_1_1observers_1_1simulation__observer/#function-initialize","title":"function initialize","text":"<pre><code>inline virtual void naomi::observers::simulation_observer::initialize (\n    const std::shared_ptr&lt; system_t &gt; &amp; system\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1observers_1_1simulation__observer/#function-observe_event","title":"function observe_event","text":"<pre><code>inline virtual void naomi::observers::simulation_observer::observe_event (\n    const std::shared_ptr&lt; event_detector &gt; &amp; event\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1observers_1_1simulation__observer/#function-observe_state","title":"function observe_state","text":"<pre><code>inline void naomi::observers::simulation_observer::observe_state (\n    const std::shared_ptr&lt; system_t &gt; &amp; system\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1observers_1_1simulation__observer/#function-simulation_observer","title":"function simulation_observer","text":"<pre><code>inline explicit naomi::observers::simulation_observer::simulation_observer (\n    const double obs_interval\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1observers_1_1simulation__observer/#function-terminate","title":"function terminate","text":"<pre><code>inline virtual void naomi::observers::simulation_observer::terminate (\n    const std::shared_ptr&lt; system_t &gt; &amp; system\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1observers_1_1simulation__observer/#function-simulation_observer_1","title":"function ~simulation_observer","text":"<pre><code>virtual naomi::observers::simulation_observer::~simulation_observer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/observers/simulation_observer.h</code></p>"},{"location":"naomi/namespacenaomi_1_1orbits/","title":"Namespace naomi::orbits","text":"<p>Namespace List &gt; naomi &gt; orbits</p>"},{"location":"naomi/namespacenaomi_1_1orbits/#classes","title":"Classes","text":"Type Name class cartesian_orbit struct eccentric_anomaly_functor &lt;class T&gt; class keplerian_orbit"},{"location":"naomi/namespacenaomi_1_1orbits/#public-types","title":"Public Types","text":"Type Name enum AnomalyType"},{"location":"naomi/namespacenaomi_1_1orbits/#public-functions","title":"Public Functions","text":"Type Name vector_type get_circular_orbit (const arma::vec3 &amp; initial_position, const double mu=constants::EARTH_MU)  double vis_viva (const double radius, const double sma, const double mu=constants::EARTH_MU) Compute the velocity of an object given the radius, semi-major axis, and mu."},{"location":"naomi/namespacenaomi_1_1orbits/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"naomi/namespacenaomi_1_1orbits/#enum-anomalytype","title":"enum AnomalyType","text":"<pre><code>enum naomi::orbits::AnomalyType {\n    TRUE,\n    MEAN,\n    ECCENTRIC\n};\n</code></pre>"},{"location":"naomi/namespacenaomi_1_1orbits/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/namespacenaomi_1_1orbits/#function-get_circular_orbit","title":"function get_circular_orbit","text":"<pre><code>inline vector_type naomi::orbits::get_circular_orbit (\n    const arma::vec3 &amp; initial_position,\n    const double mu=constants::EARTH_MU\n) \n</code></pre>"},{"location":"naomi/namespacenaomi_1_1orbits/#function-vis_viva","title":"function vis_viva","text":"<p>Compute the velocity of an object given the radius, semi-major axis, and mu. <pre><code>inline double naomi::orbits::vis_viva (\n    const double radius,\n    const double sma,\n    const double mu=constants::EARTH_MU\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>radius</code> The radius at the current location in orbit in meters </li> <li><code>sma</code> The semi-major axis of the orbit in meters </li> <li><code>mu</code> Optional gravitational parameter for the central body, defaults to the gravitational parameter for Earth </li> </ul> <p>Returns:</p> <p>The velocity of the object </p> <p>The documentation for this class was generated from the following file <code>include/orbits/cartesian.h</code></p>"},{"location":"naomi/classnaomi_1_1orbits_1_1cartesian__orbit/","title":"Class naomi::orbits::cartesian_orbit","text":"<p>ClassList &gt; naomi &gt; orbits &gt; cartesian_orbit</p> <ul> <li><code>#include &lt;cartesian.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1orbits_1_1cartesian__orbit/#public-functions","title":"Public Functions","text":"Type Name cartesian_orbit (const arma::vec3 &amp; pos, const arma::vec3 &amp; vel)  auto get_position ()  auto get_velocity ()"},{"location":"naomi/classnaomi_1_1orbits_1_1cartesian__orbit/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1orbits_1_1cartesian__orbit/#function-cartesian_orbit","title":"function cartesian_orbit","text":"<pre><code>inline naomi::orbits::cartesian_orbit::cartesian_orbit (\n    const arma::vec3 &amp; pos,\n    const arma::vec3 &amp; vel\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1cartesian__orbit/#function-get_position","title":"function get_position","text":"<pre><code>inline auto naomi::orbits::cartesian_orbit::get_position () \n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1cartesian__orbit/#function-get_velocity","title":"function get_velocity","text":"<pre><code>inline auto naomi::orbits::cartesian_orbit::get_velocity () \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/orbits/cartesian.h</code></p>"},{"location":"naomi/structnaomi_1_1orbits_1_1eccentric__anomaly__functor/","title":"Struct naomi::orbits::eccentric_anomaly_functor","text":"<p>template &lt;class T&gt;</p> <p>ClassList &gt; naomi &gt; orbits &gt; eccentric_anomaly_functor</p> <ul> <li><code>#include &lt;keplerian.h&gt;</code></li> </ul>"},{"location":"naomi/structnaomi_1_1orbits_1_1eccentric__anomaly__functor/#public-functions","title":"Public Functions","text":"Type Name eccentric_anomaly_functor (T const &amp; ecc, T const &amp; ma)  boost::math::tuple&lt; T, T &gt; operator() (T const &amp; psi)"},{"location":"naomi/structnaomi_1_1orbits_1_1eccentric__anomaly__functor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/structnaomi_1_1orbits_1_1eccentric__anomaly__functor/#function-eccentric_anomaly_functor","title":"function eccentric_anomaly_functor","text":"<pre><code>inline naomi::orbits::eccentric_anomaly_functor::eccentric_anomaly_functor (\n    T const &amp; ecc,\n    T const &amp; ma\n) \n</code></pre>"},{"location":"naomi/structnaomi_1_1orbits_1_1eccentric__anomaly__functor/#function-operator","title":"function operator()","text":"<pre><code>inline boost::math::tuple&lt; T, T &gt; naomi::orbits::eccentric_anomaly_functor::operator() (\n    T const &amp; psi\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/orbits/keplerian.h</code></p>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/","title":"Class naomi::orbits::keplerian_orbit","text":"<p>ClassList &gt; naomi &gt; orbits &gt; keplerian_orbit</p> <ul> <li><code>#include &lt;keplerian.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#public-functions","title":"Public Functions","text":"Type Name double deg2rad (double deg) const auto fn (const double &amp; psi) const auto get_a () const auto get_anomaly (bool degrees=true) const auto get_aop (bool degrees=true) const auto get_e () const auto get_eccentric_anomaly () const auto get_i (bool degrees=true) const auto get_orbital_period () const auto get_raan (bool degrees=true) const keplerian_orbit (const double sma, const double ecc=0, const double inc=0, const double raan=0, const double aop=0, const double anomaly=0, const AnomalyType anomaly_type=AnomalyType::MEAN)  bool operator== (const keplerian_orbit &amp; other) const double rad2deg (double rad) const auto to_cartesian () const auto to_vec (bool degrees=false) const"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#public-static-functions","title":"Public Static Functions","text":"Type Name double compute_eccentricity (arma::vec3 &amp; r, arma::vec3 &amp; v, double mu)  keplerian_orbit from_cartesian (cartesian_orbit &amp; cart)  auto get_orbital_period (const double sma)  double v_norm (arma::vec3 v)"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-deg2rad","title":"function deg2rad","text":"<pre><code>inline double naomi::orbits::keplerian_orbit::deg2rad (\n    double deg\n) const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-fn","title":"function fn","text":"<pre><code>inline auto naomi::orbits::keplerian_orbit::fn (\n    const double &amp; psi\n) const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-get_a","title":"function get_a","text":"<pre><code>inline auto naomi::orbits::keplerian_orbit::get_a () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-get_anomaly","title":"function get_anomaly","text":"<pre><code>inline auto naomi::orbits::keplerian_orbit::get_anomaly (\n    bool degrees=true\n) const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-get_aop","title":"function get_aop","text":"<pre><code>inline auto naomi::orbits::keplerian_orbit::get_aop (\n    bool degrees=true\n) const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-get_e","title":"function get_e","text":"<pre><code>inline auto naomi::orbits::keplerian_orbit::get_e () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-get_eccentric_anomaly","title":"function get_eccentric_anomaly","text":"<pre><code>inline auto naomi::orbits::keplerian_orbit::get_eccentric_anomaly () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-get_i","title":"function get_i","text":"<pre><code>inline auto naomi::orbits::keplerian_orbit::get_i (\n    bool degrees=true\n) const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-get_orbital_period-12","title":"function get_orbital_period [1/2]","text":"<pre><code>inline auto naomi::orbits::keplerian_orbit::get_orbital_period () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-get_raan","title":"function get_raan","text":"<pre><code>inline auto naomi::orbits::keplerian_orbit::get_raan (\n    bool degrees=true\n) const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-keplerian_orbit","title":"function keplerian_orbit","text":"<pre><code>inline naomi::orbits::keplerian_orbit::keplerian_orbit (\n    const double sma,\n    const double ecc=0,\n    const double inc=0,\n    const double raan=0,\n    const double aop=0,\n    const double anomaly=0,\n    const AnomalyType anomaly_type=AnomalyType::MEAN\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-operator","title":"function operator==","text":"<pre><code>inline bool naomi::orbits::keplerian_orbit::operator== (\n    const keplerian_orbit &amp; other\n) const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-rad2deg","title":"function rad2deg","text":"<pre><code>inline double naomi::orbits::keplerian_orbit::rad2deg (\n    double rad\n) const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-to_cartesian","title":"function to_cartesian","text":"<pre><code>inline auto naomi::orbits::keplerian_orbit::to_cartesian () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-to_vec","title":"function to_vec","text":"<pre><code>inline auto naomi::orbits::keplerian_orbit::to_vec (\n    bool degrees=false\n) const\n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-compute_eccentricity","title":"function compute_eccentricity","text":"<pre><code>static inline double naomi::orbits::keplerian_orbit::compute_eccentricity (\n    arma::vec3 &amp; r,\n    arma::vec3 &amp; v,\n    double mu\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-from_cartesian","title":"function from_cartesian","text":"<pre><code>static inline keplerian_orbit naomi::orbits::keplerian_orbit::from_cartesian (\n    cartesian_orbit &amp; cart\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-get_orbital_period-22","title":"function get_orbital_period [2/2]","text":"<pre><code>static inline auto naomi::orbits::keplerian_orbit::get_orbital_period (\n    const double sma\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1orbits_1_1keplerian__orbit/#function-v_norm","title":"function v_norm","text":"<pre><code>static inline double naomi::orbits::keplerian_orbit::v_norm (\n    arma::vec3 v\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/orbits/keplerian.h</code></p>"},{"location":"naomi/classnaomi_1_1physical__system/","title":"Class naomi::physical_system","text":"<p>template &lt;typename Propagator&gt;</p> <p>ClassList &gt; naomi &gt; physical_system</p> <p>A <code>physical_system</code> contains the force model definitions of the system to be simulated, the spacecrafts that exist within the system, and the propagator that will be used to integrate the dynamics.More...</p> <ul> <li><code>#include &lt;system.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1physical__system/#public-functions","title":"Public Functions","text":"Type Name auto get_current_time () const auto get_spacecraft (const std::string &amp; scid)  auto get_spacecrafts ()  physical_system (const spacecraft &amp; spacecraft, const std::shared_ptr&lt; equations_of_motion &gt; &amp; system_eoms)  physical_system (const std::shared_ptr&lt; spacecraft &gt; &amp; spacecraft, const std::shared_ptr&lt; equations_of_motion &gt; &amp; system_eoms)  physical_system (const std::initializer_list&lt; spacecraft &gt; &amp; spacecrafts, const std::shared_ptr&lt; equations_of_motion &gt; &amp; system_eoms)  physical_system (const std::initializer_list&lt; std::shared_ptr&lt; spacecraft &gt; &gt; &amp; spacecrafts, const std::shared_ptr&lt; equations_of_motion &gt; &amp; system_eoms)  void simulate_by (double dt)  double simulate_to (double dt)"},{"location":"naomi/classnaomi_1_1physical__system/#detailed-description","title":"Detailed Description","text":"<p>A definition of the physical system to be simulated. </p> <p>Template parameters:</p> <ul> <li><code>Propagator</code> The propagator to use for simulation, right now the only type allowed is <code>NumericalPropagator&lt;T&gt;</code> where T defines the stepper (see boost docs). Future work hopefully enables more customizability. </li> </ul>"},{"location":"naomi/classnaomi_1_1physical__system/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1physical__system/#function-get_current_time","title":"function get_current_time","text":"<pre><code>inline auto naomi::physical_system::get_current_time () const\n</code></pre> <p>Returns:</p>"},{"location":"naomi/classnaomi_1_1physical__system/#function-get_spacecraft","title":"function get_spacecraft","text":"<pre><code>inline auto naomi::physical_system::get_spacecraft (\n    const std::string &amp; scid\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>scid</code> </li> </ul> <p>Returns:</p>"},{"location":"naomi/classnaomi_1_1physical__system/#function-get_spacecrafts","title":"function get_spacecrafts","text":"<pre><code>inline auto naomi::physical_system::get_spacecrafts () \n</code></pre> <p>Returns:</p>"},{"location":"naomi/classnaomi_1_1physical__system/#function-physical_system-14","title":"function physical_system [1/4]","text":"<pre><code>inline naomi::physical_system::physical_system (\n    const spacecraft &amp; spacecraft,\n    const std::shared_ptr&lt; equations_of_motion &gt; &amp; system_eoms\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>spacecraft</code> </li> <li><code>system_eoms</code> </li> </ul>"},{"location":"naomi/classnaomi_1_1physical__system/#function-physical_system-24","title":"function physical_system [2/4]","text":"<pre><code>inline naomi::physical_system::physical_system (\n    const std::shared_ptr&lt; spacecraft &gt; &amp; spacecraft,\n    const std::shared_ptr&lt; equations_of_motion &gt; &amp; system_eoms\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>spacecraft</code> </li> <li><code>system_eoms</code> </li> </ul>"},{"location":"naomi/classnaomi_1_1physical__system/#function-physical_system-34","title":"function physical_system [3/4]","text":"<pre><code>inline naomi::physical_system::physical_system (\n    const std::initializer_list&lt; spacecraft &gt; &amp; spacecrafts,\n    const std::shared_ptr&lt; equations_of_motion &gt; &amp; system_eoms\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>spacecrafts</code> </li> <li><code>system_eoms</code> </li> </ul>"},{"location":"naomi/classnaomi_1_1physical__system/#function-physical_system-44","title":"function physical_system [4/4]","text":"<pre><code>inline naomi::physical_system::physical_system (\n    const std::initializer_list&lt; std::shared_ptr&lt; spacecraft &gt; &gt; &amp; spacecrafts,\n    const std::shared_ptr&lt; equations_of_motion &gt; &amp; system_eoms\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>spacecrafts</code> </li> <li><code>system_eoms</code> </li> </ul>"},{"location":"naomi/classnaomi_1_1physical__system/#function-simulate_by","title":"function simulate_by","text":"<pre><code>inline void naomi::physical_system::simulate_by (\n    double dt\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>dt</code> </li> </ul>"},{"location":"naomi/classnaomi_1_1physical__system/#function-simulate_to","title":"function simulate_to","text":"<pre><code>inline double naomi::physical_system::simulate_to (\n    double dt\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>dt</code> </li> </ul> <p>Returns:</p> <p>The documentation for this class was generated from the following file <code>include/systems/system.h</code></p>"},{"location":"naomi/classnaomi_1_1simulation/","title":"Class naomi::simulation","text":"<p>template &lt;typename system_t&gt;</p> <p>ClassList &gt; naomi &gt; simulation</p> <ul> <li><code>#include &lt;simulation.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1simulation/#public-functions","title":"Public Functions","text":"Type Name std::pair&lt; double, std::shared_ptr&lt; simulation_observer&lt; system_t &gt; &gt; &gt; get_next_update ()  void simulate (const double duration)  simulation (std::shared_ptr&lt; system_t &gt; system)  simulation (std::shared_ptr&lt; system_t &gt; system, const std::initializer_list&lt; std::shared_ptr&lt; simulation_observer&lt; system_t &gt; &gt; &gt; &amp; observers)"},{"location":"naomi/classnaomi_1_1simulation/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1simulation/#function-get_next_update","title":"function get_next_update","text":"<pre><code>inline std::pair&lt; double, std::shared_ptr&lt; simulation_observer &lt; system_t &gt; &gt; &gt; naomi::simulation::get_next_update () \n</code></pre>"},{"location":"naomi/classnaomi_1_1simulation/#function-simulate","title":"function simulate","text":"<pre><code>inline void naomi::simulation::simulate (\n    const double duration\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1simulation/#function-simulation-12","title":"function simulation [1/2]","text":"<pre><code>inline explicit naomi::simulation::simulation (\n    std::shared_ptr&lt; system_t &gt; system\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1simulation/#function-simulation-22","title":"function simulation [2/2]","text":"<pre><code>inline naomi::simulation::simulation (\n    std::shared_ptr&lt; system_t &gt; system,\n    const std::initializer_list&lt; std::shared_ptr&lt; simulation_observer &lt; system_t &gt; &gt; &gt; &amp; observers\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/simulation/simulation.h</code></p>"},{"location":"naomi/classnaomi_1_1simulation__component/","title":"Class naomi::simulation_component","text":"<p>template &lt;typename state_t&gt;</p> <p>ClassList &gt; naomi &gt; simulation_component</p> <ul> <li><code>#include &lt;simulation.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1simulation__component/#public-functions","title":"Public Functions","text":"Type Name virtual void initialize (state_t &amp; state)  virtual void terminate (state_t &amp; state)  virtual void update (state_t &amp; state)  virtual ~simulation_component () = default"},{"location":"naomi/classnaomi_1_1simulation__component/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1simulation__component/#function-initialize","title":"function initialize","text":"<pre><code>inline virtual void naomi::simulation_component::initialize (\n    state_t &amp; state\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1simulation__component/#function-terminate","title":"function terminate","text":"<pre><code>inline virtual void naomi::simulation_component::terminate (\n    state_t &amp; state\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1simulation__component/#function-update","title":"function update","text":"<pre><code>inline virtual void naomi::simulation_component::update (\n    state_t &amp; state\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1simulation__component/#function-simulation_component","title":"function ~simulation_component","text":"<pre><code>virtual naomi::simulation_component::~simulation_component () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/simulation/simulation.h</code></p>"},{"location":"naomi/classnaomi_1_1spacecraft/","title":"Class naomi::spacecraft","text":"<p>ClassList &gt; naomi &gt; spacecraft</p> <ul> <li><code>#include &lt;spacecraft.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1spacecraft/#public-functions","title":"Public Functions","text":"Type Name auto get_attitude () const auto get_identifier () const auto get_identifier () Returns the string identifier of this spacecraft. auto get_inertia_matrix () Get the 3x3 intertia matrix of the spacecraft. auto get_maneuver_plan ()  auto get_pv_coordinates (const std::shared_ptr&lt; frames::frame &gt; &amp; frame=nullptr) The current positional coordinates of the spacecraft in a given frame. auto get_state ()  void set_attitude (const quaternion_type &amp; attitude)  spacecraft (std::string identifier, const vector_type &amp; state, const double &amp; mass)  spacecraft (std::string identifier, const vector_type &amp; state, const double &amp; mass, const std::shared_ptr&lt; attitude_provider &gt; &amp; attitude_provider)  spacecraft (std::string identifier, const vector_type &amp; state, const double &amp; mass, const std::shared_ptr&lt; maneuvers::maneuver_plan &gt; &amp; mp)  void update (const double dt)"},{"location":"naomi/classnaomi_1_1spacecraft/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1spacecraft/#function-get_attitude","title":"function get_attitude","text":"<pre><code>inline auto naomi::spacecraft::get_attitude () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1spacecraft/#function-get_identifier-12","title":"function get_identifier [1/2]","text":"<pre><code>inline auto naomi::spacecraft::get_identifier () const\n</code></pre>"},{"location":"naomi/classnaomi_1_1spacecraft/#function-get_identifier-22","title":"function get_identifier [2/2]","text":"<p>Returns the string identifier of this spacecraft. <pre><code>inline auto naomi::spacecraft::get_identifier () \n</code></pre></p> <p>Returns:</p> <p>Copy of the spacecraft identifier </p>"},{"location":"naomi/classnaomi_1_1spacecraft/#function-get_inertia_matrix","title":"function get_inertia_matrix","text":"<p>Get the 3x3 intertia matrix of the spacecraft. <pre><code>inline auto naomi::spacecraft::get_inertia_matrix () \n</code></pre></p> <p>Returns:</p> <p>Inertia matrix for the spacecraft copied by value. </p>"},{"location":"naomi/classnaomi_1_1spacecraft/#function-get_maneuver_plan","title":"function get_maneuver_plan","text":"<pre><code>inline auto naomi::spacecraft::get_maneuver_plan () \n</code></pre>"},{"location":"naomi/classnaomi_1_1spacecraft/#function-get_pv_coordinates","title":"function get_pv_coordinates","text":"<p>The current positional coordinates of the spacecraft in a given frame. <pre><code>inline auto naomi::spacecraft::get_pv_coordinates (\n    const std::shared_ptr&lt; frames::frame &gt; &amp; frame=nullptr\n) \n</code></pre></p> <p>TODO: Actually implement frame transformation logic.</p> <p>Parameters:</p> <ul> <li><code>frame</code> The desired frame of the pv coordinates </li> </ul> <p>Returns:</p> <p>The current pv coordinates copied by value </p>"},{"location":"naomi/classnaomi_1_1spacecraft/#function-get_state","title":"function get_state","text":"<pre><code>inline auto naomi::spacecraft::get_state () \n</code></pre>"},{"location":"naomi/classnaomi_1_1spacecraft/#function-set_attitude","title":"function set_attitude","text":"<pre><code>inline void naomi::spacecraft::set_attitude (\n    const quaternion_type &amp; attitude\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1spacecraft/#function-spacecraft-13","title":"function spacecraft [1/3]","text":"<pre><code>inline naomi::spacecraft::spacecraft (\n    std::string identifier,\n    const vector_type &amp; state,\n    const double &amp; mass\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1spacecraft/#function-spacecraft-23","title":"function spacecraft [2/3]","text":"<pre><code>inline naomi::spacecraft::spacecraft (\n    std::string identifier,\n    const vector_type &amp; state,\n    const double &amp; mass,\n    const std::shared_ptr&lt; attitude_provider &gt; &amp; attitude_provider\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1spacecraft/#function-spacecraft-33","title":"function spacecraft [3/3]","text":"<pre><code>inline naomi::spacecraft::spacecraft (\n    std::string identifier,\n    const vector_type &amp; state,\n    const double &amp; mass,\n    const std::shared_ptr&lt; maneuvers::maneuver_plan &gt; &amp; mp\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1spacecraft/#function-update","title":"function update","text":"<pre><code>inline void naomi::spacecraft::update (\n    const double dt\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/spacecraft/spacecraft.h</code></p>"},{"location":"naomi/classnaomi_1_1spacecraft__state/","title":"Class naomi::spacecraft_state","text":"<p>ClassList &gt; naomi &gt; spacecraft_state</p> <ul> <li><code>#include &lt;spacecraft_state.h&gt;</code></li> </ul>"},{"location":"naomi/classnaomi_1_1spacecraft__state/#public-functions","title":"Public Functions","text":"Type Name std::shared_ptr&lt; attitude_provider &gt; get_attitude_provider ()  vector_type get_integrated_state ()  std::vector&lt; std::pair&lt; arma::span, std::shared_ptr&lt; integrated_provider &gt; &gt; &gt; get_provider_mapping ()  std::shared_ptr&lt; state_provider &gt; get_state_provider ()  void set_integrated_state (const vector_type &amp; state)  spacecraft_state (const std::shared_ptr&lt; state_provider &gt; &amp; state_provider, const std::shared_ptr&lt; attitude_provider &gt; &amp; attitude_provider, const double mass)"},{"location":"naomi/classnaomi_1_1spacecraft__state/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classnaomi_1_1spacecraft__state/#function-get_attitude_provider","title":"function get_attitude_provider","text":"<pre><code>inline std::shared_ptr&lt; attitude_provider &gt; naomi::spacecraft_state::get_attitude_provider () \n</code></pre>"},{"location":"naomi/classnaomi_1_1spacecraft__state/#function-get_integrated_state","title":"function get_integrated_state","text":"<pre><code>inline vector_type naomi::spacecraft_state::get_integrated_state () \n</code></pre>"},{"location":"naomi/classnaomi_1_1spacecraft__state/#function-get_provider_mapping","title":"function get_provider_mapping","text":"<pre><code>inline std::vector&lt; std::pair&lt; arma::span, std::shared_ptr&lt; integrated_provider &gt; &gt; &gt; naomi::spacecraft_state::get_provider_mapping () \n</code></pre>"},{"location":"naomi/classnaomi_1_1spacecraft__state/#function-get_state_provider","title":"function get_state_provider","text":"<pre><code>inline std::shared_ptr&lt; state_provider &gt; naomi::spacecraft_state::get_state_provider () \n</code></pre>"},{"location":"naomi/classnaomi_1_1spacecraft__state/#function-set_integrated_state","title":"function set_integrated_state","text":"<pre><code>inline void naomi::spacecraft_state::set_integrated_state (\n    const vector_type &amp; state\n) \n</code></pre>"},{"location":"naomi/classnaomi_1_1spacecraft__state/#function-spacecraft_state","title":"function spacecraft_state","text":"<pre><code>inline naomi::spacecraft_state::spacecraft_state (\n    const std::shared_ptr&lt; state_provider &gt; &amp; state_provider,\n    const std::shared_ptr&lt; attitude_provider &gt; &amp; attitude_provider,\n    const double mass\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/spacecraft/spacecraft_state.h</code></p>"},{"location":"naomi/classpv__coordinates/","title":"Class pv_coordinates","text":"<p>ClassList &gt; pv_coordinates</p> <ul> <li><code>#include &lt;pv_coordinates.h&gt;</code></li> </ul>"},{"location":"naomi/classpv__coordinates/#public-functions","title":"Public Functions","text":"Type Name auto get_acceleration () const auto get_position () const auto get_velocity () const pv_coordinates (const naomi::vector_type &amp; state)  pv_coordinates (const arma::vec9 &amp; state)  auto to_vec () const"},{"location":"naomi/classpv__coordinates/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classpv__coordinates/#function-get_acceleration","title":"function get_acceleration","text":"<pre><code>inline auto pv_coordinates::get_acceleration () const\n</code></pre>"},{"location":"naomi/classpv__coordinates/#function-get_position","title":"function get_position","text":"<pre><code>inline auto pv_coordinates::get_position () const\n</code></pre>"},{"location":"naomi/classpv__coordinates/#function-get_velocity","title":"function get_velocity","text":"<pre><code>inline auto pv_coordinates::get_velocity () const\n</code></pre>"},{"location":"naomi/classpv__coordinates/#function-pv_coordinates-12","title":"function pv_coordinates [1/2]","text":"<pre><code>inline explicit pv_coordinates::pv_coordinates (\n    const naomi::vector_type &amp; state\n) \n</code></pre>"},{"location":"naomi/classpv__coordinates/#function-pv_coordinates-22","title":"function pv_coordinates [2/2]","text":"<pre><code>inline explicit pv_coordinates::pv_coordinates (\n    const arma::vec9 &amp; state\n) \n</code></pre>"},{"location":"naomi/classpv__coordinates/#function-to_vec","title":"function to_vec","text":"<pre><code>inline auto pv_coordinates::to_vec () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/spacecraft/pv_coordinates.h</code></p>"},{"location":"naomi/classpv__coordinates__provider/","title":"Class pv_coordinates_provider","text":"<p>ClassList &gt; pv_coordinates_provider</p> <ul> <li><code>#include &lt;pv_coordinates_provider.h&gt;</code></li> </ul> <p>Inherits the following classes: state_provider,  integrated_provider</p>"},{"location":"naomi/classpv__coordinates__provider/#public-functions","title":"Public Functions","text":"Type Name virtual void apply_control (const vector_type &amp; control) override virtual std::shared_ptr&lt; forces::equations_of_motion &gt; get_eoms () override virtual vector_type get_integrated_state () override virtual pv_coordinates get_pv_coordinates () override virtual std::size_t get_size () override pv_coordinates_provider (pv_coordinates initial_state)  virtual void set_integrated_state (const vector_type &amp; state) override ~pv_coordinates_provider () override"},{"location":"naomi/classpv__coordinates__provider/#public-functions-inherited-from-state_provider","title":"Public Functions inherited from state_provider","text":"<p>See state_provider</p> Type Name virtual void apply_control (const naomi::vector_type &amp; control) = 0 virtual pv_coordinates get_pv_coordinates () = 0 virtual ~state_provider () = default"},{"location":"naomi/classpv__coordinates__provider/#public-functions-inherited-from-integrated_provider","title":"Public Functions inherited from integrated_provider","text":"<p>See integrated_provider</p> Type Name virtual std::shared_ptr&lt; naomi::forces::equations_of_motion &gt; get_eoms () = 0 virtual naomi::vector_type get_integrated_state () = 0 virtual std::size_t get_size () = 0 virtual void set_integrated_state (const naomi::vector_type &amp; state) = 0 virtual ~integrated_provider () = default"},{"location":"naomi/classpv__coordinates__provider/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classpv__coordinates__provider/#function-apply_control","title":"function apply_control","text":"<pre><code>inline virtual void pv_coordinates_provider::apply_control (\n    const vector_type &amp; control\n) override\n</code></pre> <p>Implements state_provider::apply_control</p>"},{"location":"naomi/classpv__coordinates__provider/#function-get_eoms","title":"function get_eoms","text":"<pre><code>inline virtual std::shared_ptr&lt; forces::equations_of_motion &gt; pv_coordinates_provider::get_eoms () override\n</code></pre> <p>Implements integrated_provider::get_eoms</p>"},{"location":"naomi/classpv__coordinates__provider/#function-get_integrated_state","title":"function get_integrated_state","text":"<pre><code>inline virtual vector_type pv_coordinates_provider::get_integrated_state () override\n</code></pre> <p>Implements integrated_provider::get_integrated_state</p>"},{"location":"naomi/classpv__coordinates__provider/#function-get_pv_coordinates","title":"function get_pv_coordinates","text":"<pre><code>inline virtual pv_coordinates pv_coordinates_provider::get_pv_coordinates () override\n</code></pre> <p>Implements state_provider::get_pv_coordinates</p>"},{"location":"naomi/classpv__coordinates__provider/#function-get_size","title":"function get_size","text":"<pre><code>inline virtual std::size_t pv_coordinates_provider::get_size () override\n</code></pre> <p>Implements integrated_provider::get_size</p>"},{"location":"naomi/classpv__coordinates__provider/#function-pv_coordinates_provider","title":"function pv_coordinates_provider","text":"<pre><code>inline explicit pv_coordinates_provider::pv_coordinates_provider (\n    pv_coordinates initial_state\n) \n</code></pre>"},{"location":"naomi/classpv__coordinates__provider/#function-set_integrated_state","title":"function set_integrated_state","text":"<pre><code>inline virtual void pv_coordinates_provider::set_integrated_state (\n    const vector_type &amp; state\n) override\n</code></pre> <p>Implements integrated_provider::set_integrated_state</p>"},{"location":"naomi/classpv__coordinates__provider/#function-pv_coordinates_provider_1","title":"function ~pv_coordinates_provider","text":"<pre><code>pv_coordinates_provider::~pv_coordinates_provider () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/spacecraft/pv_coordinates_provider.h</code></p>"},{"location":"naomi/classspacecraft__attitude__subsystem/","title":"Class spacecraft_attitude_subsystem","text":"<p>ClassList &gt; spacecraft_attitude_subsystem</p> <ul> <li><code>#include &lt;spacecraft_attitude_subsystem.h&gt;</code></li> </ul> <p>Inherits the following classes: spacecraft_subsystem</p>"},{"location":"naomi/classspacecraft__attitude__subsystem/#public-functions","title":"Public Functions","text":"Type Name virtual std::vector&lt; std::shared_ptr&lt; attitude::additional_state_provider &gt; &gt; get_additional_state_providers () override void initialize (const spacecraft_state &amp; state) override spacecraft_attitude_subsystem (const std::shared_ptr&lt; attitude::attitude_provider &gt; &amp; provider)  void terminate (const spacecraft_state &amp; state) override void update (const spacecraft_state &amp; state) override ~spacecraft_attitude_subsystem () override"},{"location":"naomi/classspacecraft__attitude__subsystem/#public-functions-inherited-from-spacecraft_subsystem","title":"Public Functions inherited from spacecraft_subsystem","text":"<p>See spacecraft_subsystem</p> Type Name virtual std::vector&lt; std::shared_ptr&lt; attitude::additional_state_provider &gt; &gt; get_additional_state_providers ()  auto get_name () const spacecraft_subsystem (std::string name)  ~spacecraft_subsystem () override"},{"location":"naomi/classspacecraft__attitude__subsystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classspacecraft__attitude__subsystem/#function-get_additional_state_providers","title":"function get_additional_state_providers","text":"<pre><code>virtual std::vector&lt; std::shared_ptr&lt; attitude::additional_state_provider &gt; &gt; spacecraft_attitude_subsystem::get_additional_state_providers () override\n</code></pre> <p>Implements spacecraft_subsystem::get_additional_state_providers</p>"},{"location":"naomi/classspacecraft__attitude__subsystem/#function-initialize","title":"function initialize","text":"<pre><code>void spacecraft_attitude_subsystem::initialize (\n    const spacecraft_state &amp; state\n) override\n</code></pre>"},{"location":"naomi/classspacecraft__attitude__subsystem/#function-spacecraft_attitude_subsystem","title":"function spacecraft_attitude_subsystem","text":"<pre><code>inline spacecraft_attitude_subsystem::spacecraft_attitude_subsystem (\n    const std::shared_ptr&lt; attitude::attitude_provider &gt; &amp; provider\n) \n</code></pre>"},{"location":"naomi/classspacecraft__attitude__subsystem/#function-terminate","title":"function terminate","text":"<pre><code>void spacecraft_attitude_subsystem::terminate (\n    const spacecraft_state &amp; state\n) override\n</code></pre>"},{"location":"naomi/classspacecraft__attitude__subsystem/#function-update","title":"function update","text":"<pre><code>void spacecraft_attitude_subsystem::update (\n    const spacecraft_state &amp; state\n) override\n</code></pre>"},{"location":"naomi/classspacecraft__attitude__subsystem/#function-spacecraft_attitude_subsystem_1","title":"function ~spacecraft_attitude_subsystem","text":"<pre><code>spacecraft_attitude_subsystem::~spacecraft_attitude_subsystem () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/attitude/spacecraft_attitude_subsystem.h</code></p>"},{"location":"naomi/classspacecraft__subsystem/","title":"Class spacecraft_subsystem","text":"<p>ClassList &gt; spacecraft_subsystem</p> <ul> <li><code>#include &lt;spacecraft_subsystem.h&gt;</code></li> </ul> <p>Inherits the following classes: simulation_component&lt; spacecraft_state &gt;</p> <p>Inherited by the following classes: spacecraft_attitude_subsystem</p>"},{"location":"naomi/classspacecraft__subsystem/#public-functions","title":"Public Functions","text":"Type Name virtual std::vector&lt; std::shared_ptr&lt; attitude::additional_state_provider &gt; &gt; get_additional_state_providers ()  auto get_name () const spacecraft_subsystem (std::string name)  ~spacecraft_subsystem () override"},{"location":"naomi/classspacecraft__subsystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classspacecraft__subsystem/#function-get_additional_state_providers","title":"function get_additional_state_providers","text":"<pre><code>inline virtual std::vector&lt; std::shared_ptr&lt; attitude::additional_state_provider &gt; &gt; spacecraft_subsystem::get_additional_state_providers () \n</code></pre>"},{"location":"naomi/classspacecraft__subsystem/#function-get_name","title":"function get_name","text":"<pre><code>inline auto spacecraft_subsystem::get_name () const\n</code></pre>"},{"location":"naomi/classspacecraft__subsystem/#function-spacecraft_subsystem","title":"function spacecraft_subsystem","text":"<pre><code>inline explicit spacecraft_subsystem::spacecraft_subsystem (\n    std::string name\n) \n</code></pre>"},{"location":"naomi/classspacecraft__subsystem/#function-spacecraft_subsystem_1","title":"function ~spacecraft_subsystem","text":"<pre><code>spacecraft_subsystem::~spacecraft_subsystem () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/spacecraft/spacecraft_subsystem.h</code></p>"},{"location":"naomi/classspacecraft__subsystem__state/","title":"Class spacecraft_subsystem_state","text":"<p>ClassList &gt; spacecraft_subsystem_state</p> <ul> <li><code>#include &lt;spacecraft_subsystem.h&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>include/spacecraft/spacecraft_subsystem.h</code></p>"},{"location":"naomi/classstate__provider/","title":"Class state_provider","text":"<p>ClassList &gt; state_provider</p> <ul> <li><code>#include &lt;state_provider.h&gt;</code></li> </ul> <p>Inherited by the following classes: pv_coordinates_provider</p>"},{"location":"naomi/classstate__provider/#public-functions","title":"Public Functions","text":"Type Name virtual void apply_control (const naomi::vector_type &amp; control) = 0 virtual pv_coordinates get_pv_coordinates () = 0 virtual ~state_provider () = default"},{"location":"naomi/classstate__provider/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classstate__provider/#function-apply_control","title":"function apply_control","text":"<pre><code>virtual void state_provider::apply_control (\n    const naomi::vector_type &amp; control\n) = 0\n</code></pre>"},{"location":"naomi/classstate__provider/#function-get_pv_coordinates","title":"function get_pv_coordinates","text":"<pre><code>virtual pv_coordinates state_provider::get_pv_coordinates () = 0\n</code></pre>"},{"location":"naomi/classstate__provider/#function-state_provider","title":"function ~state_provider","text":"<pre><code>virtual state_provider::~state_provider () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/spacecraft/state_provider.h</code></p>"},{"location":"naomi/classtorque__free__attitude__provider/","title":"Class torque_free_attitude_provider","text":"<p>ClassList &gt; torque_free_attitude_provider</p> <ul> <li><code>#include &lt;torque_free_provider.h&gt;</code></li> </ul> <p>Inherits the following classes: naomi::attitude::attitude_provider,  integrated_provider</p>"},{"location":"naomi/classtorque__free__attitude__provider/#public-functions","title":"Public Functions","text":"Type Name virtual void apply_force (const arma::vec3 &amp; forces) override virtual vector_type get_angular_momentum () override virtual vector_type get_angular_velocity () override virtual std::shared_ptr&lt; forces::equations_of_motion &gt; get_eoms () override virtual vector_type get_integrated_state () override virtual quaternion_type get_rotation () override virtual std::size_t get_size () override virtual void set_integrated_state (const vector_type &amp; state) override torque_free_attitude_provider (const arma::mat33 &amp; inertia_matrix, const quaternion_type &amp; q, const pv_coordinates &amp; pv)  torque_free_attitude_provider (const arma::mat33 &amp; inertia_matrix, const quaternion_type &amp; q, const vector_type &amp; pv)"},{"location":"naomi/classtorque__free__attitude__provider/#public-functions-inherited-from-naomiattitudeattitude_provider","title":"Public Functions inherited from naomi::attitude::attitude_provider","text":"<p>See naomi::attitude::attitude_provider</p> Type Name virtual void apply_force (const arma::vec3 &amp; forces) = 0 virtual vector_type get_angular_momentum () = 0 virtual vector_type get_angular_velocity () = 0 virtual quaternion_type get_rotation () = 0 virtual ~attitude_provider () = default"},{"location":"naomi/classtorque__free__attitude__provider/#public-functions-inherited-from-integrated_provider","title":"Public Functions inherited from integrated_provider","text":"<p>See integrated_provider</p> Type Name virtual std::shared_ptr&lt; naomi::forces::equations_of_motion &gt; get_eoms () = 0 virtual naomi::vector_type get_integrated_state () = 0 virtual std::size_t get_size () = 0 virtual void set_integrated_state (const naomi::vector_type &amp; state) = 0 virtual ~integrated_provider () = default"},{"location":"naomi/classtorque__free__attitude__provider/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/classtorque__free__attitude__provider/#function-apply_force","title":"function apply_force","text":"<pre><code>inline virtual void torque_free_attitude_provider::apply_force (\n    const arma::vec3 &amp; forces\n) override\n</code></pre> <p>Implements naomi::attitude::attitude_provider::apply_force</p>"},{"location":"naomi/classtorque__free__attitude__provider/#function-get_angular_momentum","title":"function get_angular_momentum","text":"<pre><code>inline virtual vector_type torque_free_attitude_provider::get_angular_momentum () override\n</code></pre> <p>Implements naomi::attitude::attitude_provider::get_angular_momentum</p>"},{"location":"naomi/classtorque__free__attitude__provider/#function-get_angular_velocity","title":"function get_angular_velocity","text":"<pre><code>inline virtual vector_type torque_free_attitude_provider::get_angular_velocity () override\n</code></pre> <p>Implements naomi::attitude::attitude_provider::get_angular_velocity</p>"},{"location":"naomi/classtorque__free__attitude__provider/#function-get_eoms","title":"function get_eoms","text":"<pre><code>inline virtual std::shared_ptr&lt; forces::equations_of_motion &gt; torque_free_attitude_provider::get_eoms () override\n</code></pre> <p>Implements integrated_provider::get_eoms</p>"},{"location":"naomi/classtorque__free__attitude__provider/#function-get_integrated_state","title":"function get_integrated_state","text":"<pre><code>inline virtual vector_type torque_free_attitude_provider::get_integrated_state () override\n</code></pre> <p>Implements integrated_provider::get_integrated_state</p>"},{"location":"naomi/classtorque__free__attitude__provider/#function-get_rotation","title":"function get_rotation","text":"<pre><code>inline virtual quaternion_type torque_free_attitude_provider::get_rotation () override\n</code></pre> <p>Implements naomi::attitude::attitude_provider::get_rotation</p>"},{"location":"naomi/classtorque__free__attitude__provider/#function-get_size","title":"function get_size","text":"<pre><code>inline virtual std::size_t torque_free_attitude_provider::get_size () override\n</code></pre> <p>Implements integrated_provider::get_size</p>"},{"location":"naomi/classtorque__free__attitude__provider/#function-set_integrated_state","title":"function set_integrated_state","text":"<pre><code>inline virtual void torque_free_attitude_provider::set_integrated_state (\n    const vector_type &amp; state\n) override\n</code></pre> <p>Implements integrated_provider::set_integrated_state</p>"},{"location":"naomi/classtorque__free__attitude__provider/#function-torque_free_attitude_provider-12","title":"function torque_free_attitude_provider [1/2]","text":"<pre><code>inline torque_free_attitude_provider::torque_free_attitude_provider (\n    const arma::mat33 &amp; inertia_matrix,\n    const quaternion_type &amp; q,\n    const pv_coordinates &amp; pv\n) \n</code></pre>"},{"location":"naomi/classtorque__free__attitude__provider/#function-torque_free_attitude_provider-22","title":"function torque_free_attitude_provider [2/2]","text":"<pre><code>inline torque_free_attitude_provider::torque_free_attitude_provider (\n    const arma::mat33 &amp; inertia_matrix,\n    const quaternion_type &amp; q,\n    const vector_type &amp; pv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/attitude/torque_free_provider.h</code></p>"},{"location":"naomi/dir_d44c64559bbebec7f509842c48db8b23/","title":"Dir include","text":"<p>FileList &gt; include</p>"},{"location":"naomi/dir_d44c64559bbebec7f509842c48db8b23/#files","title":"Files","text":"Type Name file constants.h file naomi.h"},{"location":"naomi/dir_d44c64559bbebec7f509842c48db8b23/#directories","title":"Directories","text":"Type Name dir attitude dir bodies dir control dir forces dir frames dir integrators dir maneuvers dir math dir observers dir orbits dir propagators dir simulation dir spacecraft dir systems <p>The documentation for this class was generated from the following file <code>include/</code></p>"},{"location":"naomi/constants_8h/","title":"File constants.h","text":"<p>FileList &gt; include &gt; constants.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;armadillo&gt;</code></li> </ul>"},{"location":"naomi/constants_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace constants"},{"location":"naomi/constants_8h/#macros","title":"Macros","text":"Type Name define GRAVITATIONAL_CONSTANT  6.67428e-11L"},{"location":"naomi/constants_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"naomi/constants_8h/#define-gravitational_constant","title":"define GRAVITATIONAL_CONSTANT","text":"<pre><code>#define GRAVITATIONAL_CONSTANT 6.67428e-11L\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/constants.h</code></p>"},{"location":"naomi/constants_8h_source/","title":"File constants.h","text":"<p>File List &gt; include &gt; constants.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 6/10/2024.\n//\n\n#ifndef CONSTANTS_H\n#define CONSTANTS_H\n\n#ifndef GRAVITATIONAL_CONSTANT\n#define GRAVITATIONAL_CONSTANT 6.67428e-11L\n#endif\n\n#include &lt;armadillo&gt;\n\n// #ifndef EARTH_MU\n// #define EARTH_MU (3.986004418*10e14)\n// // #define EARTH_MU (3.9800000*10e14)\n\nnamespace naomi::constants\n{\nconstexpr double EARTH_MU = 3.986004418*1e14;\nconstexpr double EARTH_MU_KM = 3.986004418*1e5;\nconst arma::vec3 PLUS_I({1, 0, 0});\nconst arma::vec3 PLUS_J({0, 1, 0});\nconst arma::vec3 PLUS_K({0, 0, 1});\nconst arma::vec3 MINUS_I({-1, 0, 0});\nconst arma::vec3 MINUS_J({0, -1, 0});\nconst arma::vec3 MINUS_K({0, 0, -1});\n\n}\n\n\n\n// #define EARTH_MU 398600.4418\n#endif\n</code></pre>"},{"location":"naomi/dir_475d33b39e6bc997ea6d18d5c9545513/","title":"Dir include/attitude","text":"<p>FileList &gt; attitude</p>"},{"location":"naomi/dir_475d33b39e6bc997ea6d18d5c9545513/#files","title":"Files","text":"Type Name file angular_coordinates.h file attitude_provider.h file constant_attitude_provider.h file euler_angles.h file rotation.h file spacecraft_attitude_subsystem.h file torque_free.h file torque_free_provider.h <p>The documentation for this class was generated from the following file <code>include/attitude/</code></p>"},{"location":"naomi/angular__coordinates_8h/","title":"File angular_coordinates.h","text":"<p>FileList &gt; attitude &gt; angular_coordinates.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"math/quaternion.h\"</code></li> <li><code>#include &lt;naomi.h&gt;</code></li> </ul>"},{"location":"naomi/angular__coordinates_8h/#classes","title":"Classes","text":"Type Name class angular_coordinates <p>The documentation for this class was generated from the following file <code>include/attitude/angular_coordinates.h</code></p>"},{"location":"naomi/angular__coordinates_8h_source/","title":"File angular_coordinates.h","text":"<p>File List &gt; attitude &gt; angular_coordinates.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 7/24/2024.\n//\n\n#ifndef ANGULAR_COORDINATES_H\n#define ANGULAR_COORDINATES_H\n#include \"math/quaternion.h\"\n#include &lt;naomi.h&gt;\n\nusing namespace naomi::math::quaternion;\nusing namespace naomi;\n\nclass angular_coordinates\n{\n  quaternion_type _rotation;\n\npublic:\n  explicit angular_coordinates(const quaternion_type&amp; rotation): _rotation(rotation){}\n\n  auto get_rotation() -&gt; quaternion_type&amp;\n  {\n    return _rotation;\n  }\n\n  static angular_coordinates identity()\n  {\n    return angular_coordinates({1, 0, 0, 0});\n  }\n\n  auto to_vec() -&gt; vector_type&amp;\n  {\n   return _rotation;\n  }\n};\n\n#endif //ANGULAR_COORDINATES_H\n</code></pre>"},{"location":"naomi/attitude__provider_8h/","title":"File attitude_provider.h","text":"<p>FileList &gt; attitude &gt; attitude_provider.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"naomi.h\"</code></li> </ul>"},{"location":"naomi/attitude__provider_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace attitude"},{"location":"naomi/attitude__provider_8h/#classes","title":"Classes","text":"Type Name class additional_state_provider class attitude_provider <p>The documentation for this class was generated from the following file <code>include/attitude/attitude_provider.h</code></p>"},{"location":"naomi/attitude__provider_8h_source/","title":"File attitude_provider.h","text":"<p>File List &gt; attitude &gt; attitude_provider.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/10/2024.\n//\n\n#ifndef ATTITUDE_LAW_H\n#define ATTITUDE_LAW_H\n\n\n#include \"naomi.h\"\n\n\nnamespace naomi::attitude\n{\n\nclass additional_state_provider\n{\n\nprotected:\n  std::string _name;\n  vector_type m_state;\npublic:\n  explicit additional_state_provider(std::string name, vector_type state): _name(std::move(name)), m_state(std::move(state)){}\n  virtual ~additional_state_provider() = default;\n  [[nodiscard]] virtual std::string get_name() const\n  {\n    return _name;\n  }\n  [[nodiscard]] virtual vector_type get_state() const\n  {\n    return m_state;\n  };\n  [[nodiscard]] virtual vector_type get_derivative(const vector_type&amp; state) const = 0;\n  [[nodiscard]] virtual std::size_t get_size()\n  {\n      return m_state.size();\n  };\n  // virtual void initialize(const spacecraft_state&amp; state) {}\n\n};\n\n\nclass attitude_provider\n{\npublic:\n  virtual ~attitude_provider() = default;\n  virtual quaternion_type get_rotation() = 0;\n  virtual vector_type get_angular_momentum() = 0;\n  virtual vector_type get_angular_velocity() = 0;\n  // virtual std::shared_ptr&lt;additional_state_provider&gt; get_additional_state_provider()\n  // {\n  //   return nullptr;\n  // }\n  virtual void apply_force(const arma::vec3&amp; forces) = 0;\n};\n}\n#endif //ATTITUDE_LAW_H\n</code></pre>"},{"location":"naomi/constant__attitude__provider_8h/","title":"File constant_attitude_provider.h","text":"<p>FileList &gt; attitude &gt; constant_attitude_provider.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"attitude_provider.h\"</code></li> </ul>"},{"location":"naomi/constant__attitude__provider_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace attitude"},{"location":"naomi/constant__attitude__provider_8h/#classes","title":"Classes","text":"Type Name class constant_attitude_provider <p>The documentation for this class was generated from the following file <code>include/attitude/constant_attitude_provider.h</code></p>"},{"location":"naomi/constant__attitude__provider_8h_source/","title":"File constant_attitude_provider.h","text":"<p>File List &gt; attitude &gt; constant_attitude_provider.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 8/1/2024.\n//\n\n#ifndef CONSTANT_ATTITUDE_PROVIDER_H\n#define CONSTANT_ATTITUDE_PROVIDER_H\n\n#include \"attitude_provider.h\"\n\nnamespace naomi::attitude\n{\nclass constant_attitude_provider final : public attitude_provider\n{\n  quaternion_type _attitude;\npublic:\n  constant_attitude_provider() = default;\n  explicit constant_attitude_provider(const quaternion_type&amp; q): _attitude(q){}\n  ~constant_attitude_provider() override = default;\n  quaternion_type get_rotation() override { return _attitude; }\n  vector_type get_angular_momentum() override\n  {\n    return {0, 0, 0};\n  };\n  vector_type get_angular_velocity() override\n  {\n    return {0, 0, 0};\n  };\n  void apply_force(const arma::vec3&amp; forces) override {}\n};\n}\n#endif //CONSTANT_ATTITUDE_PROVIDER_H\n</code></pre>"},{"location":"naomi/euler__angles_8h/","title":"File euler_angles.h","text":"<p>FileList &gt; attitude &gt; euler_angles.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"rotation.h\"</code></li> </ul>"},{"location":"naomi/euler__angles_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace attitude"},{"location":"naomi/euler__angles_8h/#classes","title":"Classes","text":"Type Name class euler_angles <p>The documentation for this class was generated from the following file <code>include/attitude/euler_angles.h</code></p>"},{"location":"naomi/euler__angles_8h_source/","title":"File euler_angles.h","text":"<p>File List &gt; attitude &gt; euler_angles.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/12/2024.\n//\n\n#ifndef EULER_ANGLES_H\n#define EULER_ANGLES_H\n#include \"rotation.h\"\n\nnamespace naomi::attitude\n{\n\nenum rotation_order\n{\n  XYZ,\n  XYX,\n  XZY,\n  XZX,\n  YXZ,\n  YXY,\n  YZX,\n  YZY,\n  ZXY,\n  ZXZ,\n  ZYX,\n  ZYZ\n};\n\nclass euler_angles: public rotation\n{\n  double m_alpha;\n  double m_beta;\n  double m_gamma;\n  rotation_order m_rotation_order;\n\n  std::map&lt;rotation_order, std::array&lt;int, 3&gt;&gt; m_rotation_order_map = {\n    {XYZ, {1, 2, 3}},\n    {XYX, {1, 2, 1}},\n    {XZY, {1, 3, 2}},\n    {XZX, {1, 3, 1}},\n    {YXZ, {2, 1, 3}},\n    {YXY, {2, 1, 2}},\n    {YZX, {2, 3, 1}},\n    {YZY, {2, 3, 2}},\n    {ZXY, {3, 1, 2}},\n    {ZXZ, {3, 1, 3}},\n    {ZYX, {3, 2, 1}},\n    {ZYZ, {3, 2, 3}}\n  };\n\npublic:\n  euler_angles(const double alpha, const double beta, const double gamma, const rotation_order order):\n    m_alpha(alpha), m_beta(beta), m_gamma(gamma), m_rotation_order(order){}\n  ~euler_angles() override = default;\n  std::shared_ptr&lt;rotation&gt; apply_to(\n      const std::shared_ptr&lt;rotation&gt;&amp; r) override\n  {\n    return r;\n  }\n\n  arma::vec3 apply_to(const arma::vec3&amp; r) override\n  {\n    return r;\n  }\n\n  arma::mat33 get_dcm() override\n  {\n    const std::array&lt;int, 3&gt; rotation_order_arr =\n        m_rotation_order_map[m_rotation_order];\n    const auto rot1 = get_axis_rotation(rotation_order_arr[0], m_alpha);\n    const auto rot2 = get_axis_rotation(rotation_order_arr[1], m_beta);\n    const auto rot3 = get_axis_rotation(rotation_order_arr[2], m_gamma);\n    return rot1 * rot2 * rot3;\n  }\n\n  static arma::mat33 get_axis_rotation(int axis, double th)\n  {\n    if (axis == 1) {\n      return {\n        {1, 0, 0},\n        {0, cos(th), sin(th)},\n        {0, -sin(th), cos(th)}\n      };\n    }\n    if (axis == 2) {\n      return {\n          {cos(th), 0, -sin(th)},\n          {0, 1, 0},\n          {sin(th), 0, cos(th)}\n      };\n    }\n    if (axis == 3) {\n      return {\n          {cos(th), sin(th), 0},\n          {-sin(th), cos(th), 0},\n          {0, 0, 1}\n      };\n    }\n    throw std::runtime_error(fmt::format(\"Invalid axis: {}\", axis));\n  }\n};\n}\n\n#endif //EULER_ANGLES_H\n</code></pre>"},{"location":"naomi/rotation_8h/","title":"File rotation.h","text":"<p>FileList &gt; attitude &gt; rotation.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;armadillo&gt;</code></li> </ul>"},{"location":"naomi/rotation_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace attitude"},{"location":"naomi/rotation_8h/#classes","title":"Classes","text":"Type Name class rotation <p>The documentation for this class was generated from the following file <code>include/attitude/rotation.h</code></p>"},{"location":"naomi/rotation_8h_source/","title":"File rotation.h","text":"<p>File List &gt; attitude &gt; rotation.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/12/2024.\n//\n\n#ifndef ROTATION_H\n#define ROTATION_H\n#include &lt;memory&gt;\n#include &lt;armadillo&gt;\n\nnamespace naomi::attitude\n{\nclass rotation\n{\npublic:\n  virtual ~rotation() = default;\n  virtual std::shared_ptr&lt;rotation&gt; apply_to(const std::shared_ptr&lt;rotation&gt;&amp; r) = 0;\n  virtual arma::vec3 apply_to(const arma::vec3&amp; r) = 0;\n  virtual arma::mat33 get_dcm() = 0;\n\n};\n}\n#endif //ROTATION_H\n</code></pre>"},{"location":"naomi/spacecraft__attitude__subsystem_8h/","title":"File spacecraft_attitude_subsystem.h","text":"<p>FileList &gt; attitude &gt; spacecraft_attitude_subsystem.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"spacecraft/spacecraft_subsystem.h\"</code></li> </ul>"},{"location":"naomi/spacecraft__attitude__subsystem_8h/#classes","title":"Classes","text":"Type Name class spacecraft_attitude_subsystem <p>The documentation for this class was generated from the following file <code>include/attitude/spacecraft_attitude_subsystem.h</code></p>"},{"location":"naomi/spacecraft__attitude__subsystem_8h_source/","title":"File spacecraft_attitude_subsystem.h","text":"<p>File List &gt; attitude &gt; spacecraft_attitude_subsystem.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 7/24/2024.\n//\n\n#ifndef ATTITUDE_SUBSYSTEM_H\n#define ATTITUDE_SUBSYSTEM_H\n#include \"spacecraft/spacecraft_subsystem.h\"\n\nclass spacecraft_attitude_subsystem: public spacecraft_subsystem\n{\n  std::shared_ptr&lt;attitude::attitude_provider&gt; _provider;\npublic:\n  spacecraft_attitude_subsystem(\n    const std::shared_ptr&lt;attitude::attitude_provider&gt;&amp; provider)\n      : spacecraft_subsystem(\"AttitudeSubsystem\")\n        , _provider(provider)\n  {\n  }\n  std::vector&lt;std::shared_ptr&lt;attitude::additional_state_provider&gt;&gt;\n  get_additional_state_providers() override;\n  void initialize(const spacecraft_state&amp; state) override;\n  void update(const spacecraft_state&amp; state) override;\n  void terminate(const spacecraft_state&amp; state) override;\n  ~spacecraft_attitude_subsystem() override;\n};\n#endif //ATTITUDE_SUBSYSTEM_H\n</code></pre>"},{"location":"naomi/torque__free_8h/","title":"File torque_free.h","text":"<p>FileList &gt; attitude &gt; torque_free.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"frames/transforms.h\"</code></li> <li><code>#include \"math/vector_utils.h\"</code></li> <li><code>#include \"spacecraft/state_provider.h\"</code></li> </ul>"},{"location":"naomi/torque__free_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace attitude"},{"location":"naomi/torque__free_8h/#classes","title":"Classes","text":"Type Name class torque_free_eoms <p>The documentation for this class was generated from the following file <code>include/attitude/torque_free.h</code></p>"},{"location":"naomi/torque__free_8h_source/","title":"File torque_free.h","text":"<p>File List &gt; attitude &gt; torque_free.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/10/2024.\n//\n\n#ifndef TORQUE_FREE_H\n#define TORQUE_FREE_H\n\n#include \"frames/transforms.h\"\n#include \"math/vector_utils.h\"\n#include \"spacecraft/state_provider.h\"\n\nnamespace naomi::attitude\n{\nusing namespace math;\n\nclass torque_free_eoms final :\n  public forces::equations_of_motion\n{\n\n  arma::mat33 _inertia_matrix;\n\npublic:\n  explicit torque_free_eoms(const arma::mat33&amp; inertia_matrix): _inertia_matrix(inertia_matrix){}\n  ~torque_free_eoms() override = default;\n  [[nodiscard]] vector_type get_derivative(const vector_type&amp; state, double t) const override\n  {\n    const auto q = state(arma::span(0, 3));\n    const auto w = state(arma::span(4, 6));\n    const vector_type w4 = {0, w[0], w[1], w[2]};\n    const vector_type q_dot = 0.5 * q_skew(q) * w4;\n    const arma::vec3 w_dot = {\n      -(_inertia_matrix(2, 2) - _inertia_matrix(1, 1))*w[1]*w[2] / _inertia_matrix(0, 0),\n      -(_inertia_matrix(0, 0) - _inertia_matrix(2, 2))*w[2]*w[0] / _inertia_matrix(1, 1),\n      -(_inertia_matrix(1, 1) - _inertia_matrix(0, 0))*w[0]*w[1] / _inertia_matrix(2, 2),\n    };\n    vector_type res(10);\n    res(arma::span(0, 3)) = q_dot;\n    res(arma::span(4, 6)) = w_dot;\n    return res;\n  }\n\n};\n}\n#endif //TORQUE_FREE_H\n</code></pre>"},{"location":"naomi/torque__free__provider_8h/","title":"File torque_free_provider.h","text":"<p>FileList &gt; attitude &gt; torque_free_provider.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"attitude/attitude_provider.h\"</code></li> <li><code>#include \"spacecraft/state_provider.h\"</code></li> <li><code>#include \"torque_free.h\"</code></li> </ul>"},{"location":"naomi/torque__free__provider_8h/#classes","title":"Classes","text":"Type Name class torque_free_attitude_provider <p>The documentation for this class was generated from the following file <code>include/attitude/torque_free_provider.h</code></p>"},{"location":"naomi/torque__free__provider_8h_source/","title":"File torque_free_provider.h","text":"<p>File List &gt; attitude &gt; torque_free_provider.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 7/31/2024.\n//\n\n#ifndef TORQUE_FREE_PROVIDER_H\n#define TORQUE_FREE_PROVIDER_H\n\n#include &lt;utility&gt;\n\n#include \"attitude/attitude_provider.h\"\n#include \"spacecraft/state_provider.h\"\n#include \"torque_free.h\"\n\nclass torque_free_attitude_provider:\n  public attitude::attitude_provider,\n  public integrated_provider\n{\n\n  quaternion_type _q = {1, 0, 0, 0};\n  vector_type _w = {0, 0, 0};\n  vector_type _wdot = {0, 0, 0};\n  arma::mat33 _inertia_matrix;\n  std::shared_ptr&lt;forces::equations_of_motion&gt; _eoms;\n\n  static vector_type compute_angular_velocity(const vector_type&amp; state)\n  {\n    const auto t = eci2ric(state(arma::span(0, 5)));\n    const vector_type r = state(arma::span(0, 2));\n    const vector_type v = state(arma::span(3, 5));\n    const vector_type w = t * cross(r, v) / dot(r, r);\n    return w;\n  }\n\n  static vector_type compute_angular_velocity(const pv_coordinates&amp; state)\n  {\n    const vector_type r = state.get_position();\n    const vector_type v = state.get_velocity();\n    const vector_type pv = join_cols(r, v);\n    const auto t = eci2ric(pv);\n    const vector_type w = t * cross(r, v) / dot(r, r);\n    return w;\n  }\n\npublic:\n  torque_free_attitude_provider(\n      const arma::mat33&amp; inertia_matrix,\n      const quaternion_type&amp; q,\n      const pv_coordinates&amp; pv):\n      _q(q)\n      , _w(compute_angular_velocity(pv))\n      , _inertia_matrix(inertia_matrix)\n      , _eoms(std::make_shared&lt;attitude::torque_free_eoms&gt;(inertia_matrix))\n  {\n  }\n\n  torque_free_attitude_provider(\n    const arma::mat33&amp; inertia_matrix,\n    const quaternion_type&amp; q,\n    const vector_type&amp; pv):\n    _q(q)\n    , _w(compute_angular_velocity(pv))\n    , _inertia_matrix(inertia_matrix)\n    , _eoms(std::make_shared&lt;attitude::torque_free_eoms&gt;(inertia_matrix))\n  {\n  }\n\n  quaternion_type get_rotation() override\n  {\n    return _q;\n  }\n  vector_type get_angular_momentum() override\n  {\n    return {0, 0, 1};\n  }\n  vector_type get_angular_velocity() override\n  {\n    return _w;\n  }\n  std::shared_ptr&lt;forces::equations_of_motion&gt; get_eoms() override\n  {\n    return _eoms;\n  }\n\n  std::size_t get_size() override\n  {\n    return 10;\n  }\n\n  [[nodiscard]] vector_type get_integrated_state() override\n  {\n    vector_type state(10);\n    state(arma::span(0, 3)) = _q;\n    state(arma::span(4, 6)) = _w;\n    state(arma::span(7, 9)) = _wdot;\n    return state;\n  }\n\n  void set_integrated_state(const vector_type&amp; state) override\n  {\n    _q = state(arma::span(0, 3));\n    _w = state(arma::span(4, 6));\n    _wdot = state(arma::span(7, 9));\n  }\n\n  void apply_force(const arma::vec3&amp; forces) override {}\n};\n\n#endif //TORQUE_FREE_PROVIDER_H\n</code></pre>"},{"location":"naomi/dir_51af20585daf02d6159fda884adf2140/","title":"Dir include/bodies","text":"<p>FileList &gt; bodies</p>"},{"location":"naomi/dir_51af20585daf02d6159fda884adf2140/#files","title":"Files","text":"Type Name file celestial_body.h file earth.h <p>The documentation for this class was generated from the following file <code>include/bodies/</code></p>"},{"location":"naomi/celestial__body_8h/","title":"File celestial_body.h","text":"<p>FileList &gt; bodies &gt; celestial_body.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;Eigen/Dense&gt;</code></li> <li><code>#include &lt;symengine/expression.h&gt;</code></li> <li><code>#include &lt;armadillo&gt;</code></li> <li><code>#include &lt;symengine/lambda_double.h&gt;</code></li> <li><code>#include &lt;symengine/llvm_double.h&gt;</code></li> </ul>"},{"location":"naomi/celestial__body_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace bodies"},{"location":"naomi/celestial__body_8h/#classes","title":"Classes","text":"Type Name class celestial_body <p>The documentation for this class was generated from the following file <code>include/bodies/celestial_body.h</code></p>"},{"location":"naomi/celestial__body_8h_source/","title":"File celestial_body.h","text":"<p>File List &gt; bodies &gt; celestial_body.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 6/2/2024.\n//\n\n#ifndef CELESTIAL_BODY_H\n#define CELESTIAL_BODY_H\n\n#include &lt;Eigen/Dense&gt;\n#include &lt;symengine/expression.h&gt;\n#include &lt;armadillo&gt;\n\n#include &lt;symengine/lambda_double.h&gt;\n#include &lt;symengine/llvm_double.h&gt;\n\nnamespace naomi::bodies\n{\nclass celestial_body\n{\nprotected:\n  double m_mu;\n  double m_soi;\n  double m_eq_radius;\n  std::vector&lt;double&gt; m_higher_order_terms;\n  SymEngine::Expression m_potential_exp;\n  SymEngine::RCP&lt;const SymEngine::Basic&gt; m_potential_partial_x;\n  SymEngine::RCP&lt;const SymEngine::Basic&gt; m_potential_partial_y;\n  SymEngine::RCP&lt;const SymEngine::Basic&gt; m_potential_partial_z;\n  SymEngine::LLVMDoubleVisitor m_potential_partial_x_visitor;\n  SymEngine::LLVMDoubleVisitor m_potential_partial_y_visitor;\n  SymEngine::LLVMDoubleVisitor m_potential_partial_z_visitor;\n\npublic:\n  virtual ~celestial_body() = default;\n  explicit celestial_body(const double mu, const double soi, const double eq_radius, const std::initializer_list&lt;double&gt; higher_order_terms = {}): m_mu(mu), m_soi(soi), m_eq_radius(eq_radius), m_higher_order_terms(higher_order_terms)\n  {\n    SymEngine::RCP&lt;const SymEngine::Basic&gt; x, y, z, c;\n    x = SymEngine::symbol(\"x\");\n    y = SymEngine::symbol(\"y\");\n    z = SymEngine::symbol(\"z\");\n    c = SymEngine::symbol(\"c\");\n\n    auto r = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));\n    auto sin_ph = SymEngine::mul(z, pow(r, -1));\n    m_potential_exp = -m_mu * pow(r, -1) - c * pow(r, -3) * (1 - 3 * pow(sin_ph, 2));\n    m_potential_partial_x = m_potential_exp.diff(x);\n    m_potential_partial_y = m_potential_exp.diff(y);\n    m_potential_partial_z = m_potential_exp.diff(z);\n    m_potential_partial_x_visitor.init({x, y, z, c}, *m_potential_partial_x);\n    m_potential_partial_y_visitor.init({x, y, z, c}, *m_potential_partial_y);\n    m_potential_partial_z_visitor.init({x, y, z, c}, *m_potential_partial_z);\n  }\n  virtual SymEngine::Expression get_potential()\n  {\n    return m_potential_exp;\n  }\n\n  virtual double get_potential(arma::vec&amp; pos)\n  {\n    SymEngine::Expression x(\"x\");\n    SymEngine::Expression y(\"y\");\n    SymEngine::Expression z(\"z\");\n    SymEngine::Expression c(\"c\");\n\n    auto v = m_potential_exp.subs({\n        {x, SymEngine::real_double(pos[0])},\n        {y, SymEngine::real_double(pos[1])},\n        {z, SymEngine::real_double(pos[2])},\n        {c, SymEngine::real_double(m_mu * m_higher_order_terms[0] * pow(m_eq_radius, 2) / 2)}\n    });\n    return static_cast&lt;double&gt;(v);\n  }\n\n  virtual arma::vec get_potential_partial(arma::vec&amp; pos)\n  {\n    double c = m_mu * m_higher_order_terms[0] * pow(m_eq_radius, 2) / 2;\n    const double du_x =\n        m_potential_partial_x_visitor.call({pos[0], pos[1], pos[2], c});\n    const double du_y =\n        m_potential_partial_y_visitor.call({pos[0], pos[1], pos[2], c});\n    const double du_z = m_potential_partial_z_visitor.call({pos[0], pos[1], pos[2], c});\n\n    arma::vec result = { du_x, du_y, du_z };\n    return result;\n  };\n  virtual Eigen::Vector3d get_potential_partial_derivative(Eigen::Vector3d position) = 0;\n  virtual arma::vec get_potential_partial_derivative(arma::vec position) = 0;\n\n  [[nodiscard]] auto get_mu() const -&gt; double\n  {\n    return m_mu;\n  }\n\n  [[nodiscard]] auto get_sphere_of_influence() const -&gt; double\n  {\n    return m_soi;\n  }\n};\n}\n#endif //CELESTIAL_BODY_H\n</code></pre>"},{"location":"naomi/earth_8h/","title":"File earth.h","text":"<p>FileList &gt; bodies &gt; earth.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"celestial_body.h\"</code></li> <li><code>#include \"constants.h\"</code></li> <li><code>#include &lt;symengine/expression.h&gt;</code></li> <li><code>#include &lt;symengine/lambda_double.h&gt;</code></li> </ul>"},{"location":"naomi/earth_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace bodies"},{"location":"naomi/earth_8h/#classes","title":"Classes","text":"Type Name class earth"},{"location":"naomi/earth_8h/#macros","title":"Macros","text":"Type Name define EARTH_EQ_RADIUS  6378.1 * 1000.0 define EARTH_J2  1082.63 * 10e-6 define EARTH_SOI  9.24 * 10e5 * 1000.0"},{"location":"naomi/earth_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"naomi/earth_8h/#define-earth_eq_radius","title":"define EARTH_EQ_RADIUS","text":"<pre><code>#define EARTH_EQ_RADIUS 6378.1 * 1000.0\n</code></pre>"},{"location":"naomi/earth_8h/#define-earth_j2","title":"define EARTH_J2","text":"<pre><code>#define EARTH_J2 1082.63 * 10e-6\n</code></pre>"},{"location":"naomi/earth_8h/#define-earth_soi","title":"define EARTH_SOI","text":"<pre><code>#define EARTH_SOI 9.24 * 10e5 * 1000.0\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/bodies/earth.h</code></p>"},{"location":"naomi/earth_8h_source/","title":"File earth.h","text":"<p>File List &gt; bodies &gt; earth.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 6/2/2024.\n//\n\n#ifndef EARTH_H\n#define EARTH_H\n#include \"celestial_body.h\"\n#include \"constants.h\"\n#include &lt;symengine/expression.h&gt;\n#include &lt;symengine/lambda_double.h&gt;\n\nusing SymEngine::Expression;\n\n#ifndef EARTH_SOI\n#define EARTH_SOI 9.24 * 10e5 * 1000.0 // meters\n#endif\n\n#ifndef EARTH_J2\n#define EARTH_J2  1082.63 * 10e-6\n#endif\n\n#ifndef EARTH_EQ_RADIUS\n#define EARTH_EQ_RADIUS 6378.1 * 1000.0 // meters\n#endif\n\nnamespace naomi::bodies\n{\nclass earth : public celestial_body\n{\n  double earth_j2 = 1082.63 * 10e-6;\n  double earth_radius = 6378.1 * 1000.0; // meters\n  double a_j2 = 0.5 * earth_j2 * pow(earth_radius, 2);\n\npublic:\n  earth()\n    : celestial_body(constants::EARTH_MU, EARTH_SOI, EARTH_EQ_RADIUS, {EARTH_J2}){}\n\n  ~earth() override = default;\n\n  auto get_potential_partial_derivative(\n      Eigen::Vector3d position)\n    -&gt; Eigen::Vector3d override\n  {\n    double x = position[0];\n    double y = position[1];\n    double z = position[2];\n    Eigen::Vector3d result;\n\n    const double r = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));\n    double u_x = m_mu\n        * (-x / pow(r, 3)\n          + a_j2 * (15 * x * pow(z, 2) / pow(r, 7) - 3 * x / pow(r, 5)));\n    double u_y = m_mu\n        * (-y / pow(r, 3)\n          + a_j2 * (15 * y * pow(z, 2) / pow(r, 7) - 3 * y / pow(r, 5)));\n    double u_z = m_mu\n        * (-z / pow(r, 3)\n          + a_j2 * (15 * z * pow(z, 2) / pow(r, 7) - 9 * z / pow(r, 5)));\n\n    result &lt;&lt; u_x, u_y, u_z;\n    return result;\n  }\n\n  auto get_potential_partial_derivative(arma::vec position)\n    -&gt; arma::vec override\n  {\n    double x = position[0];\n    double y = position[1];\n    double z = position[2];\n\n    const double r = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));\n    double u_x = m_mu\n        * (-x / pow(r, 3)\n          + a_j2 * (15 * x * pow(z, 2) / pow(r, 7) - 3 * x / pow(r, 5)));\n    double u_y = m_mu\n        * (-y / pow(r, 3)\n          + a_j2 * (15 * y * pow(z, 2) / pow(r, 7) - 3 * y / pow(r, 5)));\n    double u_z = m_mu\n        * (-z / pow(r, 3)\n          + a_j2 * (15 * z * pow(z, 2) / pow(r, 7) - 9 * z / pow(r, 5)));\n\n    arma::vec result = {u_x, u_y, u_z};\n    return result;\n  }\n};\n}\n\n#endif //EARTH_H\n</code></pre>"},{"location":"naomi/dir_a4935814f13a540f683bf390f3273be3/","title":"Dir include/control","text":"<p>FileList &gt; control</p>"},{"location":"naomi/dir_a4935814f13a540f683bf390f3273be3/#files","title":"Files","text":"Type Name file controller.h file pid_controller.h <p>The documentation for this class was generated from the following file <code>include/control/</code></p>"},{"location":"naomi/controller_8h/","title":"File controller.h","text":"<p>FileList &gt; control &gt; controller.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"naomi.h\"</code></li> <li><code>#include \"spacecraft/spacecraft_state.h\"</code></li> </ul>"},{"location":"naomi/controller_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace control"},{"location":"naomi/controller_8h/#classes","title":"Classes","text":"Type Name class control_input class controller <p>The documentation for this class was generated from the following file <code>include/control/controller.h</code></p>"},{"location":"naomi/controller_8h_source/","title":"File controller.h","text":"<p>File List &gt; control &gt; controller.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/4/2024.\n//\n\n#ifndef SPACECRAFT_CONTROLLER_H\n#define SPACECRAFT_CONTROLLER_H\n#include \"naomi.h\"\n#include \"spacecraft/spacecraft_state.h\"\n\nnamespace naomi::control\n{\nusing namespace naomi;\n\nclass control_input\n{\n  arma::vec3 m_position_control_input;\n  quaternion_type m_attitude_control_input;\n\npublic:\n  control_input(const arma::vec3&amp; position_control_input, const quaternion_type&amp; attitude_control_input):\n    m_position_control_input(position_control_input), m_attitude_control_input(attitude_control_input){}\n\n};\n\nclass controller\n{\npublic:\n  virtual ~controller() = default;\n  virtual control_input get_control_input(const vector_type&amp; state, const vector_type&amp; attitude,\n                                             double t) = 0;\n  virtual void initialize(const vector_type&amp; state, const vector_type&amp; attitude, double t) = 0;\n\n  virtual vector_type get_desired_state(const vector_type&amp; state, const vector_type&amp; attitude, double t) = 0;\n\n};\n\n// class spacecraft_subsystem: simulation_component&lt;spacecraft_state&gt;\n// {\n//   std::shared_ptr&lt;controller&gt; m_controller = nullptr;\n//   std::shared_ptr&lt;attitude::additional_state_provider&gt; m_state_provider = nullptr;\n//\n// public:\n//   ~spacecraft_subsystem() override = default;\n// };\n\n}\n#endif //SPACECRAFT_CONTROLLER_H\n</code></pre>"},{"location":"naomi/pid__controller_8h/","title":"File pid_controller.h","text":"<p>FileList &gt; control &gt; pid_controller.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"controller.h\"</code></li> <li><code>#include \"frames/transforms.h\"</code></li> </ul>"},{"location":"naomi/pid__controller_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace control"},{"location":"naomi/pid__controller_8h/#classes","title":"Classes","text":"Type Name class nadir_pointing_pid_controller class pid_controller <p>The documentation for this class was generated from the following file <code>include/control/pid_controller.h</code></p>"},{"location":"naomi/pid__controller_8h_source/","title":"File pid_controller.h","text":"<p>File List &gt; control &gt; pid_controller.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/20/2024.\n//\n\n#ifndef LQR_CONTROLLER_H\n#define LQR_CONTROLLER_H\n#include &lt;utility&gt;\n\n#include \"controller.h\"\n#include \"frames/transforms.h\"\n\nnamespace naomi::control\n{\nclass pid_controller: public controller\n{\n  arma::mat m_kp;\n  arma::mat m_ki;\n  arma::mat m_kd;\n  vector_type m_e;\n  double m_t = 0;\n  vector_type m_integral;\n\npublic:\n  pid_controller(arma::mat Kp, arma::mat Ki, arma::mat Kd):\n    m_kp(std::move(Kp)), m_ki(std::move(Ki)), m_kd(std::move(Kd)){}\n\n  ~pid_controller() override = default;\n\n  void initialize(const vector_type&amp; state, const vector_type&amp; attitude, const double t) override\n  {\n    const auto desired = get_desired_state(state, attitude, t);\n    m_t = t;\n    m_e = desired - state;\n  }\n\n  control_input get_control_input(const vector_type&amp; state, const vector_type&amp; attitude, const double t) override\n  {\n    const auto desired = get_desired_state(state, attitude, t);\n    const auto e = desired - state;\n    const auto P = m_kp * e;\n    m_integral = m_integral * m_ki * e * (t - m_t);\n    const auto D = m_kd*(e - m_e)/(t - m_t);\n    vector_type control_inp = P + m_integral + D;\n    m_e = e;\n    m_t = t;\n    return {control_inp, attitude};\n  }\n};\n\nclass nadir_pointing_pid_controller final : public pid_controller\n{\npublic:\n  nadir_pointing_pid_controller(const arma::mat&amp; Kp,\n                                const arma::mat&amp; Ki,\n                                const arma::mat&amp; Kd)\n      : pid_controller(Kp, Ki, Kd)\n  {\n  }\n\n  vector_type get_desired_state(const vector_type&amp; state, const vector_type&amp; attitude, double t) override\n  {\n    const auto trans = eci2ric(state);\n    const arma::vec3 desired_vec_ric = {0, 0, 1};\n    const arma::vec3 desired_vec_eci = trans.t() * desired_vec_ric;\n    return {boost::math::double_constants::pi, desired_vec_eci[0], desired_vec_eci[1], desired_vec_eci[2]};\n  }\n};\n}\n\n#endif //LQR_CONTROLLER_H\n</code></pre>"},{"location":"naomi/dir_05b2e84f333249ba12020e133ece87db/","title":"Dir include/forces","text":"<p>FileList &gt; forces</p>"},{"location":"naomi/dir_05b2e84f333249ba12020e133ece87db/#files","title":"Files","text":"Type Name file force_model.h file two_body_force_model.h file two_body_rot_force_model.h <p>The documentation for this class was generated from the following file <code>include/forces/</code></p>"},{"location":"naomi/force__model_8h/","title":"File force_model.h","text":"<p>FileList &gt; forces &gt; force_model.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"naomi.h\"</code></li> </ul>"},{"location":"naomi/force__model_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace forces"},{"location":"naomi/force__model_8h/#classes","title":"Classes","text":"Type Name class equations_of_motion class force_model <p>The documentation for this class was generated from the following file <code>include/forces/force_model.h</code></p>"},{"location":"naomi/force__model_8h_source/","title":"File force_model.h","text":"<p>File List &gt; forces &gt; force_model.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/4/2024.\n//\n\n#ifndef FORCE_MODEL_H\n#define FORCE_MODEL_H\n\n#include \"naomi.h\"\n\nnamespace naomi::forces\n{\nclass force_model\n{\n\npublic:\n  virtual void operator()( const vector_type&amp; x , vector_type&amp; dxdt, double t) const = 0;\n  virtual ~force_model() = default;\n\n};\n\nclass equations_of_motion\n{\n\npublic:\n  [[nodiscard]] virtual vector_type get_derivative( const vector_type&amp; state, double t) const = 0;\n  virtual ~equations_of_motion() = default;\n\n};\n\n}\n\n#endif //FORCE_MODEL_H\n</code></pre>"},{"location":"naomi/two__body__force__model_8h/","title":"File two_body_force_model.h","text":"<p>FileList &gt; forces &gt; two_body_force_model.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"bodies/celestial_body.h\"</code></li> <li><code>#include \"force_model.h\"</code></li> </ul>"},{"location":"naomi/two__body__force__model_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace forces"},{"location":"naomi/two__body__force__model_8h/#classes","title":"Classes","text":"Type Name class two_body_force_model class two_body_force_model_eoms <p>The documentation for this class was generated from the following file <code>include/forces/two_body_force_model.h</code></p>"},{"location":"naomi/two__body__force__model_8h_source/","title":"File two_body_force_model.h","text":"<p>File List &gt; forces &gt; two_body_force_model.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/4/2024.\n//\n\n#ifndef TWO_BODY_FORCE_MODEL_H\n#define TWO_BODY_FORCE_MODEL_H\n#include \"bodies/celestial_body.h\"\n#include \"force_model.h\"\n\nnamespace naomi::forces\n{\nusing namespace bodies;\nclass two_body_force_model : public force_model\n{\n  std::shared_ptr&lt;celestial_body&gt; m_central_body;\n\n\npublic:\n  explicit two_body_force_model(\n      const std::shared_ptr&lt;celestial_body&gt;&amp; central_body)\n      : m_central_body(central_body)\n  {\n  }\n\n  ~two_body_force_model() override = default;\n\n  void operator()(const vector_type&amp; x,\n                  vector_type&amp; dxdt,\n                  double t) const override\n  {\n    arma::vec3 pos = x.subvec(0, 2);\n    const arma::vec3 vel = x.subvec(3, 5);\n    const arma::vec3 rddot = -1.0 * m_central_body-&gt;get_potential_partial(pos);\n    dxdt(arma::span(0, 2)) = vel;\n    dxdt(arma::span(3, 5)) = rddot;\n    dxdt(arma::span(6, 8)) = {0, 0, 0};\n  }\n};\n\nclass two_body_force_model_eoms : public equations_of_motion\n{\n  std::shared_ptr&lt;celestial_body&gt; m_central_body;\n\n\npublic:\n  explicit two_body_force_model_eoms(\n      const std::shared_ptr&lt;celestial_body&gt;&amp; central_body)\n      : m_central_body(central_body)\n  {\n  }\n\n  ~two_body_force_model_eoms() override = default;\n\n  [[nodiscard]] vector_type get_derivative(const vector_type&amp; state, double t) const override\n  {\n    arma::vec3 pos = state.subvec(0, 2);\n    const arma::vec3 vel = state.subvec(3, 5);\n    const arma::vec3 rddot = -1.0 * m_central_body-&gt;get_potential_partial(pos);\n    auto dxdt = arma::vec(9);\n    dxdt(arma::span(0, 2)) = vel;\n    dxdt(arma::span(3, 5)) = rddot;\n    dxdt(arma::span(6, 8)) = {0, 0, 0};\n    return dxdt;\n  }\n};\n}\n\n#endif //TWO_BODY_FORCE_MODEL_H\n</code></pre>"},{"location":"naomi/two__body__rot__force__model_8h/","title":"File two_body_rot_force_model.h","text":"<p>FileList &gt; forces &gt; two_body_rot_force_model.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"bodies/celestial_body.h\"</code></li> <li><code>#include \"force_model.h\"</code></li> </ul>"},{"location":"naomi/two__body__rot__force__model_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace forces"},{"location":"naomi/two__body__rot__force__model_8h/#classes","title":"Classes","text":"Type Name class two_body_rot_force_model <p>The documentation for this class was generated from the following file <code>include/forces/two_body_rot_force_model.h</code></p>"},{"location":"naomi/two__body__rot__force__model_8h_source/","title":"File two_body_rot_force_model.h","text":"<p>File List &gt; forces &gt; two_body_rot_force_model.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/9/2024.\n//\n\n#ifndef TWO_BODY_ROT_FORCE_MODEL_H\n#define TWO_BODY_ROT_FORCE_MODEL_H\n#include \"bodies/celestial_body.h\"\n#include \"force_model.h\"\n\nnamespace naomi::forces\n{\nusing namespace bodies;\nclass two_body_rot_force_model : public force_model\n{\n  std::shared_ptr&lt;celestial_body&gt; m_central_body;\n\n\npublic:\n  explicit two_body_rot_force_model(\n      const std::shared_ptr&lt;celestial_body&gt;&amp; central_body)\n      : m_central_body(central_body)\n  {\n  }\n\n  ~two_body_rot_force_model() override = default;\n\n  void operator()(const vector_type&amp; x,\n                  vector_type&amp; dxdt,\n                  double t) const override\n  {\n    arma::vec3 pos = x.subvec(0, 2);\n    arma::vec3 vel = x.subvec(3, 5);\n    arma::vec3 rddot = -1.0 * m_central_body-&gt;get_potential_partial(pos);\n    dxdt(arma::span(0, 2)) = vel;\n    dxdt(arma::span(3, 5)) = rddot;\n  }\n};\n}\n#endif //TWO_BODY_ROT_FORCE_MODEL_H\n</code></pre>"},{"location":"naomi/dir_ac19973500a4fd01fbc243659a6fd273/","title":"Dir include/frames","text":"<p>FileList &gt; frames</p>"},{"location":"naomi/dir_ac19973500a4fd01fbc243659a6fd273/#files","title":"Files","text":"Type Name file frame.h file transforms.h <p>The documentation for this class was generated from the following file <code>include/frames/</code></p>"},{"location":"naomi/frame_8h/","title":"File frame.h","text":"<p>FileList &gt; frames &gt; frame.h</p> <p>Go to the source code of this file</p>"},{"location":"naomi/frame_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace frames"},{"location":"naomi/frame_8h/#classes","title":"Classes","text":"Type Name class frame <p>The documentation for this class was generated from the following file <code>include/frames/frame.h</code></p>"},{"location":"naomi/frame_8h_source/","title":"File frame.h","text":"<p>File List &gt; frames &gt; frame.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 7/24/2024.\n//\n\n#ifndef FRAME_H\n#define FRAME_H\n\nnamespace naomi::frames\n{\nclass frame\n{\npublic:\n  virtual vector_type get_transform_to(const frame&amp; other) = 0;\n};\n}\n#endif //FRAME_H\n</code></pre>"},{"location":"naomi/transforms_8h/","title":"File transforms.h","text":"<p>FileList &gt; frames &gt; transforms.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;armadillo&gt;</code></li> <li><code>#include \"naomi.h\"</code></li> </ul>"},{"location":"naomi/transforms_8h/#public-functions","title":"Public Functions","text":"Type Name arma::mat33 eci2ric (arma::vec3 r, arma::vec3 v)  arma::mat33 eci2ric (const vector_type &amp; sv)"},{"location":"naomi/transforms_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"naomi/transforms_8h/#function-eci2ric","title":"function eci2ric","text":"<pre><code>inline arma::mat33 eci2ric (\n    arma::vec3 r,\n    arma::vec3 v\n) \n</code></pre>"},{"location":"naomi/transforms_8h/#function-eci2ric_1","title":"function eci2ric","text":"<pre><code>inline arma::mat33 eci2ric (\n    const vector_type &amp; sv\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/frames/transforms.h</code></p>"},{"location":"naomi/transforms_8h_source/","title":"File transforms.h","text":"<p>File List &gt; frames &gt; transforms.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 6/23/2024.\n//\n\n#ifndef TRANSFORMS_H\n#define TRANSFORMS_H\n\n#include &lt;armadillo&gt;\n#include \"naomi.h\"\n\nusing namespace naomi;\n\ninline arma::mat33 eci2ric(arma::vec3 r, arma::vec3 v)\n{\n  auto rn = normalise(r);\n  auto vn = normalise(v);\n  auto h = cross(r, v);\n  auto c = normalise(h);\n  auto i = normalise(cross(c, rn));\n  return arma::join_rows(rn, i, c);\n}\n\ninline arma::mat33 eci2ric(const vector_type&amp; sv)\n{\n  return eci2ric(sv(arma::span(0, 2)), sv(arma::span(3, 5)));\n}\n\n#endif //TRANSFORMS_H\n</code></pre>"},{"location":"naomi/dir_dc924870d46bc59197fc3bc2d75e5d7e/","title":"Dir include/integrators","text":"<p>FileList &gt; include &gt; integrators</p>"},{"location":"naomi/dir_dc924870d46bc59197fc3bc2d75e5d7e/#files","title":"Files","text":"Type Name file integrator.h <p>The documentation for this class was generated from the following file <code>include/integrators/</code></p>"},{"location":"naomi/integrator_8h/","title":"File integrator.h","text":"<p>FileList &gt; include &gt; integrators &gt; integrator.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;naomi.h&gt;</code></li> <li><code>#include &lt;systems/two_body.h&gt;</code></li> <li><code>#include \"propagators/event_detector.h\"</code></li> <li><code>#include \"forces/force_model.h\"</code></li> </ul>"},{"location":"naomi/integrator_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace numeric"},{"location":"naomi/integrator_8h/#classes","title":"Classes","text":"Type Name class integrator &lt;class Stepper&gt; <p>The documentation for this class was generated from the following file <code>include/integrators/integrator.h</code></p>"},{"location":"naomi/integrator_8h_source/","title":"File integrator.h","text":"<p>File List &gt; include &gt; integrators &gt; integrator.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 6/10/2024.\n//\n\n#ifndef INTEGRATOR_H\n#define INTEGRATOR_H\n\n#include &lt;naomi.h&gt;\n#include &lt;systems/two_body.h&gt;\n\n#include \"propagators/event_detector.h\"\n#include \"forces/force_model.h\"\n\nnamespace naomi::numeric\n{\nusing namespace events;\nusing namespace forces;\n\ntypedef std::function&lt;void(const vector_type&amp;, vector_type&amp;, double)&gt; system_t;\n\ntemplate&lt; class Stepper&gt;\nclass integrator\n{\npublic:\n  integrator(const integrator&amp; other)\n      : m_stepper(other.m_stepper)\n  {\n  }\n  integrator(integrator&amp;&amp; other) noexcept\n      : m_stepper(std::move(other.m_stepper))\n  {\n  }\n  integrator&amp; operator=(const integrator&amp; other)\n  {\n    if (this == &amp;other)\n      return *this;\n    m_stepper = other.m_stepper;\n    return *this;\n  }\n  integrator&amp; operator=(integrator&amp;&amp; other) noexcept\n  {\n    if (this == &amp;other)\n      return *this;\n    m_stepper = std::move(other.m_stepper);\n    return *this;\n  }\n\nprivate:\n  Stepper m_stepper;\n\npublic:\n  ~ integrator() = default;\n  integrator() = default;\n\n  std::pair&lt;double, vector_type&gt; find_event_time(const system_t&amp; system, double start_time, double end_time, std::shared_ptr&lt;event_detector&gt; e, state_and_time_type state, double step_size)\n  {\n    auto stepper = make_dense_output(1.0e-6, 1.0e-6, Stepper());\n    vector_type s = state.first;\n    stepper.initialize(s, start_time, end_time-start_time);\n    stepper.do_step(system);\n    double mid_time;\n    vector_type next_state = s;\n    while(std::abs(end_time - start_time) &gt; 1e-6) {\n      mid_time = 0.5 * (start_time + end_time);  // get the mid point time\n      stepper.calc_state(mid_time, next_state); // obtain the corresponding state\n      state_and_time_type prev = {s, start_time};\n      state_and_time_type curr = {next_state, mid_time};\n      if ((*e)(prev, curr))\n        end_time = mid_time;  // condition changer lies before midpoint\n      else {\n        start_time = mid_time;  // condition changer lies after midpoint\n        s = next_state;\n      }\n    }\n    // we found the interval of size eps, take it's midpoint as final guess\n    mid_time = 0.5 * (start_time + end_time);\n    stepper.calc_state(mid_time, s);\n    return {mid_time, s};\n  }\n\n  double integrate(const system_t&amp; system, vector_type&amp; state, double start_time, double end_time, double step_size)\n  {\n    integrate_adaptive(make_controlled( 1.0e-6 , 1.0e-6, m_stepper), system, state, start_time, end_time, step_size);\n    // integrate_const(m_stepper, system, state, start_time, end_time, step_size);\n    return end_time;\n  }\n};\n}\n\n\n#endif //INTEGRATOR_H\n</code></pre>"},{"location":"naomi/dir_080a7f4d2599f19d45508189cb33581e/","title":"Dir include/maneuvers","text":"<p>FileList &gt; include &gt; maneuvers</p>"},{"location":"naomi/dir_080a7f4d2599f19d45508189cb33581e/#files","title":"Files","text":"Type Name file hohmann_transfer.h file maneuver.h file maneuver_plan.h <p>The documentation for this class was generated from the following file <code>include/maneuvers/</code></p>"},{"location":"naomi/hohmann__transfer_8h/","title":"File hohmann_transfer.h","text":"<p>FileList &gt; include &gt; maneuvers &gt; hohmann_transfer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;fmt/core.h&gt;</code></li> <li><code>#include \"constants.h\"</code></li> <li><code>#include \"maneuver.h\"</code></li> <li><code>#include \"maneuver_plan.h\"</code></li> <li><code>#include \"orbits/keplerian.h\"</code></li> <li><code>#include \"orbits/orbits.h\"</code></li> </ul>"},{"location":"naomi/hohmann__transfer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace maneuvers"},{"location":"naomi/hohmann__transfer_8h/#classes","title":"Classes","text":"Type Name class bielliptic_hohmann_transfer class hohmann_transfer A class to compute the optimal burns for a Hohmann Transfer using equations as described by orbital-mechanics.space . <p>The documentation for this class was generated from the following file <code>include/maneuvers/hohmann_transfer.h</code></p>"},{"location":"naomi/hohmann__transfer_8h_source/","title":"File hohmann_transfer.h","text":"<p>File List &gt; include &gt; maneuvers &gt; hohmann_transfer.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 6/19/2024.\n//\n\n#ifndef HOHMANN_TRANSFER_H\n#define HOHMANN_TRANSFER_H\n#include &lt;utility&gt;\n\n#include &lt;fmt/core.h&gt;\n\n#include \"constants.h\"\n#include \"maneuver.h\"\n#include \"maneuver_plan.h\"\n#include \"orbits/keplerian.h\"\n#include \"orbits/orbits.h\"\n\nnamespace naomi::maneuvers\n{\nusing namespace orbits;\n\nclass hohmann_transfer\n{\n  vector_type m_initial_state;\n  double m_target_radius;\n  std::vector&lt;double&gt; m_dvs;\n  double m_transit_time;\n\npublic:\n  hohmann_transfer(vector_type initial_state, double target_radius ):\n    m_initial_state(std::move(initial_state)), m_target_radius(target_radius)\n  {\n    auto r = m_initial_state(arma::span(0, 2));\n    auto v = m_initial_state(arma::span(3, 5));\n    arma::vec3 h_vec = cross(r, v);\n    arma::vec3 ih = normalise(h_vec);\n    arma::vec3 rn = normalise(r);\n    arma::vec3 vn = normalise(v);\n    arma::vec3 e_vec = cross(v, h_vec) / constants::EARTH_MU - rn;\n\n    if (const double e = norm(e_vec); e &gt; 1e-6) {\n      throw std::runtime_error(\"WARNING: Initial orbit is not near circular\");\n    }\n\n    auto initial_radius = norm(r);\n    double h_t = sqrt(2*constants::EARTH_MU*((initial_radius * m_target_radius)/(initial_radius + m_target_radius)));\n    double v_tp = h_t / initial_radius;\n    double v_ta = h_t / m_target_radius;\n    double v_i = sqrt(constants::EARTH_MU / initial_radius);\n    double v_f = sqrt(constants::EARTH_MU / m_target_radius);\n    double sma_t = (initial_radius + m_target_radius) / 2;\n    m_transit_time = boost::math::double_constants::pi * sqrt(pow(sma_t, 3)/ constants::EARTH_MU);\n    m_dvs = {\n      v_tp - v_i,\n      v_f - v_ta\n    };\n  }\n\n  hohmann_transfer(const double initial_radius, const double target_radius):\n    hohmann_transfer(\n            arma::Col(keplerian_orbit(initial_radius).to_cartesian()), target_radius)\n  {\n  }\n\n  auto get_maneuver_plan(double start_time = 0) -&gt; std::shared_ptr&lt;maneuver_plan&gt;\n  {\n    const double initial_radius = norm(m_initial_state(arma::span(0, 2)));\n    std::shared_ptr&lt;event_detector&gt; start_detector = std::make_shared&lt;time_detector&gt;(start_time);\n    if (m_target_radius &gt; initial_radius) {\n      std::shared_ptr&lt;event_detector&gt; apoapsis_detector = std::make_shared&lt;apside_detector&gt;(apside_detector(DECREASING));\n      maneuver first(m_dvs.at(0), constants::PLUS_J, start_detector);\n      maneuver second(m_dvs.at(1),  constants::PLUS_J, apoapsis_detector);\n      return std::make_shared&lt;maneuver_plan&gt;(maneuver_plan({first, second}));\n    }\n    std::shared_ptr&lt;event_detector&gt; periapsis_detector = std::make_shared&lt;apside_detector&gt;(apside_detector(INCREASING));\n    maneuver first(m_dvs.at(0), constants::PLUS_J, start_detector);\n    maneuver second(m_dvs.at(1),  constants::PLUS_J, periapsis_detector);\n    return std::make_shared&lt;maneuver_plan&gt;(maneuver_plan({first, second}));\n  }\n\n  [[nodiscard]] auto get_total_dv() const -&gt; double\n  {\n    return std::accumulate(m_dvs.begin(), m_dvs.end(), 0.0,\n      [](auto x, auto y) {return x + std::abs(y);});\n  }\n\n  [[nodiscard]] auto get_dvs() const -&gt; std::vector&lt;double&gt;\n  {\n    return m_dvs;\n  }\n\n  [[nodiscard]] auto get_transit_time() const -&gt; double\n  {\n    return m_transit_time;\n  }\n};\n\nclass bielliptic_hohmann_transfer\n{\n  double m_initial_sma;\n  double m_target_sma;\n  double m_transfer_magnitude;\n  double m_transit_time = 0;\n  std::vector&lt;double&gt; m_dvs;\n\npublic:\n  bielliptic_hohmann_transfer(vector_type&amp; initial_state, double target_sma, double transfer_magnitude)\n  {\n    auto r = initial_state(arma::span(0, 2));\n    auto v = initial_state(arma::span(3, 5));\n    const arma::vec3 h_vec = cross(r, v);\n    const arma::vec3 ih = normalise(h_vec);\n    const arma::vec3 rn = normalise(r);\n    const arma::vec3 vn = normalise(v);\n    const arma::vec3 e_vec = cross(v, h_vec) / constants::EARTH_MU - rn;\n\n    if (const double e = norm(e_vec); e &gt; 1e-6) {\n      throw std::runtime_error(\"Initial orbit is not near circular\");\n    }\n    m_initial_sma = norm(initial_state(arma::span(0, 2)));\n    m_target_sma = target_sma;\n    m_transfer_magnitude = transfer_magnitude;\n    const double transfer_sma1 =\n        (m_target_sma * m_transfer_magnitude + m_initial_sma) / 2;\n    const double v_pt =\n        sqrt(constants::EARTH_MU * ((2 / m_initial_sma) - (1 / transfer_sma1)));\n    const double r_a1 = transfer_sma1 * 2 - m_initial_sma;\n    const double transfer_sma2 =\n        (2 * transfer_sma1 + (m_target_sma - m_initial_sma)) / 2;\n    const double v_a1 =\n        sqrt(constants::EARTH_MU * ((2 / r_a1) - (1 / transfer_sma1)));\n    const double v_a2 =\n        sqrt(constants::EARTH_MU * ((2 / r_a1) - (1 / transfer_sma2)));\n    const double v_p2 =\n        sqrt(constants::EARTH_MU * (2 / m_target_sma - 1 / transfer_sma2));\n    const double v_t = sqrt(constants::EARTH_MU * (2/m_target_sma - 1/m_target_sma));\n    const double t1_time = boost::math::double_constants::pi * sqrt(pow(transfer_sma1, 3)/ constants::EARTH_MU);\n    const double t2_time = boost::math::double_constants::pi * sqrt(pow(transfer_sma2, 3)/ constants::EARTH_MU);\n    m_transit_time = t1_time + t2_time;\n    m_dvs = {\n      v_pt - sqrt(constants::EARTH_MU / m_initial_sma),\n      v_a2 - v_a1,\n      v_t - v_p2\n    };\n  }\n\n  bielliptic_hohmann_transfer(const double initial_sma,\n                              const double target_sma,\n                              const double transfer_radius):\n    m_initial_sma(initial_sma), m_target_sma(target_sma), m_transfer_magnitude(transfer_radius)\n  {\n    const double transfer_sma1 = (transfer_radius + m_initial_sma) / 2.0;\n    const double v_initial = vis_viva(m_initial_sma, m_initial_sma);\n    const double v_pt = vis_viva(m_initial_sma, transfer_sma1);\n    const double r_a1 = transfer_sma1 * 2.0 - m_initial_sma;\n    const double transfer_sma2 = (r_a1 + m_target_sma) / 2.0;\n    const double v_a1 = vis_viva(r_a1, transfer_sma1);\n    const double v_a2 = vis_viva(r_a1, transfer_sma2);\n\n    const double v_p2 = vis_viva(m_target_sma, transfer_sma2);\n    const double v_t = vis_viva(m_target_sma, m_target_sma);\n\n    m_dvs = {\n      v_pt - v_initial,\n      v_a2 - v_a1,\n      v_t - v_p2\n    };\n  }\n\n  [[nodiscard]] auto get_maneuver_plan(double start_time = 0.0) const -&gt; std::shared_ptr&lt;maneuver_plan&gt;\n  {\n    std::shared_ptr&lt;event_detector&gt; start_detector = std::make_shared&lt;time_detector&gt;(start_time);\n    std::shared_ptr&lt;event_detector&gt; periapsis_detector = std::make_shared&lt;apside_detector&gt;(apside_detector(DECREASING));\n    std::shared_ptr&lt;event_detector&gt; apoapsis_detector = std::make_shared&lt;apside_detector&gt;(apside_detector(DECREASING));\n    maneuver first(m_dvs.at(0), constants::PLUS_J, start_detector);\n    maneuver second(m_dvs.at(1),  constants::PLUS_J, apoapsis_detector);\n    maneuver third(m_dvs.at(2), constants::PLUS_J, periapsis_detector);\n\n    return std::make_shared&lt;maneuver_plan&gt;(maneuver_plan({first, second, third}));\n  }\n\n  [[nodiscard]] auto get_total_dv() const -&gt; double\n  {\n    return std::accumulate(m_dvs.begin(), m_dvs.end(), 0.0,\n      [](auto x, auto y) {return x + std::abs(y);});\n  }\n\n  [[nodiscard]] auto get_dvs() const -&gt; std::vector&lt;double&gt;\n  {\n    return m_dvs;\n  }\n\n  [[nodiscard]] auto get_transit_time() const -&gt; double\n  {\n    return m_transit_time;\n  }\n};\n}\n\n#endif //HOHMANN_TRANSFER_H\n</code></pre>"},{"location":"naomi/maneuver_8h/","title":"File maneuver.h","text":"<p>FileList &gt; include &gt; maneuvers &gt; maneuver.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;armadillo&gt;</code></li> <li><code>#include \"frames/transforms.h\"</code></li> <li><code>#include \"propagators/event_detector.h\"</code></li> <li><code>#include \"spacecraft/spacecraft_state.h\"</code></li> </ul>"},{"location":"naomi/maneuver_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace maneuvers"},{"location":"naomi/maneuver_8h/#classes","title":"Classes","text":"Type Name class maneuver <p>The documentation for this class was generated from the following file <code>include/maneuvers/maneuver.h</code></p>"},{"location":"naomi/maneuver_8h_source/","title":"File maneuver.h","text":"<p>File List &gt; include &gt; maneuvers &gt; maneuver.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 6/19/2024.\n//\n\n#ifndef MANEUVER_H\n#define MANEUVER_H\n#include &lt;armadillo&gt;\n\n#include \"frames/transforms.h\"\n#include \"propagators/event_detector.h\"\n#include \"spacecraft/spacecraft_state.h\"\n\nnamespace naomi\n{\nclass spacecraft_state;\n}\nnamespace naomi::maneuvers\n{\nusing namespace events;\n\nclass maneuver\n{\n  double m_delta_v;\n  arma::vec3 m_direction;  // RIC Frame\n  std::shared_ptr&lt;event_detector&gt; m_trigger;\n\npublic:\n\n  maneuver(const double dv, const arma::vec3&amp; dir, std::shared_ptr&lt;event_detector&gt;&amp; rt): m_delta_v(dv), m_direction(dir), m_trigger(rt){}\n\n  friend auto operator&lt;&lt;(std::ostream &amp;output, const maneuver &amp;maneuver ) -&gt; std::ostream &amp; {\n    output &lt;&lt; \"delta-v: \" &lt;&lt; maneuver.m_delta_v &lt;&lt; \"\\n\";\n    output &lt;&lt; \"direction: [\" &lt;&lt; maneuver.m_direction[0] &lt;&lt; \", \" &lt;&lt; maneuver.m_direction[1] &lt;&lt; \", \" &lt;&lt; maneuver.m_direction[2] &lt;&lt; \"]\\n\";\n    return output;\n  }\n\n  [[nodiscard]] auto get_delta_v() const -&gt; arma::vec3\n  {\n    return m_delta_v * m_direction;\n  }\n\n  [[nodiscard]] auto get_delta_v_mag() const -&gt; double\n  {\n    return m_delta_v;\n  }\n\n  [[nodiscard]] auto get_direction() const -&gt; arma::vec3\n  {\n    return m_direction;\n  }\n\n  [[nodiscard]] vector_type get_control_input(double dt, spacecraft_state&amp; state) const\n  {\n    const auto dv = get_delta_v();\n    auto curr_pva = state.get_state_provider()-&gt;get_pv_coordinates().to_vec();\n    vector_type curr_pv = curr_pva(arma::span(0, 5));\n    const auto eci_control = eci2ric(curr_pv(arma::span(0, 5))) * dv;\n    vector_type control_inp(9);\n    control_inp(arma::span(3, 5)) = eci_control;\n\n    return control_inp;\n  }\n\n  auto get_trigger() const -&gt; std::shared_ptr&lt;event_detector&gt;\n  {\n    return m_trigger;\n  }\n};\n}\n\n\n\n#endif //MANEUVER_H\n</code></pre>"},{"location":"naomi/maneuver__plan_8h/","title":"File maneuver_plan.h","text":"<p>FileList &gt; include &gt; maneuvers &gt; maneuver_plan.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"maneuver.h\"</code></li> </ul>"},{"location":"naomi/maneuver__plan_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace maneuvers"},{"location":"naomi/maneuver__plan_8h/#classes","title":"Classes","text":"Type Name class maneuver_plan class no_such_maneuver_exception <p>The documentation for this class was generated from the following file <code>include/maneuvers/maneuver_plan.h</code></p>"},{"location":"naomi/maneuver__plan_8h_source/","title":"File maneuver_plan.h","text":"<p>File List &gt; include &gt; maneuvers &gt; maneuver_plan.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/4/2024.\n//\n\n#ifndef MANEUVER_PLAN_H\n#define MANEUVER_PLAN_H\n#include &lt;vector&gt;\n\n#include \"maneuver.h\"\n\nnamespace naomi\n{\nclass spacecraft;\nnamespace maneuvers\n{\nclass no_such_maneuver_exception : public std::exception {\npublic:\n  const char * what() {\n    return std::string(\"No such maneuver exists.\").c_str();\n  }\n};\n\nclass maneuver_plan : public event_detector\n{\n  std::vector&lt;maneuver&gt; m_maneuvers;\n  std::vector&lt;maneuver&gt; _active_maneuvers;\n  std::size_t stage = 0;\n  double m_start_time = 0.0;\n\npublic:\n  explicit maneuver_plan(const std::vector&lt;maneuver&gt;&amp; maneuvers)\n      : event_detector(ALL)\n      , m_maneuvers(maneuvers)\n  {\n  }\n\n  maneuver_plan(const maneuver_plan&amp; other)\n      : event_detector(ALL)\n      , m_maneuvers(other.m_maneuvers)\n      , m_start_time(other.m_start_time)\n  {\n    stage = other.stage;\n  }\n\n  maneuver_plan(maneuver_plan&amp;&amp; other) noexcept\n      : event_detector(ALL)\n      , m_maneuvers(std::move(other.m_maneuvers))\n      , stage(other.stage)\n      , m_start_time(other.m_start_time)\n  {\n  }\n\n  maneuver_plan&amp; operator=(const maneuver_plan&amp; other)\n  {\n    if (this == &amp;other)\n      return *this;\n    m_maneuvers = other.m_maneuvers;\n    stage = other.stage;\n    m_start_time = other.m_start_time;\n    return *this;\n  }\n\n  maneuver_plan&amp; operator=(maneuver_plan&amp;&amp; other) noexcept\n  {\n    if (this == &amp;other)\n      return *this;\n    m_maneuvers = std::move(other.m_maneuvers);\n    stage = other.stage;\n    m_start_time = other.m_start_time;\n    return *this;\n  }\n\n  auto get_maneuvers() -&gt; std::vector&lt;maneuver&gt; { return m_maneuvers; }\n\n  [[nodiscard]] auto get_total_delta_v() const -&gt; double\n  {\n    double total = 0;\n    for (const auto&amp; man : m_maneuvers) {\n      total += man.get_delta_v_mag();\n    }\n    return total;\n  }\n\n  auto pop_stage() -&gt; maneuver&amp; { return m_maneuvers.at(stage++); }\n\n  void execute_maneuver(const std::shared_ptr&lt;spacecraft&gt;&amp; sc);\n\n  friend auto operator&lt;&lt;(std::ostream&amp; output, const maneuver_plan&amp; mp)\n      -&gt; std::ostream&amp;\n  {\n    for (std::size_t i = 0; i &lt; mp.m_maneuvers.size(); i++) {\n      output &lt;&lt; \"Manuever \" &lt;&lt; i &lt;&lt; \": \\n\";\n      output &lt;&lt; mp.m_maneuvers[i] &lt;&lt; \"\\n\\n\";\n    }\n    return output;\n  }\n\n  [[nodiscard]] double g(const state_and_time_type&amp; sv) const override\n  {\n    return m_maneuvers.at(stage).get_trigger()-&gt;g(sv);\n  }\n\n  vector_type get_control_input(const double dt, spacecraft_state&amp; state)\n  {\n    vector_type control_inp(9);\n    for (const auto&amp; maneuver: _active_maneuvers) {\n      control_inp += maneuver.get_control_input(dt, state);\n    }\n    _active_maneuvers.clear();\n    return control_inp;\n  }\n\n  void handle_event(const std::shared_ptr&lt;spacecraft&gt;&amp; sc, double t) override\n  {\n    _active_maneuvers.push_back(m_maneuvers.at(stage++));\n    if (stage &gt;= m_maneuvers.size()) m_is_active = false;\n  }\n};\n}\n}\n\n#endif //MANEUVER_PLAN_H\n</code></pre>"},{"location":"naomi/dir_fba38f648377aa56ae5d69782adf9e53/","title":"Dir include/math","text":"<p>FileList &gt; include &gt; math</p>"},{"location":"naomi/dir_fba38f648377aa56ae5d69782adf9e53/#files","title":"Files","text":"Type Name file quaternion.h file transport_theorem.h file vector_utils.h file volume_integrals.h <p>The documentation for this class was generated from the following file <code>include/math/</code></p>"},{"location":"naomi/quaternion_8h/","title":"File quaternion.h","text":"<p>FileList &gt; include &gt; math &gt; quaternion.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;armadillo&gt;</code></li> </ul>"},{"location":"naomi/quaternion_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace math namespace quaternion <p>The documentation for this class was generated from the following file <code>include/math/quaternion.h</code></p>"},{"location":"naomi/quaternion_8h_source/","title":"File quaternion.h","text":"<p>File List &gt; include &gt; math &gt; quaternion.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/21/2024.\n//\n\n#ifndef QUATERNION_H\n#define QUATERNION_H\n\n#include &lt;armadillo&gt;\n\nnamespace naomi::math::quaternion\n{\n\ntypedef arma::vec4 quaternion_type;\n\ninline quaternion_type product(const quaternion_type&amp; q1, const quaternion_type&amp; q2)\n{\n  const auto p0 = q1[0]*q2[0] - q1[1]*q2[1] - q1[2]*q2[2] - q1[3]*q2[3];\n  const auto p1 = q1[0]*q2[1] + q1[1]*q2[0] + q1[2]*q2[3] - q1[3]*q2[2];\n  const auto p2 = q1[0]*q2[2] - q1[1]*q2[3] + q1[2]*q2[0] + q1[3]*q2[1];\n  const auto p3 = q1[0]*q2[3] + q1[1]*q2[2] - q1[2]*q2[1] + q1[3]*q2[0];\n\n  return {p0, p1, p2, p3};\n}\n\ninline quaternion_type conjugate(const quaternion_type&amp; q)\n{\n  return {q[0], -q[1], -q[2], -q[3]};\n}\n\n\n}\n#endif //QUATERNION_H\n</code></pre>"},{"location":"naomi/transport__theorem_8h/","title":"File transport_theorem.h","text":"<p>FileList &gt; include &gt; math &gt; transport_theorem.h</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>include/math/transport_theorem.h</code></p>"},{"location":"naomi/transport__theorem_8h_source/","title":"File transport_theorem.h","text":"<p>File List &gt; include &gt; math &gt; transport_theorem.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/21/2024.\n//\n\n#ifndef TRANSPORT_THEOREM_H\n#define TRANSPORT_THEOREM_H\n\n\n\n#endif //TRANSPORT_THEOREM_H\n</code></pre>"},{"location":"naomi/vector__utils_8h/","title":"File vector_utils.h","text":"<p>FileList &gt; include &gt; math &gt; vector_utils.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;naomi.h&gt;</code></li> </ul>"},{"location":"naomi/vector__utils_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace math <p>The documentation for this class was generated from the following file <code>include/math/vector_utils.h</code></p>"},{"location":"naomi/vector__utils_8h_source/","title":"File vector_utils.h","text":"<p>File List &gt; include &gt; math &gt; vector_utils.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/10/2024.\n//\n\n#ifndef VECTOR_UTILS_H\n#define VECTOR_UTILS_H\n#include &lt;naomi.h&gt;\n\nnamespace naomi::math\n{\ninline arma::mat44 q_skew(const quaternion_type&amp; q)\n{\n  return {\n      {q[0], -q[1], -q[2], -q[3]},\n      {q[1], q[0], -q[3], q[2]},\n      {q[2], q[3], q[0], -q[1]},\n      {q[3], -q[2], q[1], q[0]}\n  };\n}\n\ninline arma::mat44 skew(const arma::vec3&amp; x)\n{\n  return {\n      {0, -x[2], x[1]},\n      {x[2], 0, -x[0]},\n      {-x[1], x[0], 0}\n  };\n}\n}\n#endif //VECTOR_UTILS_H\n</code></pre>"},{"location":"naomi/volume__integrals_8h/","title":"File volume_integrals.h","text":"<p>FileList &gt; include &gt; math &gt; volume_integrals.h</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>include/math/volume_integrals.h</code></p>"},{"location":"naomi/volume__integrals_8h_source/","title":"File volume_integrals.h","text":"<p>File List &gt; include &gt; math &gt; volume_integrals.h</p> <p>Go to the documentation of this file</p> <pre><code>// //\n// // Created by alex on 7/12/2024.\n// //\n//\n// #ifndef VOLUME_INTEGRALS_H\n// #define VOLUME_INTEGRALS_H\n//\n//  /*******************************************************\n//         *                                                      *\n//  *  volInt.c                                            *\n//  *                                                      *\n//  *  This code computes volume integrals needed for      *\n//  *  determining mass properties of polyhedral bodies.   *\n//  *                                                      *\n//  *  For more information, see the accompanying README   *\n//  *  file, and the paper                                 *\n//  *                                                      *\n//  *  Brian Mirtich, \"Fast and Accurate Computation of    *\n//  *  Polyhedral Mass Properties,\" journal of graphics    *\n//  *  tools, volume 1, number 1, 1996.                    *\n//  *                                                      *\n//  *  This source code is public domain, and may be used  *\n//  *  in any way, shape or form, free of charge.          *\n//  *                                                      *\n//  *  Copyright 1995 by Brian Mirtich                     *\n//  *                                                      *\n//  *  mirtich@cs.berkeley.edu                             *\n//  *  http://www.cs.berkeley.edu/~mirtich                 *\n//         *                                                      *\n//  *******************************************************/\n//\n// /*\n//  Revision history\n//\n//  26 Jan 1996 Program creation.\n//\n//   3 Aug 1996 Corrected bug arising when polyhedron density\n//          is not 1.0.  Changes confined to function main().\n//          Thanks to Zoran Popovic for catching this one.\n//\n//  27 May 1997     Corrected sign error in translation of inertia\n//                  product terms to center of mass frame.  Changes\n//          confined to function main().  Thanks to\n//          Chris Hecker.\n// */\n//\n//\n//\n// #include &lt;stdio.h&gt;\n// #include &lt;string.h&gt;\n// #include &lt;math.h&gt;\n//\n// namespace naomi::geometry::test\n// {\n// /*\n//    ============================================================================\n//    constants\n//    ============================================================================\n// */\n//\n// #define MAX_VERTS 100     /* maximum number of polyhedral vertices */\n// #define MAX_FACES 100     /* maximum number of polyhedral faces */\n// #define MAX_POLYGON_SZ 10 /* maximum number of verts per polygonal face */\n//\n// #define X 0\n// #define Y 1\n// #define Z 2\n//\n// /*\n//    ============================================================================\n//    macros\n//    ============================================================================\n// */\n//\n// #define SQR(x) ((x)*(x))\n// #define CUBE(x) ((x)*(x)*(x))\n//\n// /*\n//    ============================================================================\n//    data structures\n//    ============================================================================\n// */\n//\n// typedef struct {\n//   int numVerts;\n//   double norm[3];\n//   double w;\n//   int verts[MAX_POLYGON_SZ];\n//   struct polyhedron *poly;\n// } FACE;\n//\n// typedef struct polyhedron {\n//   int numVerts, numFaces;\n//   double verts[MAX_VERTS][3];\n//   FACE faces[MAX_FACES];\n// } POLYHEDRON;\n//\n// /* CUBE INPUT\n// 8\n//\n// -10  -10 -10\n// +10  -10 -10\n// +10  +10 -10\n// -10  +10 -10\n// -10  -10 +10\n// +10  -10 +10\n// +10  +10 +10\n// -10  +10 +10\n//\n// 6\n//\n// 4    0 3 2 1\n// 4    4 5 6 7\n// 4    0 1 5 4\n// 4    6 2 3 7\n// 4    1 2 6 5\n// 4    0 4 7 3\n//\n// */\n//\n// /*\n//    ============================================================================\n//    globals\n//    ============================================================================\n// */\n//\n// static int A;   /* alpha */\n// static int B;   /* beta */\n// static int C;   /* gamma */\n//\n// /* projection integrals */\n// static double P1, Pa, Pb, Paa, Pab, Pbb, Paaa, Paab, Pabb, Pbbb;\n//\n// /* face integrals */\n// static double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;\n//\n// /* volume integrals */\n// static double T0, T1[3], T2[3], TP[3];\n//\n//\n// /*\n//    ============================================================================\n//    read in a polyhedron\n//    ============================================================================\n// */\n//\n// inline void readPolyhedron(const char *name, POLYHEDRON *p)\n// {\n//   FILE *fp;\n//   char line[200], *c;\n//   int i, j, n;\n//   double dx1, dy1, dz1, dx2, dy2, dz2, nx, ny, nz, len;\n//   FACE *f;\n//\n//\n//   if (!(fp = std::fopen(name, \"r\"))) {\n//     printf(\"i/o error\\n\");\n//     // exit(1);\n//   }\n//\n//   fscanf(fp, \"%d\", &amp;p-&gt;numVerts);\n//   printf(\"Reading in %d vertices\\n\", p-&gt;numVerts);\n//   for (i = 0; i &lt; p-&gt;numVerts; i++)\n//     fscanf(fp, \"%lf %lf %lf\",\n//            &amp;p-&gt;verts[i][X], &amp;p-&gt;verts[i][Y], &amp;p-&gt;verts[i][Z]);\n//\n//   fscanf(fp, \"%d\", &amp;p-&gt;numFaces);\n//   printf(\"Reading in %d faces\\n\", p-&gt;numFaces);\n//   for (i = 0; i &lt; p-&gt;numFaces; i++) {\n//     f = &amp;p-&gt;faces[i];\n//     f-&gt;poly = p;\n//     fscanf(fp, \"%d\", &amp;f-&gt;numVerts);\n//     for (j = 0; j &lt; f-&gt;numVerts; j++) fscanf(fp, \"%d\", &amp;f-&gt;verts[j]);\n//\n//     /* compute face normal and offset w from first 3 vertices */\n//     dx1 = p-&gt;verts[f-&gt;verts[1]][X] - p-&gt;verts[f-&gt;verts[0]][X];\n//     dy1 = p-&gt;verts[f-&gt;verts[1]][Y] - p-&gt;verts[f-&gt;verts[0]][Y];\n//     dz1 = p-&gt;verts[f-&gt;verts[1]][Z] - p-&gt;verts[f-&gt;verts[0]][Z];\n//     dx2 = p-&gt;verts[f-&gt;verts[2]][X] - p-&gt;verts[f-&gt;verts[1]][X];\n//     dy2 = p-&gt;verts[f-&gt;verts[2]][Y] - p-&gt;verts[f-&gt;verts[1]][Y];\n//     dz2 = p-&gt;verts[f-&gt;verts[2]][Z] - p-&gt;verts[f-&gt;verts[1]][Z];\n//     nx = dy1 * dz2 - dy2 * dz1;\n//     ny = dz1 * dx2 - dz2 * dx1;\n//     nz = dx1 * dy2 - dx2 * dy1;\n//     len = sqrt(nx * nx + ny * ny + nz * nz);\n//     f-&gt;norm[X] = nx / len;\n//     f-&gt;norm[Y] = ny / len;\n//     f-&gt;norm[Z] = nz / len;\n//     f-&gt;w = - f-&gt;norm[X] * p-&gt;verts[f-&gt;verts[0]][X]\n//            - f-&gt;norm[Y] * p-&gt;verts[f-&gt;verts[0]][Y]\n//            - f-&gt;norm[Z] * p-&gt;verts[f-&gt;verts[0]][Z];\n//\n//   }\n//\n//   fclose(fp);\n//\n// }\n//\n// /*\n//    ============================================================================\n//    compute mass properties\n//    ============================================================================\n// */\n//\n//\n// /* compute various integrations over projection of face */\n// inline void compProjectionIntegrals(FACE* f)\n// {\n//   double a0, a1, da;\n//   double b0, b1, db;\n//   double a0_2, a0_3, a0_4, b0_2, b0_3, b0_4;\n//   double a1_2, a1_3, b1_2, b1_3;\n//   double C1, Ca, Caa, Caaa, Cb, Cbb, Cbbb;\n//   double Cab, Kab, Caab, Kaab, Cabb, Kabb;\n//   int i;\n//\n//   P1 = Pa = Pb = Paa = Pab = Pbb = Paaa = Paab = Pabb = Pbbb = 0.0;\n//\n//   for (i = 0; i &lt; f-&gt;numVerts; i++) {\n//     a0 = f-&gt;poly-&gt;verts[f-&gt;verts[i]][A];\n//     b0 = f-&gt;poly-&gt;verts[f-&gt;verts[i]][B];\n//     a1 = f-&gt;poly-&gt;verts[f-&gt;verts[(i + 1) % f-&gt;numVerts]][A];\n//     b1 = f-&gt;poly-&gt;verts[f-&gt;verts[(i + 1) % f-&gt;numVerts]][B];\n//     da = a1 - a0;\n//     db = b1 - b0;\n//     a0_2 = a0 * a0;\n//     a0_3 = a0_2 * a0;\n//     a0_4 = a0_3 * a0;\n//     b0_2 = b0 * b0;\n//     b0_3 = b0_2 * b0;\n//     b0_4 = b0_3 * b0;\n//     a1_2 = a1 * a1;\n//     a1_3 = a1_2 * a1;\n//     b1_2 = b1 * b1;\n//     b1_3 = b1_2 * b1;\n//\n//     C1 = a1 + a0;\n//     Ca = a1 * C1 + a0_2;\n//     Caa = a1 * Ca + a0_3;\n//     Caaa = a1 * Caa + a0_4;\n//     Cb = b1 * (b1 + b0) + b0_2;\n//     Cbb = b1 * Cb + b0_3;\n//     Cbbb = b1 * Cbb + b0_4;\n//     Cab = 3 * a1_2 + 2 * a1 * a0 + a0_2;\n//     Kab = a1_2 + 2 * a1 * a0 + 3 * a0_2;\n//     Caab = a0 * Cab + 4 * a1_3;\n//     Kaab = a1 * Kab + 4 * a0_3;\n//     Cabb = 4 * b1_3 + 3 * b1_2 * b0 + 2 * b1 * b0_2 + b0_3;\n//     Kabb = b1_3 + 2 * b1_2 * b0 + 3 * b1 * b0_2 + 4 * b0_3;\n//\n//     P1 += db * C1;\n//     Pa += db * Ca;\n//     Paa += db * Caa;\n//     Paaa += db * Caaa;\n//     Pb += da * Cb;\n//     Pbb += da * Cbb;\n//     Pbbb += da * Cbbb;\n//     Pab += db * (b1 * Cab + b0 * Kab);\n//     Paab += db * (b1 * Caab + b0 * Kaab);\n//     Pabb += da * (a1 * Cabb + a0 * Kabb);\n//   }\n//\n//   P1 /= 2.0;\n//   Pa /= 6.0;\n//   Paa /= 12.0;\n//   Paaa /= 20.0;\n//   Pb /= -6.0;\n//   Pbb /= -12.0;\n//   Pbbb /= -20.0;\n//   Pab /= 24.0;\n//   Paab /= 60.0;\n//   Pabb /= -60.0;\n// }\n//\n// inline void compFaceIntegrals(FACE* f)\n// {\n//   double *n, w;\n//   double k1, k2, k3, k4;\n//\n//   compProjectionIntegrals(f);\n//\n//   w = f-&gt;w;\n//   n = f-&gt;norm;\n//   k1 = 1 / n[C];\n//   k2 = k1 * k1;\n//   k3 = k2 * k1;\n//   k4 = k3 * k1;\n//\n//   Fa = k1 * Pa;\n//   Fb = k1 * Pb;\n//   Fc = -k2 * (n[A] * Pa + n[B] * Pb + w * P1);\n//\n//   Faa = k1 * Paa;\n//   Fbb = k1 * Pbb;\n//   Fcc = k3\n//       * (SQR(n[A]) * Paa + 2 * n[A] * n[B] * Pab + SQR(n[B]) * Pbb\n//          + w * (2 * (n[A] * Pa + n[B] * Pb) + w * P1));\n//\n//   Faaa = k1 * Paaa;\n//   Fbbb = k1 * Pbbb;\n//   Fccc = -k4\n//       * (CUBE(n[A]) * Paaa + 3 * SQR(n[A]) * n[B] * Paab\n//          + 3 * n[A] * SQR(n[B]) * Pabb + CUBE(n[B]) * Pbbb\n//          + 3 * w * (SQR(n[A]) * Paa + 2 * n[A] * n[B] * Pab + SQR(n[B]) * Pbb)\n//          + w * w * (3 * (n[A] * Pa + n[B] * Pb) + w * P1));\n//\n//   Faab = k1 * Paab;\n//   Fbbc = -k2 * (n[A] * Pabb + n[B] * Pbbb + w * Pbb);\n//   Fcca = k3\n//       * (SQR(n[A]) * Paaa + 2 * n[A] * n[B] * Paab + SQR(n[B]) * Pabb\n//          + w * (2 * (n[A] * Paa + n[B] * Pab) + w * Pa));\n// }\n//\n// inline void compVolumeIntegrals(POLYHEDRON *p)\n// {\n//   FACE *f;\n//   double nx, ny, nz;\n//   int i;\n//\n//   T0 = T1[X] = T1[Y] = T1[Z]\n//      = T2[X] = T2[Y] = T2[Z]\n//      = TP[X] = TP[Y] = TP[Z] = 0;\n//\n//   for (i = 0; i &lt; p-&gt;numFaces; i++) {\n//\n//     f = &amp;p-&gt;faces[i];\n//\n//     nx = fabs(f-&gt;norm[X]);\n//     ny = fabs(f-&gt;norm[Y]);\n//     nz = fabs(f-&gt;norm[Z]);\n//     if (nx &gt; ny &amp;&amp; nx &gt; nz) C = X;\n//     else C = (ny &gt; nz) ? Y : Z;\n//     A = (C + 1) % 3;\n//     B = (A + 1) % 3;\n//\n//     compFaceIntegrals(f);\n//\n//     T0 += f-&gt;norm[X] * ((A == X) ? Fa : ((B == X) ? Fb : Fc));\n//\n//     T1[A] += f-&gt;norm[A] * Faa;\n//     T1[B] += f-&gt;norm[B] * Fbb;\n//     T1[C] += f-&gt;norm[C] * Fcc;\n//     T2[A] += f-&gt;norm[A] * Faaa;\n//     T2[B] += f-&gt;norm[B] * Fbbb;\n//     T2[C] += f-&gt;norm[C] * Fccc;\n//     TP[A] += f-&gt;norm[A] * Faab;\n//     TP[B] += f-&gt;norm[B] * Fbbc;\n//     TP[C] += f-&gt;norm[C] * Fcca;\n//   }\n//\n//   T1[X] /= 2; T1[Y] /= 2; T1[Z] /= 2;\n//   T2[X] /= 3; T2[Y] /= 3; T2[Z] /= 3;\n//   TP[X] /= 2; TP[Y] /= 2; TP[Z] /= 2;\n// }\n//\n//\n// /*\n//    ============================================================================\n//    main\n//    ============================================================================\n// */\n//\n// /**\n// *\n// */\n// // int main_test(int argc, char *argv[])\n// // {\n// //   POLYHEDRON p;\n// //   double density, mass;\n// //   double r[3];            /* center of mass */\n// //   double J[3][3];         /* inertia tensor */\n// //\n// //   if (argc != 2) {\n// //     printf(\"usage:  %s &lt;polyhedron geometry filename&gt;\\n\", argv[0]);\n// //     exit(0);\n// //   }\n// //\n// //   readPolyhedron(argv[1], &amp;p);\n// //\n// //   compVolumeIntegrals(&amp;p);\n// //\n// //\n// //   printf(\"\\nT1 =   %+20.6f\\n\\n\", T0);\n// //\n// //   printf(\"Tx =   %+20.6f\\n\", T1[X]);\n// //   printf(\"Ty =   %+20.6f\\n\", T1[Y]);\n// //   printf(\"Tz =   %+20.6f\\n\\n\", T1[Z]);\n// //\n// //   printf(\"Txx =  %+20.6f\\n\", T2[X]);\n// //   printf(\"Tyy =  %+20.6f\\n\", T2[Y]);\n// //   printf(\"Tzz =  %+20.6f\\n\\n\", T2[Z]);\n// //\n// //   printf(\"Txy =  %+20.6f\\n\", TP[X]);\n// //   printf(\"Tyz =  %+20.6f\\n\", TP[Y]);\n// //   printf(\"Tzx =  %+20.6f\\n\\n\", TP[Z]);\n// //\n// //   density = 1.0;  /* assume unit density */\n// //\n// //   mass = density * T0;\n// //\n// //   /* compute center of mass */\n// //   r[X] = T1[X] / T0;\n// //   r[Y] = T1[Y] / T0;\n// //   r[Z] = T1[Z] / T0;\n// //\n// //   /* compute inertia tensor */\n// //   J[X][X] = density * (T2[Y] + T2[Z]);\n// //   J[Y][Y] = density * (T2[Z] + T2[X]);\n// //   J[Z][Z] = density * (T2[X] + T2[Y]);\n// //   J[X][Y] = J[Y][X] = - density * TP[X];\n// //   J[Y][Z] = J[Z][Y] = - density * TP[Y];\n// //   J[Z][X] = J[X][Z] = - density * TP[Z];\n// //\n// //   /* translate inertia tensor to center of mass */\n// //   J[X][X] -= mass * (r[Y]*r[Y] + r[Z]*r[Z]);\n// //   J[Y][Y] -= mass * (r[Z]*r[Z] + r[X]*r[X]);\n// //   J[Z][Z] -= mass * (r[X]*r[X] + r[Y]*r[Y]);\n// //   J[X][Y] = J[Y][X] += mass * r[X] * r[Y];\n// //   J[Y][Z] = J[Z][Y] += mass * r[Y] * r[Z];\n// //   J[Z][X] = J[X][Z] += mass * r[Z] * r[X];\n// //\n// //   printf(\"center of mass:  (%+12.6f,%+12.6f,%+12.6f)\\n\\n\", r[X], r[Y], r[Z]);\n// //\n// //   printf(\"inertia tensor with origin at c.o.m. :\\n\");\n// //   printf(\"%+15.6f  %+15.6f  %+15.6f\\n\", J[X][X], J[X][Y], J[X][Z]);\n// //   printf(\"%+15.6f  %+15.6f  %+15.6f\\n\", J[Y][X], J[Y][Y], J[Y][Z]);\n// //   printf(\"%+15.6f  %+15.6f  %+15.6f\\n\\n\", J[Z][X], J[Z][Y], J[Z][Z]);\n// //\n// // }\n// }\n// #endif //VOLUME_INTEGRALS_H\n</code></pre>"},{"location":"naomi/dir_71a2c17b217df2e2fd8ff646c1f46430/","title":"Dir include/observers","text":"<p>FileList &gt; include &gt; observers</p>"},{"location":"naomi/dir_71a2c17b217df2e2fd8ff646c1f46430/#files","title":"Files","text":"Type Name file simulation_observer.h <p>The documentation for this class was generated from the following file <code>include/observers/</code></p>"},{"location":"naomi/simulation__observer_8h/","title":"File simulation_observer.h","text":"<p>FileList &gt; include &gt; observers &gt; simulation_observer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"propagators/event_detector.h\"</code></li> <li><code>#include \"spacecraft/pv_coordinates.h\"</code></li> </ul>"},{"location":"naomi/simulation__observer_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace observers"},{"location":"naomi/simulation__observer_8h/#classes","title":"Classes","text":"Type Name class results_csv_writer_observer &lt;class system_t&gt; class simulation_observer &lt;typename system_t&gt; <p>The documentation for this class was generated from the following file <code>include/observers/simulation_observer.h</code></p>"},{"location":"naomi/simulation__observer_8h_source/","title":"File simulation_observer.h","text":"<p>File List &gt; include &gt; observers &gt; simulation_observer.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/6/2024.\n//\n\n#ifndef SIMULATION_OBSERVER_H\n#define SIMULATION_OBSERVER_H\n#include &lt;memory&gt;\n#include &lt;utility&gt;\n\n#include \"propagators/event_detector.h\"\n#include \"spacecraft/pv_coordinates.h\"\n\nnamespace naomi::observers\n{\nusing namespace events;\ntemplate&lt;typename system_t&gt;\nclass simulation_observer\n{\n  double m_obs_interval;\n  double m_prev_obs_time = 0;\n  double m_next_obs_time = 0;\n\npublic:\n  virtual ~simulation_observer() = default;\n  explicit simulation_observer(const double obs_interval): m_obs_interval(obs_interval){}\n  virtual void initialize(const std::shared_ptr&lt;system_t&gt;&amp; system){}\n  void observe_state(const std::shared_ptr&lt;system_t&gt;&amp; system)\n  {\n    handle_observe_state(system);\n    m_prev_obs_time = system-&gt;get_current_time();\n    m_next_obs_time = m_prev_obs_time + m_obs_interval;\n  }\n  virtual void handle_observe_state(const std::shared_ptr&lt;system_t&gt;&amp; system) = 0;\n  virtual void observe_event(const std::shared_ptr&lt;event_detector&gt;&amp; event){}\n  virtual void terminate(const std::shared_ptr&lt;system_t&gt;&amp; system){}\n  [[nodiscard]] double get_next_update() const\n  {\n    return m_next_obs_time;\n  }\n};\n\n\ntemplate&lt;class system_t&gt;\nclass results_csv_writer_observer: public simulation_observer&lt;system_t&gt;\n{\n  std::string m_filepath;\n  std::fstream m_fout;\n  std::fstream::openmode m_openmode = std::ios::out;\n\npublic:\n  results_csv_writer_observer(const double obs_interval, std::string filepath):\n    simulation_observer&lt;system_t&gt;(obs_interval), m_filepath(std::move(filepath)){}\n\n  results_csv_writer_observer(const double obs_interval, std::string filepath, std::fstream::openmode openmode):\n    simulation_observer&lt;system_t&gt;(obs_interval), m_filepath(std::move(filepath)), m_openmode(openmode){}\n\n  void initialize(const std::shared_ptr&lt;system_t&gt;&amp; system) override\n  {\n    m_fout.open(m_filepath, m_openmode);\n    m_fout &lt;&lt; \"scid,x,y,z,vx,vy,vz,q0,q1,q2,q3\\n\";\n    this-&gt;observe_state(system);\n  }\n\n  void handle_observe_state(const std::shared_ptr&lt;system_t&gt;&amp; system) override\n  {\n    auto spacecrafts = system-&gt;get_spacecrafts();\n    for (const auto&amp; [id, sc]: spacecrafts) {\n      pv_coordinates pv = sc-&gt;get_pv_coordinates();\n      auto pos = pv.get_position();\n      auto vel = pv.get_velocity();\n      auto attitude = sc-&gt;get_attitude();\n      m_fout &lt;&lt; id &lt;&lt; \",\";\n      m_fout &lt;&lt; pos[0]  &lt;&lt; \",\" &lt;&lt; pos[1] &lt;&lt; \",\" &lt;&lt; pos[2] &lt;&lt; \",\";\n      m_fout &lt;&lt; pos[3]  &lt;&lt; \",\" &lt;&lt; pos[4] &lt;&lt; \",\" &lt;&lt; pos[5] &lt;&lt; \",\";\n      m_fout &lt;&lt; attitude[0] &lt;&lt; \",\" &lt;&lt; attitude[1] &lt;&lt; \",\" &lt;&lt; attitude[2] &lt;&lt; \",\" &lt;&lt; attitude[3] &lt;&lt; \"\\n\";\n    }\n  }\n\n  void terminate(const std::shared_ptr&lt;system_t&gt;&amp; system) override\n  {\n    m_fout.close();\n  }\n};\n}\n\n#endif //SIMULATION_OBSERVER_H\n</code></pre>"},{"location":"naomi/dir_ea5b6e782444c86c66e3453d3324b378/","title":"Dir include/orbits","text":"<p>FileList &gt; include &gt; orbits</p>"},{"location":"naomi/dir_ea5b6e782444c86c66e3453d3324b378/#files","title":"Files","text":"Type Name file cartesian.h file keplerian.h file orbits.h <p>The documentation for this class was generated from the following file <code>include/orbits/</code></p>"},{"location":"naomi/cartesian_8h/","title":"File cartesian.h","text":"<p>FileList &gt; include &gt; orbits &gt; cartesian.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;armadillo&gt;</code></li> </ul>"},{"location":"naomi/cartesian_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace orbits"},{"location":"naomi/cartesian_8h/#classes","title":"Classes","text":"Type Name class cartesian_orbit <p>The documentation for this class was generated from the following file <code>include/orbits/cartesian.h</code></p>"},{"location":"naomi/cartesian_8h_source/","title":"File cartesian.h","text":"<p>File List &gt; include &gt; orbits &gt; cartesian.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 6/15/2024.\n//\n\n#ifndef CARTESIAN_ORBIT_H\n#define CARTESIAN_ORBIT_H\n\n#include &lt;armadillo&gt;\n\nnamespace naomi::orbits\n{\nclass cartesian_orbit\n{\n  arma::vec3 m_pos;\n  arma::vec3 m_vel;\n\npublic:\n  cartesian_orbit(const arma::vec3&amp; pos, const arma::vec3&amp; vel): m_pos(pos), m_vel(vel){}\n\n  auto get_position() -&gt; arma::vec3&amp;\n  {\n    return m_pos;\n  }\n\n  auto get_velocity()  -&gt; arma::vec3&amp;\n  {\n    return m_vel;\n  }\n};\n}\n\n#endif //CARTESIAN_ORBIT_H\n</code></pre>"},{"location":"naomi/keplerian_8h/","title":"File keplerian.h","text":"<p>FileList &gt; include &gt; orbits &gt; keplerian.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"cartesian.h\"</code></li> <li><code>#include \"constants.h\"</code></li> <li><code>#include &lt;fmt/core.h&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;boost/math/constants/constants.hpp&gt;</code></li> <li><code>#include &lt;boost/math/tools/tuple.hpp&gt;</code></li> <li><code>#include &lt;boost/math/tools/roots.hpp&gt;</code></li> <li><code>#include \"integrators/integrator.h\"</code></li> </ul>"},{"location":"naomi/keplerian_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace orbits"},{"location":"naomi/keplerian_8h/#classes","title":"Classes","text":"Type Name struct eccentric_anomaly_functor &lt;class T&gt; class keplerian_orbit <p>The documentation for this class was generated from the following file <code>include/orbits/keplerian.h</code></p>"},{"location":"naomi/keplerian_8h_source/","title":"File keplerian.h","text":"<p>File List &gt; include &gt; orbits &gt; keplerian.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 6/14/2024.\n//\n\n#ifndef KEPLERIAN_H\n#define KEPLERIAN_H\n#include \"cartesian.h\"\n#include \"constants.h\"\n#include &lt;fmt/core.h&gt;\n#include &lt;cmath&gt;\n\n#include &lt;boost/math/constants/constants.hpp&gt;\n#include &lt;boost/math/tools/tuple.hpp&gt;\n#include &lt;boost/math/tools/roots.hpp&gt;\n#include \"integrators/integrator.h\"\n\nnamespace naomi::orbits\n{\nenum class AnomalyType{ TRUE, MEAN, ECCENTRIC };\n\ntemplate &lt;class T&gt;\nstruct eccentric_anomaly_functor\n{\n  eccentric_anomaly_functor(T const&amp; ecc, T const&amp; ma) : m_ecc(ecc), m_ma(ma)\n  { // Constructor stores value to be 'cube-rooted'.\n  }\n  boost::math::tuple&lt;T, T&gt; operator()(T const&amp; psi)\n  { // z is estimate so far.\n    return boost::math::make_tuple(\n      psi - m_ecc*sin(psi) - m_ma,\n      1 - m_ecc * cos(psi)\n    );\n  }\nprivate:\n  T m_ecc;\n  T m_ma;\n};\n\n\nclass keplerian_orbit\n{\n  double m_sma;\n  double m_ecc;\n  double m_inc;\n  double m_raan;\n  double m_aop;\n  double m_ma;\n  double m_ea;\n  double m_anomaly;\n  AnomalyType m_anomaly_type;\n\npublic:\n  keplerian_orbit(\n    const double sma,\n    const double ecc = 0,\n    const double inc = 0,\n    const double raan = 0,\n    const double aop = 0,\n    const double anomaly = 0,\n    const AnomalyType anomaly_type = AnomalyType::MEAN\n    ): m_sma(sma), m_ecc(ecc), m_inc(inc), m_raan(raan), m_aop(aop),\n        m_anomaly(anomaly), m_anomaly_type(anomaly_type) {}\n\n  static keplerian_orbit from_cartesian(cartesian_orbit&amp; cart)\n  {\n    arma::vec3 r = cart.get_position();\n    arma::vec3 v = cart.get_velocity();\n    arma::vec3 h_vec = cross(r, v);\n    arma::vec3 ih = normalise(h_vec);\n    arma::vec3 rn = normalise(r);\n    arma::vec3 e_vec = cross(v, h_vec) / constants::EARTH_MU - rn;\n    arma::vec3 ie = normalise(e_vec);\n    arma::vec3 ip = cross(ih, ie);\n\n    // RAAN\n    arma::vec3 ih_cross_k = cross(constants::PLUS_K, ih);\n    arma::vec3 no_hat = normalise(ih_cross_k);\n    auto cos_big_om = dot(no_hat, constants::PLUS_I);\n    auto sin_big_om = dot(no_hat, constants::PLUS_J);\n    auto raan = atan2(sin_big_om, cos_big_om);\n\n    // Inclination\n    auto cos_i = dot(constants::PLUS_K, ih);\n    auto inc = acos(cos_i);\n\n\n    // Argument of Perigee\n    auto cos_om = dot(no_hat, ie);\n    arma::vec3 no_cross_ie = cross(no_hat, ie);\n    auto sin_om = dot(ih, no_cross_ie);\n    auto aop = atan2(sin_om, cos_om);\n    if (aop &lt; 0) {\n      aop = 2 * boost::math::double_constants::pi + aop;\n    }\n\n    // Eccentricity\n    auto e = norm(e_vec);\n\n    // Semi-Major Axis\n    auto p = dot(h_vec, h_vec) / constants::EARTH_MU;\n    auto sma = p / (1-pow(e, 2));\n\n    // Mean Anomaly\n    auto th = acos(1/e*(p/norm(cart.get_position()) -1));\n    auto tan_psi = sqrt((1 - e ) / (1 + e))  * tan(th/2);\n    auto psi = atan(tan_psi) * 2;\n    auto ma = psi - e * sin(psi);\n    return {sma, e, inc, raan, aop, ma, AnomalyType::MEAN};\n  }\n\n  static double v_norm(arma::vec3 v)\n  {\n    return sqrt(pow(v[0], 2) + pow(v[1], 2) + pow(v[2], 2));\n  }\n\n  static double compute_eccentricity(arma::vec3&amp; r, arma::vec3&amp; v, double mu)\n  {\n    typedef arma::vec3 t;\n\n    auto rn = norm(r, 2);\n    auto vn =  norm(v, 2);\n    auto v_r = dot(r/rn, v);\n    fmt::print(\"rn = {}\\nvn = {}\\nv_r = {}\\n\\n\", rn, vn, v_r);\n\n    t h = cross(r, v);\n    h.print(\"h = \");\n    auto hn = norm(h);\n    fmt::print(\"hn = {}\\n\\n\", hn);\n    t vxh = cross(v, h);\n    t vxh_mu = vxh / mu;\n    t norm_r = r / rn;\n    vxh.print(\"vxh = \");\n    vxh_mu.print(\"vxh_mu = \");\n    norm_r.print(\"norm_r = \");\n    t e = vxh_mu - norm_r;\n    e.print(\"e = \");\n    double en = norm(e, 2);\n    return en;\n  }\n\n  auto to_cartesian() const -&gt; arma::vec6\n  {\n    auto psi = get_eccentric_anomaly();\n    auto th = 2 * atan(sqrt((1 + m_ecc)/(1 - m_ecc)) * tan(psi/2));\n    auto p = m_sma * (1 - pow(m_ecc, 2));\n    auto r = p / (1 + m_ecc*cos(th));\n    auto h = sqrt(p * constants::EARTH_MU);\n    arma::vec3 r_peri = {r * cos(th), r*sin(th), 0};\n    arma::vec3 v_peri = {-(constants::EARTH_MU/h) * sin(th), (constants::EARTH_MU/h)*(m_ecc + cos(th)), 0};\n    arma::mat a = {\n      {cos(m_aop), sin(m_aop), 0},\n      {-sin(m_aop), cos(m_aop), 0},\n      {0, 0, 1}\n    };\n    arma::mat b = {\n      { 1, 0, 0},\n        {0, cos(m_inc), sin(m_inc)},\n        {0, -sin(m_inc), cos(m_inc)},\n    };\n    arma::mat c = {\n      {cos(m_raan), sin(m_raan), 0},\n      {-sin(m_raan), cos(m_raan), 0},\n      {0, 0, 1}\n    };\n    auto o_pg = (a * b * c).eval();\n    auto o_gp = o_pg.t().eval();\n    arma::vec3 r_eci = o_gp * r_peri;\n    arma::vec3 v_eci = o_gp * v_peri;\n    return arma::join_cols(r_eci, v_eci);\n  }\n\n  [[nodiscard]] auto get_orbital_period() const -&gt; double\n  {\n    return get_orbital_period(m_sma);\n  }\n\n  auto static get_orbital_period(const double sma) -&gt; double\n  {\n    return 2.0*boost::math::double_constants::pi / sqrt(constants::EARTH_MU / pow(sma, 3));\n  }\n\n  [[nodiscard]] auto get_a() const -&gt; double\n  {\n    return m_sma;\n  }\n\n  [[nodiscard]] auto get_i(bool degrees = true) const -&gt; double\n  {\n    if (degrees) {\n      return rad2deg(m_inc);\n    }\n    return m_inc;\n  }\n\n  [[nodiscard]] auto get_e() const -&gt; double\n  {\n    return m_ecc;\n  }\n\n  [[nodiscard]] auto get_raan(bool degrees = true) const -&gt; double\n  {\n    if (degrees) {\n      return rad2deg(m_raan);\n    }\n    return m_raan;\n  }\n\n  [[nodiscard]] auto get_aop(bool degrees = true) const -&gt; double\n  {\n    if (degrees) {\n      return rad2deg(m_aop);\n    }\n    return m_aop;\n  }\n\n  [[nodiscard]] auto get_anomaly(bool degrees = true) const -&gt; double\n  {\n    if (degrees) {\n      return rad2deg(m_anomaly);\n    }\n    return m_anomaly;\n  }\n\n  [[nodiscard]] auto get_eccentric_anomaly() const -&gt; double\n  {\n    if (m_anomaly_type == AnomalyType::MEAN) {\n      int digits = std::numeric_limits&lt;double&gt;::digits; // Maximum possible binary digits accuracy for type T.\n      return boost::math::tools::newton_raphson_iterate(eccentric_anomaly_functor&lt;double&gt;(m_ecc, m_anomaly), 0.1, -2*boost::math::double_constants::pi, 2*boost::math::double_constants::pi, digits);\n    }\n    if (m_anomaly_type == AnomalyType::TRUE) {\n      auto tan_psi = sqrt((1 - m_ecc ) / (1 + m_ecc))  * tan(m_anomaly/2);\n      auto psi = atan(tan_psi) * 2;\n      return psi;\n    }\n    return 0.0;\n  }\n\n  double rad2deg(double rad) const\n  {\n    auto result = rad * (180.0/boost::math::double_constants::pi);\n    return result;\n  }\n\n  double deg2rad(double deg) const\n  {\n    return deg * (boost::math::double_constants::pi/180.0);\n  }\n\n  [[nodiscard]] auto to_vec(bool degrees = false) const -&gt; arma::vec6 {\n    if (degrees) {\n      return {m_sma, m_ecc, rad2deg(m_inc), rad2deg(m_raan), rad2deg(m_aop), rad2deg(m_anomaly)};\n    }\n    return {m_sma, m_ecc, m_inc, m_raan, m_aop, m_anomaly};\n  }\n\n  [[nodiscard]] auto fn(const double&amp; psi) const -&gt; boost::math::tuple&lt;double, double&gt; {\n    return boost::math::make_tuple(\n      psi - m_ecc*sin(psi) - m_anomaly,\n      1 - m_ecc * cos(psi)\n    );\n  }\n\n  bool operator==(const keplerian_orbit&amp; other) const\n  {\n    return\n      m_sma == other.m_sma\n      &amp;&amp; m_ecc == other.m_ecc\n      &amp;&amp; m_inc == other.m_inc\n      &amp;&amp; m_raan == other.m_raan\n      &amp;&amp; m_aop == other.m_aop\n      &amp;&amp; m_anomaly == other.m_anomaly;\n  }\n};\n}\n\n#endif //KEPLERIAN_H\n</code></pre>"},{"location":"naomi/orbits_8h/","title":"File orbits.h","text":"<p>FileList &gt; include &gt; orbits &gt; orbits.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;armadillo&gt;</code></li> <li><code>#include \"constants.h\"</code></li> <li><code>#include \"naomi.h\"</code></li> </ul>"},{"location":"naomi/orbits_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace orbits <p>The documentation for this class was generated from the following file <code>include/orbits/orbits.h</code></p>"},{"location":"naomi/orbits_8h_source/","title":"File orbits.h","text":"<p>File List &gt; include &gt; orbits &gt; orbits.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 6/11/2024.\n//\n\n#ifndef ORBITS_H\n#define ORBITS_H\n#include &lt;armadillo&gt;\n\n#include \"constants.h\"\n#include \"naomi.h\"\nnamespace naomi::orbits\n{\ninline vector_type get_circular_orbit(const arma::vec3&amp; initial_position, const double mu = constants::EARTH_MU)\n{\n  const double vn = sqrt(mu / norm(initial_position));\n  const arma::vec k_hat {0.0, 0.0, 1.0};\n  const arma::vec h_dir = arma::normalise(\n      cross(initial_position, cross(k_hat, initial_position)));\n  const arma::vec v_dir = arma::normalise(arma::cross(h_dir, initial_position));\n  const arma::vec v = v_dir*vn;\n  return join_cols(initial_position, v);\n}\n\n[[nodiscard]] inline double vis_viva(const double radius,\n                              const double sma,\n                              const double mu = constants::EARTH_MU)\n{\n  return sqrt(mu * (2/radius - 1/sma));\n}\n}\n#endif //ORBITS_H\n</code></pre>"},{"location":"naomi/dir_e71f1b759bebc3883eefe2f9e102561d/","title":"Dir include/propagators","text":"<p>FileList &gt; include &gt; propagators</p>"},{"location":"naomi/dir_e71f1b759bebc3883eefe2f9e102561d/#files","title":"Files","text":"Type Name file event_detector.h file event_handler.h file numerical_propagator.h <p>The documentation for this class was generated from the following file <code>include/propagators/</code></p>"},{"location":"naomi/event__detector_8h/","title":"File event_detector.h","text":"<p>FileList &gt; include &gt; propagators &gt; event_detector.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;armadillo&gt;</code></li> <li><code>#include \"event_handler.h\"</code></li> <li><code>#include \"naomi.h\"</code></li> </ul>"},{"location":"naomi/event__detector_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace events"},{"location":"naomi/event__detector_8h/#classes","title":"Classes","text":"Type Name class apside_detector struct event class event_detector struct event_detector_condition class time_detector <p>The documentation for this class was generated from the following file <code>include/propagators/event_detector.h</code></p>"},{"location":"naomi/event__detector_8h_source/","title":"File event_detector.h","text":"<p>File List &gt; include &gt; propagators &gt; event_detector.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 6/24/2024.\n//\n\n#ifndef EVENT_DETECTOR_H\n#define EVENT_DETECTOR_H\n#include &lt;armadillo&gt;\n\n#include \"event_handler.h\"\n#include \"naomi.h\"\n\n\nnamespace naomi::events\n{\nenum EventDetectorTrigger {INCREASING, DECREASING, ALL};\n\ntypedef std::pair&lt;vector_type, double&gt; state_and_time_type;\n\nclass event_detector\n{\n  EventDetectorTrigger m_trigger = ALL;\n  double m_max_check_interval = 10;\n  double m_abs_tol = 1e-6;\n  double m_rel_tol = 1e-6;\n  std::vector&lt;std::shared_ptr&lt;event_handler&gt;&gt; m_handlers;\n\nprotected:\n  bool m_is_active = true;\n\npublic:\n  virtual ~event_detector() = default;\n  // event_detector() = default;\n  explicit event_detector(const EventDetectorTrigger trigger): m_trigger(trigger){}\n  event_detector(\n    const EventDetectorTrigger trigger,\n    const double max_check_interval\n    ): m_trigger(trigger), m_max_check_interval(max_check_interval){}\n  event_detector(\n    const EventDetectorTrigger trigger,\n    const double max_check_interval,\n    const double abs_tol\n    ): m_trigger(trigger), m_max_check_interval(max_check_interval), m_abs_tol(abs_tol){}\n  event_detector(\n    const EventDetectorTrigger trigger,\n    const double max_check_interval,\n    const double abs_tol,\n    const double rel_tol\n    ): m_trigger(trigger), m_max_check_interval(max_check_interval), m_abs_tol(abs_tol), m_rel_tol(rel_tol){}\n\n\n  [[nodiscard]] virtual double g(const state_and_time_type&amp; sv) const = 0;\n\n  [[nodiscard]] bool operator()(const state_and_time_type&amp; initial, const state_and_time_type&amp; final) const\n  {\n    if (! m_is_active) return false;\n\n    const double init_val = g(initial);\n    const double final_val = g(final);\n    const bool is_root = init_val * final_val &lt;= 0;\n\n    if (m_trigger == INCREASING) {\n      return is_root &amp;&amp; init_val &lt;= 0;\n    }\n    if (m_trigger == DECREASING) {\n      return is_root &amp;&amp; final_val &lt;= 0;\n    }\n    return init_val * final_val &lt;= 0;\n  }\n\n  virtual void handle_event(const std::shared_ptr&lt;spacecraft&gt;&amp; sc, double t)\n  {\n    for (const auto &amp; handler: m_handlers) {\n      handler-&gt;handle_event(sc, t);\n    }\n  }\n};\n\nstruct event\n{\n  double time_occurred;\n  std::shared_ptr&lt;event_detector&gt; detector;\n\n};\n\nclass apside_detector final : public event_detector\n{\npublic:\n  explicit apside_detector(const EventDetectorTrigger trigger)\n      : event_detector(trigger)\n  {\n  }\n\n  [[nodiscard]] double g(const state_and_time_type&amp; sv) const override\n  {\n    const arma::vec3 pos = sv.first(arma::span(0, 2));\n    const arma::vec3 vel = sv.first(arma::span(3, 5));\n    return dot(pos, vel);\n  }\n};\n\nclass time_detector final : public event_detector\n{\n  double m_time;\npublic:\n  explicit time_detector(double time)\n      : event_detector(DECREASING), m_time(time)\n  {\n  }\n\n  [[nodiscard]] double g(const state_and_time_type&amp; sv) const override\n  {\n    return m_time - sv.second;\n  }\n\n};\n\nstruct event_detector_condition\n{\n  std::vector&lt;apside_detector&gt; m_detectors;\n  std::vector&lt;double&gt; m_detector_g;\n\n  explicit event_detector_condition(apside_detector&amp; ad)\n  {\n    m_detectors.push_back(ad);\n  }\n\n};\n}\n\n#endif //EVENT_DETECTOR_H\n</code></pre>"},{"location":"naomi/event__handler_8h/","title":"File event_handler.h","text":"<p>FileList &gt; include &gt; propagators &gt; event_handler.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"naomi/event__handler_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace events"},{"location":"naomi/event__handler_8h/#classes","title":"Classes","text":"Type Name class event_handler <p>The documentation for this class was generated from the following file <code>include/propagators/event_handler.h</code></p>"},{"location":"naomi/event__handler_8h_source/","title":"File event_handler.h","text":"<p>File List &gt; include &gt; propagators &gt; event_handler.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/4/2024.\n//\n\n#ifndef EVENT_HANDLER_H\n#define EVENT_HANDLER_H\n#include &lt;memory&gt;\n\nnamespace naomi\n{\nclass spacecraft;\nnamespace events\n{\nclass event_handler\n{\npublic:\n  virtual ~event_handler() = default;\n  virtual void handle_event(const std::shared_ptr&lt;spacecraft&gt;&amp; sc, double t) = 0;\n};\n}\n}\n#endif //EVENT_HANDLER_H\n</code></pre>"},{"location":"naomi/numerical__propagator_8h/","title":"File numerical_propagator.h","text":"<p>FileList &gt; include &gt; propagators &gt; numerical_propagator.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;armadillo&gt;</code></li> <li><code>#include \"boost/numeric/odeint.hpp\"</code></li> <li><code>#include \"integrators/integrator.h\"</code></li> <li><code>#include \"spacecraft/spacecraft.h\"</code></li> <li><code>#include \"forces/force_model.h\"</code></li> </ul>"},{"location":"naomi/numerical__propagator_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace numeric"},{"location":"naomi/numerical__propagator_8h/#classes","title":"Classes","text":"Type Name class numerical_propagator &lt;typename Stepper&gt; <p>The documentation for this class was generated from the following file <code>include/propagators/numerical_propagator.h</code></p>"},{"location":"naomi/numerical__propagator_8h_source/","title":"File numerical_propagator.h","text":"<p>File List &gt; include &gt; propagators &gt; numerical_propagator.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 5/24/2024.\n//\n\n#ifndef NUMERICAL_PROPAGATOR_H\n#define NUMERICAL_PROPAGATOR_H\n\n#include &lt;armadillo&gt;\n#include \"boost/numeric/odeint.hpp\"\n#include \"integrators/integrator.h\"\n#include \"spacecraft/spacecraft.h\"\n#include \"forces/force_model.h\"\n\nusing namespace naomi;\n\ntemplate&lt;&gt;\nstruct boost::numeric::odeint::vector_space_norm_inf&lt;vector_type&gt;\n{\n  typedef double result_type;\n\n  result_type operator()(const vector_type&amp; s) const\n  {\n    return arma::norm(s, \"inf\");\n  }\n};  // namespace boost::numeric::odeint\n\nnamespace boost::numeric::odeint\n{\n\ntemplate&lt;&gt;\nstruct is_resizeable&lt;arma::vec&gt;\n{\n  typedef true_type type;\n  const static bool value = type::value;\n};\n\ntemplate&lt;&gt;\nstruct same_size_impl&lt;arma::vec, arma::vec&gt;\n{\n  static bool same_size(const arma::vec&amp; x, const arma::vec&amp; y)\n  {\n    return x.size() == y.size();  // or use .n_elem attributes\n  }\n};\n\ntemplate&lt;&gt;\nstruct resize_impl&lt;arma::vec, arma::vec&gt;\n{\n  static void resize(arma::vec&amp; v1, const arma::vec&amp; v2)\n  {\n    v1.resize(v2.size());  // not sure if this is correct for arma\n  }\n};\n}\n\nnamespace naomi::numeric\n{\nusing namespace events;\nusing namespace maneuvers;\n\n\ntemplate &lt;typename Stepper&gt;\nclass numerical_propagator\n{\npublic:\n  numerical_propagator(const numerical_propagator&amp; other)\n      : m_integrator(other.m_integrator)\n      , m_system(other.m_system)\n      , m_spacecrafts(other.m_spacecrafts)\n      , _system_eoms(other._system_eoms)\n      , m_event_detectors(other.m_event_detectors)\n      , m_t(other.m_t)\n  {\n  }\n  numerical_propagator(numerical_propagator&amp;&amp; other) noexcept\n      : m_integrator(std::move(other.m_integrator))\n      , m_system(std::move(other.m_system))\n      , m_spacecrafts(std::move(other.m_spacecrafts))\n      , _system_eoms(std::move(other._system_eoms))\n      , m_event_detectors(std::move(other.m_event_detectors))\n      , m_t(other.m_t)\n  {\n  }\n  numerical_propagator&amp; operator=(const numerical_propagator&amp; other)\n  {\n    if (this == &amp;other)\n      return *this;\n    m_integrator = other.m_integrator;\n    m_system = other.m_system;\n    m_spacecrafts = other.m_spacecrafts;\n    _system_eoms = other._system_eoms;\n    m_event_detectors = other.m_event_detectors;\n    m_t = other.m_t;\n    return *this;\n  }\n  numerical_propagator&amp; operator=(numerical_propagator&amp;&amp; other) noexcept\n  {\n    if (this == &amp;other)\n      return *this;\n    m_integrator = std::move(other.m_integrator);\n    m_system = std::move(other.m_system);\n    m_spacecrafts = std::move(other.m_spacecrafts);\n    _system_eoms = std::move(other._system_eoms);\n    m_event_detectors = std::move(other.m_event_detectors);\n    m_t = other.m_t;\n    return *this;\n  }\n\nprivate:\n  integrator&lt;Stepper&gt; m_integrator;\n  std::shared_ptr&lt;force_model&gt; m_system;\n  std::shared_ptr&lt;equations_of_motion&gt; _system_eoms;\n  std::map&lt;std::string, std::shared_ptr&lt;spacecraft&gt;&gt; m_spacecrafts;\n  std::vector&lt;std::shared_ptr&lt;event_detector&gt;&gt; m_event_detectors = {};\n  double m_t = 0.0;\n\npublic:\n  ~numerical_propagator() = default;\n  numerical_propagator() = default;\n\n  void initialize(const std::shared_ptr&lt;equations_of_motion&gt;&amp; system_eoms, const std::map&lt;std::string, std::shared_ptr&lt;spacecraft&gt;&gt;&amp; spacecrafts)\n  {\n    _system_eoms = system_eoms;\n    m_spacecrafts = spacecrafts;\n    for (const auto &amp; [fst, sc] : m_spacecrafts) {\n      if (sc-&gt;get_maneuver_plan() != nullptr) m_event_detectors.emplace_back(sc-&gt;get_maneuver_plan());\n    }\n  }\n\n  std::vector&lt;std::pair&lt;arma::span, std::shared_ptr&lt;additional_state_provider&gt;&gt;&gt; map_providers(\n    const std::vector&lt;std::shared_ptr&lt;additional_state_provider&gt;&gt;&amp; additional_providers\n  )\n    {\n      const std::size_t start_idx = 8;\n      std::vector&lt;\n        std::pair&lt;arma::span, std::shared_ptr&lt;additional_state_provider&gt;&gt;\n      &gt; providers;\n      for (const auto&amp; provider : additional_providers) {\n        const auto size = provider-&gt;get_size();\n        const auto end_idx = start_idx + size;\n        const auto prov_span = arma::span(start_idx + 1, end_idx);\n        providers.emplace_back(prov_span, provider);\n      }\n      return providers;\n    }\n\n  std::vector&lt;std::shared_ptr&lt;event_detector&gt;&gt; check_events(const state_and_time_type&amp; prev, const state_and_time_type&amp; curr, double t)\n  {\n    std::vector&lt;std::shared_ptr&lt;event_detector&gt;&gt; active_events;\n    for(const std::shared_ptr&lt;event_detector&gt;&amp; e: m_event_detectors) {\n      if ((*e)(prev, curr)) {\n        active_events.push_back(e);\n      }\n    }\n    return active_events;\n  }\n\n  auto make_system(const std::shared_ptr&lt;force_model&gt;&amp; force_model,\n                   const std::shared_ptr&lt;spacecraft&gt;&amp; spacecraft)\n  {\n    auto system_eoms = _system_eoms;\n    const auto provider_map = spacecraft-&gt;get_state().get_provider_mapping();\n    auto initial_state = spacecraft-&gt;get_state().get_integrated_state();\n    return [system_eoms, provider_map](const auto&amp; x, auto&amp; dxdt, double t)\n        {\n          for (const auto&amp; [fst, snd] : provider_map) {\n            if (auto eoms = snd-&gt;get_eoms(); eoms == nullptr) {\n              dxdt(fst) = system_eoms-&gt;get_derivative(x(fst), t);\n            } else {\n              dxdt(fst) = eoms-&gt;get_derivative(x(fst), t);\n            }\n          }\n        };\n  }\n\n  static std::vector&lt;double&gt; get_integration_times(const double t_start,\n                                                   const double t_end)\n  {\n    std::vector&lt;double&gt; times;\n    double t_curr = t_start;\n    double t_step = 2;\n    while (t_curr + t_step &lt; t_end) {\n      times.push_back(t_curr);\n      t_curr += t_step;\n    }\n    times.push_back(t_end);\n    return times;\n  }\n\n  void propagate_to(const std::shared_ptr&lt;spacecraft&gt;&amp; spacecraft, double dt)\n  {\n    auto system = make_system(m_system, spacecraft);\n    const double end = dt;\n    auto times = get_integration_times(m_t, end);\n    for (std::size_t i = 0; i &lt; times.size() - 1; i++) {\n      double start_t = times[i];\n      double end_t = times[i + 1];\n      vector_type state = spacecraft-&gt;get_state().get_integrated_state();\n      state_and_time_type prev_state = {state, start_t};\n      start_t = m_integrator.integrate( system, state , start_t , end_t , 0.1 );\n      state_and_time_type new_state = {state, start_t};\n      auto active_events = check_events(prev_state, new_state, start_t);\n      for (std::shared_ptr&lt;event_detector&gt; e: active_events) {\n        // TODO: This wont work with multiple events\n        auto event = m_integrator.find_event_time(system, times[i], times[i+1], e, prev_state, 0.1);\n        start_t = event.first;\n        spacecraft-&gt;get_state().set_integrated_state(event.second);\n        e-&gt;handle_event(spacecraft, start_t);\n        spacecraft-&gt;update(event.first);\n        state = spacecraft-&gt;get_state().get_integrated_state();\n        std::cout &lt;&lt; \"event occurred at: \" &lt;&lt; start_t &lt;&lt; \"state: \" &lt;&lt; state &lt;&lt; \"\\n\";\n      }\n      m_integrator.integrate( system, state , start_t , end_t , 0.1 );\n      spacecraft-&gt;get_state().set_integrated_state(state);\n      spacecraft-&gt;update(end_t);\n    }\n  }\n\n  double propagate_to(const double dt)\n  {\n    const double end = dt;\n    for (const auto &amp; [scid, sc]: m_spacecrafts) {\n      propagate_to(sc, dt);\n    }\n    m_t = end;\n    return m_t;\n  }\n\n  void propagate_by(const std::shared_ptr&lt;spacecraft&gt;&amp; spacecraft, double dt)\n  {\n    propagate_to(spacecraft, m_t + dt);\n  }\n\n  double propagate_by(const double dt)\n  {\n    return propagate_to(m_t + dt);\n  }\n};\n\n\ntypedef\n  boost::numeric::odeint::runge_kutta_dopri5&lt;\n    vector_type,\n    double,\n    vector_type,\n    double,\n    boost::numeric::odeint::vector_space_algebra&gt; rk_dopri5_stepper;\n}\n\n\n#endif //NUMERICAL_PROPAGATOR_H\n</code></pre>"},{"location":"naomi/dir_5b4f22f4782ab9e132490b62f43f6146/","title":"Dir include/simulation","text":"<p>FileList &gt; include &gt; simulation</p>"},{"location":"naomi/dir_5b4f22f4782ab9e132490b62f43f6146/#files","title":"Files","text":"Type Name file simulation.h <p>The documentation for this class was generated from the following file <code>include/simulation/</code></p>"},{"location":"naomi/simulation_8h/","title":"File simulation.h","text":"<p>FileList &gt; include &gt; simulation &gt; simulation.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"observers/simulation_observer.h\"</code></li> </ul>"},{"location":"naomi/simulation_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi"},{"location":"naomi/simulation_8h/#classes","title":"Classes","text":"Type Name class simulation &lt;typename system_t&gt; class simulation_component &lt;typename state_t&gt; <p>The documentation for this class was generated from the following file <code>include/simulation/simulation.h</code></p>"},{"location":"naomi/simulation_8h_source/","title":"File simulation.h","text":"<p>File List &gt; include &gt; simulation &gt; simulation.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/6/2024.\n//\n\n#ifndef SIMULATION_H\n#define SIMULATION_H\n#include \"observers/simulation_observer.h\"\n\nnamespace naomi\n{\nusing namespace observers;\n\ntemplate&lt;typename state_t&gt;\nclass simulation_component\n{\npublic:\n  virtual ~simulation_component() = default;\n  virtual void initialize(state_t&amp; state){}\n  virtual void update(state_t&amp; state){}\n  virtual void terminate(state_t&amp; state){}\n};\n\ntemplate&lt;typename system_t&gt;\nclass simulation\n{\n  std::shared_ptr&lt;system_t&gt; m_system;\n  std::vector&lt;std::shared_ptr&lt;simulation_observer&lt;system_t&gt;&gt;&gt; m_observers;\n  double m_t = 0;\n\npublic:\n  explicit simulation(std::shared_ptr&lt;system_t&gt; system): m_system(system){}\n  simulation(std::shared_ptr&lt;system_t&gt; system, const std::initializer_list&lt;std::shared_ptr&lt;simulation_observer&lt;system_t&gt;&gt;&gt;&amp; observers):\n    m_system(system), m_observers(observers){}\n\n  std::pair&lt;double, std::shared_ptr&lt;simulation_observer&lt;system_t&gt;&gt;&gt; get_next_update()\n  {\n    if (m_observers.empty()) {\n      return {0, nullptr};\n    }\n    auto obs = m_observers.at(0);\n    return {obs-&gt;get_next_update(), obs};\n  }\n\n  void simulate(const double duration)\n  {\n    for(const auto&amp; observer: m_observers) observer-&gt;initialize(m_system);\n\n    while (m_t &lt; duration)\n    {\n      auto next_update = get_next_update();\n      double interval = 0;\n      if (next_update.second == nullptr) {\n        interval = m_t + duration;\n      } else {\n        interval = next_update.first;\n      }\n      const double curr_time = m_system-&gt;simulate_to(interval);\n      if (next_update.second != nullptr) {\n        next_update.second-&gt;observe_state(m_system);\n      }\n      m_t = curr_time;\n    }\n    for(const auto&amp; observer: m_observers) observer-&gt;terminate(m_system);\n  }\n};\n}\n#endif //SIMULATION_H\n</code></pre>"},{"location":"naomi/dir_aa2d886d1f4bcde15bb57ed7cc846757/","title":"Dir include/spacecraft","text":"<p>FileList &gt; include &gt; spacecraft</p>"},{"location":"naomi/dir_aa2d886d1f4bcde15bb57ed7cc846757/#files","title":"Files","text":"Type Name file body_shape.h file pv_coordinates.h file pv_coordinates_provider.h file spacecraft.h file spacecraft_state.h file spacecraft_subsystem.h file state_provider.h <p>The documentation for this class was generated from the following file <code>include/spacecraft/</code></p>"},{"location":"naomi/body__shape_8h/","title":"File body_shape.h","text":"<p>FileList &gt; include &gt; spacecraft &gt; body_shape.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;armadillo&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;fmt/core.h&gt;</code></li> </ul>"},{"location":"naomi/body__shape_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi namespace geometry"},{"location":"naomi/body__shape_8h/#classes","title":"Classes","text":"Type Name class body_shape struct face"},{"location":"naomi/body__shape_8h/#public-attributes","title":"Public Attributes","text":"Type Name constexpr int X   = = 0 constexpr int Y   = = 1 constexpr int Z   = = 2"},{"location":"naomi/body__shape_8h/#macros","title":"Macros","text":"Type Name define CUBE (x) ((x)*(x)*(x)) define MAX_FACES  100     /* maximum number of polyhedral faces */ define MAX_POLYGON_SZ  10 /* maximum number of verts per polygonal face */ define MAX_VERTS  100     /* maximum number of polyhedral vertices */ define SQR (x) ((x)*(x))"},{"location":"naomi/body__shape_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"naomi/body__shape_8h/#variable-x","title":"variable X","text":"<pre><code>constexpr int X;\n</code></pre>"},{"location":"naomi/body__shape_8h/#variable-y","title":"variable Y","text":"<pre><code>constexpr int Y;\n</code></pre>"},{"location":"naomi/body__shape_8h/#variable-z","title":"variable Z","text":"<pre><code>constexpr int Z;\n</code></pre>"},{"location":"naomi/body__shape_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"naomi/body__shape_8h/#define-cube","title":"define CUBE","text":"<pre><code>#define CUBE (\n    x\n) ((x)*(x)*(x))\n</code></pre>"},{"location":"naomi/body__shape_8h/#define-max_faces","title":"define MAX_FACES","text":"<pre><code>#define MAX_FACES 100     /* maximum number of polyhedral faces */\n</code></pre>"},{"location":"naomi/body__shape_8h/#define-max_polygon_sz","title":"define MAX_POLYGON_SZ","text":"<pre><code>#define MAX_POLYGON_SZ 10 /* maximum number of verts per polygonal face */\n</code></pre>"},{"location":"naomi/body__shape_8h/#define-max_verts","title":"define MAX_VERTS","text":"<pre><code>#define MAX_VERTS 100     /* maximum number of polyhedral vertices */\n</code></pre>"},{"location":"naomi/body__shape_8h/#define-sqr","title":"define SQR","text":"<pre><code>#define SQR (\n    x\n) ((x)*(x))\n</code></pre> <p>The documentation for this class was generated from the following file <code>include/spacecraft/body_shape.h</code></p>"},{"location":"naomi/body__shape_8h_source/","title":"File body_shape.h","text":"<p>File List &gt; include &gt; spacecraft &gt; body_shape.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 7/13/2024.\n//\n\n#ifndef BODY_SHAPE_H\n#define BODY_SHAPE_H\n\n#include &lt;armadillo&gt;\n#include &lt;array&gt;\n#include &lt;cstddef&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#include &lt;fmt/core.h&gt;\n\n#define MAX_VERTS 100     /* maximum number of polyhedral vertices */\n#define MAX_FACES 100     /* maximum number of polyhedral faces */\n#define MAX_POLYGON_SZ 10 /* maximum number of verts per polygonal face */\n\nconstexpr int X = 0;\nconstexpr int Y = 1;\nconstexpr int Z = 2;\n\n#define SQR(x) ((x)*(x))\n#define CUBE(x) ((x)*(x)*(x))\n\nnamespace naomi::geometry\n{\n\nstruct face\n{\n  std::vector&lt;int&gt; verts;\n  double w;\n  arma::vec3 norm;\n\n  face(std::vector&lt;int&gt; v, const double w, const arma::vec3&amp; normal):\n    verts(std::move(v)), w(w), norm(normal){}\n};\n\nclass body_shape\n{\n  std::vector&lt;arma::vec3&gt; m_verts;\n  std::vector&lt;face&gt; m_faces;\n  double m_mass;\n  double m_density;\n  int A;   /* alpha */\n  int B;   /* beta */\n  int C;   /* gamma */\n\n  /* projection integrals */\n  double P1, Pa, Pb, Paa, Pab, Pbb, Paaa, Paab, Pabb, Pbbb;\n\n  /* face integrals */\n  double Fa, Fb, Fc, Faa, Fbb, Fcc, Faaa, Fbbb, Fccc, Faab, Fbbc, Fcca;\n\n  /* volume integrals */\n  double T0 = 0;\n  arma::vec3 T1, T2, TP;\npublic:\n  body_shape(const std::vector&lt;arma::vec3&gt;&amp; verts, const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; faces, const double mass, const double density = 1.0)\n  {\n    m_verts = verts;\n    m_mass = mass;\n    m_density = density;\n    make_polyhedron(faces);\n    compute_volume_integrals();\n  }\n\n  [[nodiscard]] arma::vec3 get_center_of_mass() const {\n    return T1/T0;\n  }\n\n  arma::mat33 get_inertia_tensor()\n  {\n    auto r = get_center_of_mass();\n    arma::mat33 J;\n    double mass = m_density * T0;\n\n    /* compute inertia tensor */\n    J(X, X) = m_density * (T2[Y] + T2[Z]);\n    J(Y, Y) = m_density * (T2[Z] + T2[X]);\n    J(Z, Z) = m_density * (T2[X] + T2[Y]);\n    J(X, Y) = J(Y, X) = - m_density * TP[X];\n    J(Y, Z) = J(Z, Y) = - m_density * TP[Y];\n    J(Z, X) = J(X, Z) = - m_density * TP[Z];\n\n    /* translate inertia tensor to center of mass */\n    J(X, X) -= mass * (r[Y]*r[Y] + r[Z]*r[Z]);\n    J(Y, Y) -= mass * (r[Z]*r[Z] + r[X]*r[X]);\n    J(Z, Z) -= mass * (r[X]*r[X] + r[Y]*r[Y]);\n    J(X, Y) = J(Y, X) += mass * r[X] * r[Y];\n    J(Y, Z) = J(Z, Y) += mass * r[Y] * r[Z];\n    J(Z, X) = J(X, Z) += mass * r[Z] * r[X];\n\n    return J;\n  }\n\n  static body_shape make_rectangle(double l, double w, double h, const double mass, const arma::vec3&amp; origin = {0, 0, 0})\n  {\n    double a = l/2;\n    double b = w/2;\n    double c = h/2;\n\n    std::vector&lt;arma::vec3&gt; verts = {\n      {-a, -b, -c},\n      {a, -b, -c},\n      {a, b, -c},\n      {-a, b, -c},\n      {-a, -b, c},\n      {a, -b, c},\n      {a, b, c},\n      {-a, b, c}\n    };\n\n    std::for_each(verts.begin(), verts.end(), [origin](arma::vec3 v){v += origin;});\n\n    std::vector&lt;std::vector&lt;int&gt;&gt; faces = {\n      {0, 3, 2, 1},\n      {4, 5, 6, 7},\n      {0, 1, 5, 4},\n      {6, 2, 3, 7},\n      {1, 2, 6, 5},\n      {0, 4, 7, 3},\n    };\n\n    return {verts, faces, mass};\n  }\n\nprivate:\n  void make_polyhedron(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; faces)\n  {\n    for (auto f : faces) {\n      /* compute face normal and offset w from first 3 vertices */\n      const arma::vec3 dv1 = m_verts[f[1]] - m_verts[f[0]];\n      const arma::vec3 dv2 = m_verts[f[2]] - m_verts[f[1]];\n      const arma::vec3 normal_vec = cross(dv1, dv2);\n      const arma::vec3 normal = normalise(normal_vec);\n      const double w = -dot(normal, m_verts[f[0]]);\n      m_faces.emplace_back(f, w, normal);\n    }\n  }\n\n  /*\n     ============================================================================\n     compute mass properties\n     ============================================================================\n  */\n\n  /* compute various integrations over projection of face */\n  void compute_projection_integrals(const face&amp; f)\n  {\n    double a0, a1, da;\n    double b0, b1, db;\n    double a0_2, a0_3, a0_4, b0_2, b0_3, b0_4;\n    double a1_2, a1_3, b1_2, b1_3;\n    double C1, Ca, Caa, Caaa, Cb, Cbb, Cbbb;\n    double Cab, Kab, Caab, Kaab, Cabb, Kabb;\n    const std::size_t n_verts = f.verts.size();\n\n    P1 = Pa = Pb = Paa = Pab = Pbb = Paaa = Paab = Pabb = Pbbb = 0.0;\n\n    for (std::size_t i = 0; i &lt; n_verts; i++) {\n      a0 = m_verts[f.verts[i]][A];\n      b0 = m_verts[f.verts[i]][B];\n      a1 = m_verts[f.verts[(i+1) % n_verts]][A];\n      b1 = m_verts[f.verts[(i+1) % n_verts]][B];\n      da = a1 - a0;\n      db = b1 - b0;\n      a0_2 = a0 * a0; a0_3 = a0_2 * a0; a0_4 = a0_3 * a0;\n      b0_2 = b0 * b0; b0_3 = b0_2 * b0; b0_4 = b0_3 * b0;\n      a1_2 = a1 * a1; a1_3 = a1_2 * a1;\n      b1_2 = b1 * b1; b1_3 = b1_2 * b1;\n\n      C1 = a1 + a0;\n      Ca = a1*C1 + a0_2; Caa = a1*Ca + a0_3; Caaa = a1*Caa + a0_4;\n      Cb = b1*(b1 + b0) + b0_2; Cbb = b1*Cb + b0_3; Cbbb = b1*Cbb + b0_4;\n      Cab = 3*a1_2 + 2*a1*a0 + a0_2; Kab = a1_2 + 2*a1*a0 + 3*a0_2;\n      Caab = a0*Cab + 4*a1_3; Kaab = a1*Kab + 4*a0_3;\n      Cabb = 4*b1_3 + 3*b1_2*b0 + 2*b1*b0_2 + b0_3;\n      Kabb = b1_3 + 2*b1_2*b0 + 3*b1*b0_2 + 4*b0_3;\n\n      P1 += db*C1;\n      Pa += db*Ca;\n      Paa += db*Caa;\n      Paaa += db*Caaa;\n      Pb += da*Cb;\n      Pbb += da*Cbb;\n      Pbbb += da*Cbbb;\n      Pab += db*(b1*Cab + b0*Kab);\n      Paab += db*(b1*Caab + b0*Kaab);\n      Pabb += da*(a1*Cabb + a0*Kabb);\n    }\n\n    P1 /= 2.0;\n    Pa /= 6.0;\n    Paa /= 12.0;\n    Paaa /= 20.0;\n    Pb /= -6.0;\n    Pbb /= -12.0;\n    Pbbb /= -20.0;\n    Pab /= 24.0;\n    Paab /= 60.0;\n    Pabb /= -60.0;\n  }\n\n  void compute_face_integrals(face&amp; f)\n  {\n    double k1, k2, k3, k4;\n\n    compute_projection_integrals(f);\n\n    const auto w = f.w;\n    const auto n = f.norm;\n    k1 = 1 / n[C]; k2 = k1 * k1; k3 = k2 * k1; k4 = k3 * k1;\n\n    Fa = k1 * Pa;\n    Fb = k1 * Pb;\n    Fc = -k2 * (n[A]*Pa + n[B]*Pb + w*P1);\n\n    Faa = k1 * Paa;\n    Fbb = k1 * Pbb;\n    Fcc = k3 * (SQR(n[A])*Paa + 2*n[A]*n[B]*Pab + SQR(n[B])*Pbb\n           + w*(2*(n[A]*Pa + n[B]*Pb) + w*P1));\n\n    Faaa = k1 * Paaa;\n    Fbbb = k1 * Pbbb;\n    Fccc = -k4 * (CUBE(n[A])*Paaa + 3*SQR(n[A])*n[B]*Paab\n             + 3*n[A]*SQR(n[B])*Pabb + CUBE(n[B])*Pbbb\n             + 3*w*(SQR(n[A])*Paa + 2*n[A]*n[B]*Pab + SQR(n[B])*Pbb)\n             + w*w*(3*(n[A]*Pa + n[B]*Pb) + w*P1));\n\n    Faab = k1 * Paab;\n    Fbbc = -k2 * (n[A]*Pabb + n[B]*Pbbb + w*Pbb);\n    Fcca = k3 * (SQR(n[A])*Paaa + 2*n[A]*n[B]*Paab + SQR(n[B])*Pabb\n           + w*(2*(n[A]*Paa + n[B]*Pab) + w*Pa));\n  }\n\n  void compute_volume_integrals()\n  {\n\n    for (auto f: m_faces) {\n      const double nx = fabs(f.norm[X]);\n      const double ny = fabs(f.norm[Y]);\n      const double nz = fabs(f.norm[Z]);\n      if (nx &gt; ny &amp;&amp; nx &gt; nz) C = X;\n      else C = ny &gt; nz ? Y : Z;\n      A = (C + 1) % 3;\n      B = (A + 1) % 3;\n\n      compute_face_integrals(f);\n\n      T0 += f.norm[X] * ((A == X) ? Fa : ((B == X) ? Fb : Fc));\n\n      T1[A] += f.norm[A] * Faa;\n      T1[B] += f.norm[B] * Fbb;\n      T1[C] += f.norm[C] * Fcc;\n      T2[A] += f.norm[A] * Faaa;\n      T2[B] += f.norm[B] * Fbbb;\n      T2[C] += f.norm[C] * Fccc;\n      TP[A] += f.norm[A] * Faab;\n      TP[B] += f.norm[B] * Fbbc;\n      TP[C] += f.norm[C] * Fcca;\n    }\n    T1 /= 2.0;\n    T2 /= 3.0;\n    TP /= 2.0;\n  }\n};\n}\n\n#endif //BODY_SHAPE_H\n</code></pre>"},{"location":"naomi/pv__coordinates_8h/","title":"File pv_coordinates.h","text":"<p>FileList &gt; include &gt; spacecraft &gt; pv_coordinates.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;armadillo&gt;</code></li> <li><code>#include &lt;fmt/format.h&gt;</code></li> <li><code>#include &lt;naomi.h&gt;</code></li> </ul>"},{"location":"naomi/pv__coordinates_8h/#classes","title":"Classes","text":"Type Name class pv_coordinates <p>The documentation for this class was generated from the following file <code>include/spacecraft/pv_coordinates.h</code></p>"},{"location":"naomi/pv__coordinates_8h_source/","title":"File pv_coordinates.h","text":"<p>File List &gt; include &gt; spacecraft &gt; pv_coordinates.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/23/2024.\n//\n\n#ifndef PV_COORDINATES_H\n#define PV_COORDINATES_H\n\n#include &lt;armadillo&gt;\n\n#include &lt;fmt/format.h&gt;\n#include &lt;naomi.h&gt;\n\nclass pv_coordinates\n{\n  arma::vec3 _pos;\n  arma::vec3 _vel;\n  arma::vec3 _acc;\n\npublic:\n  explicit pv_coordinates(const naomi::vector_type&amp; state)\n  {\n    if (state.size() == 6) {\n      _pos = state(arma::span(0, 2));\n      _vel = state(arma::span(3, 5));\n    } else if (state.size() == 9) {\n      _pos = state(arma::span(0, 2));\n      _vel = state(arma::span(3, 5));\n      _acc = state(arma::span(6, 8));\n    } else {\n      throw std::runtime_error(\n        fmt::format(\"PV state vector must have size 6 or 9 but was {}\",\n          state.size()));\n    }\n  }\n\n  explicit pv_coordinates(const arma::vec9&amp; state):\n    _pos(state(arma::span(0, 2)))\n  , _vel(state(arma::span(3, 5)))\n  , _acc(state(arma::span(6, 8))){}\n\n\n  [[nodiscard]] auto get_position() const -&gt; arma::vec3\n  {\n    return _pos;\n  }\n\n  [[nodiscard]] auto get_velocity() const -&gt; arma::vec3\n  {\n    return _vel;\n  }\n\n  [[nodiscard]] auto get_acceleration() const -&gt; arma::vec3\n  {\n    return _acc;\n  }\n\n  [[nodiscard]] auto to_vec() const -&gt; naomi::vector_type\n  {\n    const auto pv = join_cols(_pos, _vel);\n    auto pva = join_cols(pv, _acc);\n    return pva;\n  }\n};\n\n#endif //PV_COORDINATES_H\n</code></pre>"},{"location":"naomi/pv__coordinates__provider_8h/","title":"File pv_coordinates_provider.h","text":"<p>FileList &gt; include &gt; spacecraft &gt; pv_coordinates_provider.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"forces/force_model.h\"</code></li> <li><code>#include \"frames/transforms.h\"</code></li> <li><code>#include \"state_provider.h\"</code></li> </ul>"},{"location":"naomi/pv__coordinates__provider_8h/#classes","title":"Classes","text":"Type Name class pv_coordinates_provider <p>The documentation for this class was generated from the following file <code>include/spacecraft/pv_coordinates_provider.h</code></p>"},{"location":"naomi/pv__coordinates__provider_8h_source/","title":"File pv_coordinates_provider.h","text":"<p>File List &gt; include &gt; spacecraft &gt; pv_coordinates_provider.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 7/31/2024.\n//\n\n#ifndef PV_COORDINATES_PROVIDER_H\n#define PV_COORDINATES_PROVIDER_H\n#include \"forces/force_model.h\"\n#include \"frames/transforms.h\"\n#include \"state_provider.h\"\n\nusing namespace naomi;\n\nclass pv_coordinates_provider final\n    :\n  public state_provider,\n  public integrated_provider\n{\n  pv_coordinates _state;\n  std::shared_ptr&lt;naomi::forces::equations_of_motion&gt; _eoms = nullptr;\npublic:\n  explicit pv_coordinates_provider(pv_coordinates initial_state):\n    _state(std::move(initial_state)){}\n  ~pv_coordinates_provider() override = default;\n  pv_coordinates get_pv_coordinates() override { return _state; }\n\n  vector_type get_integrated_state() override\n  {\n    return _state.to_vec();\n  }\n\n  std::size_t get_size() override\n  {\n    return 9;\n  }\n\n  void set_integrated_state(const vector_type&amp; state) override\n  {\n    _state = pv_coordinates(state);\n  }\n\n  std::shared_ptr&lt;forces::equations_of_motion&gt; get_eoms() override\n  {\n    return _eoms;\n  }\n\n  void apply_control(const vector_type&amp; control) override\n  {\n    const auto curr_state = _state.to_vec();\n    const vector_type updated_state = curr_state + control;\n    _state = pv_coordinates(updated_state);\n  }\n};\n\n#endif //PV_COORDINATES_PROVIDER_H\n</code></pre>"},{"location":"naomi/spacecraft_8h/","title":"File spacecraft.h","text":"<p>FileList &gt; include &gt; spacecraft &gt; spacecraft.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"attitude/attitude_provider.h\"</code></li> <li><code>#include \"attitude/constant_attitude_provider.h\"</code></li> <li><code>#include \"body_shape.h\"</code></li> <li><code>#include \"control/controller.h\"</code></li> <li><code>#include \"frames/frame.h\"</code></li> <li><code>#include \"maneuvers/maneuver_plan.h\"</code></li> <li><code>#include \"pv_coordinates.h\"</code></li> <li><code>#include \"pv_coordinates_provider.h\"</code></li> </ul>"},{"location":"naomi/spacecraft_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi"},{"location":"naomi/spacecraft_8h/#classes","title":"Classes","text":"Type Name class spacecraft <p>The documentation for this class was generated from the following file <code>include/spacecraft/spacecraft.h</code></p>"},{"location":"naomi/spacecraft_8h_source/","title":"File spacecraft.h","text":"<p>File List &gt; include &gt; spacecraft &gt; spacecraft.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 5/25/2024.\n//\n\n#ifndef SPACECRAFT_H\n#define SPACECRAFT_H\n#include &lt;utility&gt;\n\n#include \"attitude/attitude_provider.h\"\n#include \"attitude/constant_attitude_provider.h\"\n#include \"body_shape.h\"\n#include \"control/controller.h\"\n#include \"frames/frame.h\"\n#include \"maneuvers/maneuver_plan.h\"\n#include \"pv_coordinates.h\"\n#include \"pv_coordinates_provider.h\"\n\nnamespace naomi {\n\nusing namespace naomi::control;\nusing namespace naomi::attitude;\nusing namespace naomi::geometry;\n\n\nclass spacecraft\n{\n  std::string m_identifier;\n  pv_coordinates m_pv_coordinates;\n  quaternion_type m_attitude = {1, 0, 0, 0};\n  std::shared_ptr&lt;attitude_provider&gt; _attitude_provider;\n  std::shared_ptr&lt;maneuvers::maneuver_plan&gt; m_maneuver_plan;\n  body_shape m_body_shape = body_shape::make_rectangle(1, 1, 1, 100);\n  spacecraft_state _state;\n\npublic:\n  spacecraft(std::string identifier, const vector_type&amp; state, const double&amp; mass):\n    m_identifier(std::move(identifier)),\n    m_pv_coordinates(state),\n    _attitude_provider(std::make_shared&lt;constant_attitude_provider&gt;()),\n    _state(\n      std::make_shared&lt;pv_coordinates_provider&gt;(pv_coordinates(state)),\n      std::make_shared&lt;constant_attitude_provider&gt;(),\n      mass\n    ){}\n\n  spacecraft(std::string identifier, const vector_type&amp; state, const double&amp; mass, const std::shared_ptr&lt;attitude_provider&gt;&amp; attitude_provider):\n    m_identifier(std::move(identifier)),\n    m_pv_coordinates(state),\n    _state(\n      std::make_shared&lt;pv_coordinates_provider&gt;(pv_coordinates(state)),\n      attitude_provider,\n      mass ),\n    _attitude_provider(attitude_provider){}\n\n  spacecraft(std::string identifier, const vector_type&amp; state, const double&amp; mass, const std::shared_ptr&lt;maneuvers::maneuver_plan&gt;&amp; mp):\n    m_identifier(std::move(identifier)),\n    m_pv_coordinates(state),\n    _state(\n      std::make_shared&lt;pv_coordinates_provider&gt;(pv_coordinates(state)),\n      std::make_shared&lt;constant_attitude_provider&gt;(),\n      mass),\n    _attitude_provider(std::make_shared&lt;constant_attitude_provider&gt;()),\n    m_maneuver_plan(mp) {}\n\n  auto get_state() -&gt; spacecraft_state\n  {\n    return _state;\n  }\n\n  [[nodiscard]] auto get_pv_coordinates(const std::shared_ptr&lt;frames::frame&gt;&amp; frame = nullptr)\n      -&gt; pv_coordinates\n  {\n    return _state.get_state_provider()-&gt;get_pv_coordinates();\n  }\n\n  [[nodiscard]] auto get_attitude() const -&gt; quaternion_type\n  {\n    return _attitude_provider-&gt;get_rotation();\n  }\n\n  auto get_inertia_matrix() -&gt; arma::mat33\n  {\n    return m_body_shape.get_inertia_tensor();\n  }\n\n\n  [[nodiscard]] auto get_identifier() const -&gt; std::string\n  {\n    return m_identifier;\n  }\n\n  auto get_identifier() -&gt; std::string\n  {\n    return m_identifier;\n  }\n\n  void set_attitude(const quaternion_type&amp; attitude)\n  {\n    m_attitude = attitude;\n  }\n\n  auto get_maneuver_plan() -&gt; std::shared_ptr&lt;maneuvers::maneuver_plan&gt;\n  {\n    return m_maneuver_plan;\n  }\n\n  void update(const double dt)\n  {\n    if (m_maneuver_plan != nullptr) {\n      const auto control_inp = m_maneuver_plan-&gt;get_control_input(dt, _state);\n      _state.get_state_provider()-&gt;apply_control(control_inp);\n    }\n  }\n};\n}\n\n#endif //SPACECRAFT_H\n</code></pre>"},{"location":"naomi/spacecraft__state_8h/","title":"File spacecraft_state.h","text":"<p>FileList &gt; include &gt; spacecraft &gt; spacecraft_state.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"attitude/attitude_provider.h\"</code></li> <li><code>#include \"state_provider.h\"</code></li> </ul>"},{"location":"naomi/spacecraft__state_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi"},{"location":"naomi/spacecraft__state_8h/#classes","title":"Classes","text":"Type Name class mass_provider class spacecraft_state <p>The documentation for this class was generated from the following file <code>include/spacecraft/spacecraft_state.h</code></p>"},{"location":"naomi/spacecraft__state_8h_source/","title":"File spacecraft_state.h","text":"<p>File List &gt; include &gt; spacecraft &gt; spacecraft_state.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex on 7/21/2024.\n//\n\n#ifndef SPACECRAFT_STATE_H\n#define SPACECRAFT_STATE_H\n#include &lt;utility&gt;\n\n#include \"attitude/attitude_provider.h\"\n#include \"state_provider.h\"\n\nnamespace naomi\n{\nusing namespace attitude;\n\nclass mass_provider\n{\n\n};\n\nclass spacecraft_state\n{\n  std::shared_ptr&lt;state_provider&gt; _state_provider;\n  std::shared_ptr&lt;attitude_provider&gt; _attitude_provider;\n  double _mass;\n  std::vector&lt;\n      std::pair&lt;\n        arma::span,\n        std::shared_ptr&lt;integrated_provider&gt;\n      &gt;\n    &gt; _integrated_state_idxs = {};\n\n  std::vector&lt;std::shared_ptr&lt;integrated_provider&gt;&gt; get_integrated_providers()\n      const\n  {\n    std::vector&lt;std::shared_ptr&lt;integrated_provider&gt;&gt; integrated_providers;\n    const std::shared_ptr&lt;integrated_provider&gt; int_state_provider =\n        std::dynamic_pointer_cast&lt;integrated_provider&gt;(_state_provider);\n    const std::shared_ptr&lt;integrated_provider&gt; int_attitude_provider =\n        std::dynamic_pointer_cast&lt;integrated_provider&gt;(_attitude_provider);\n\n    if (int_state_provider != nullptr) {\n      integrated_providers.push_back(int_state_provider);\n    }\n    if (int_attitude_provider != nullptr) {\n      integrated_providers.push_back(int_attitude_provider);\n    }\n    return integrated_providers;\n  }\n\npublic:\n  spacecraft_state(\n      const std::shared_ptr&lt;state_provider&gt;&amp; state_provider,\n      const std::shared_ptr&lt;attitude_provider&gt;&amp; attitude_provider,\n      const double mass)\n      : _state_provider(state_provider)\n      , _attitude_provider(attitude_provider)\n      , _mass(mass)\n  {\n    _integrated_state_idxs = get_provider_mapping();\n    _integrated_state_idxs = get_provider_mapping();\n  }\n\n  std::shared_ptr&lt;state_provider&gt; get_state_provider()\n  {\n    return _state_provider;\n  }\n\n  std::shared_ptr&lt;attitude_provider&gt; get_attitude_provider()\n  {\n    return _attitude_provider;\n  }\n\n  std::vector&lt;std::pair&lt;arma::span, std::shared_ptr&lt;integrated_provider&gt;&gt;&gt; get_provider_mapping()\n  {\n    auto integrated_providers = get_integrated_providers();\n    std::size_t start_idx = 0;\n    vector_type state;\n    std::vector&lt;\n      std::pair&lt;\n        arma::span,\n        std::shared_ptr&lt;integrated_provider&gt;\n      &gt;\n    &gt; new_idxs;\n    for (const auto&amp; provider : integrated_providers) {\n      const auto size = provider-&gt;get_size();\n      const auto end_idx = start_idx + size;\n      const auto prov_span = arma::span(start_idx, end_idx - 1);\n      new_idxs.emplace_back(prov_span, provider);\n      start_idx = end_idx;\n    }\n    _integrated_state_idxs = new_idxs;\n    return _integrated_state_idxs;\n  }\n\n  vector_type get_integrated_state()\n  {\n    vector_type state;\n    for (const auto&amp; [spn, prv] : _integrated_state_idxs) {\n      auto int_state = prv-&gt;get_integrated_state();\n      state.insert_rows(spn.a, int_state);\n    }\n    return state;\n  }\n\n  void set_integrated_state(const vector_type&amp; state)\n  {\n    for (const auto&amp; [spn, prv] : _integrated_state_idxs) {\n      prv-&gt;set_integrated_state(state(spn));\n    }\n  }\n};\n\n}\n#endif //SPACECRAFT_STATE_H\n</code></pre>"},{"location":"naomi/spacecraft__subsystem_8h/","title":"File spacecraft_subsystem.h","text":"<p>FileList &gt; include &gt; spacecraft &gt; spacecraft_subsystem.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include \"attitude/attitude_provider.h\"</code></li> <li><code>#include \"spacecraft_state.h\"</code></li> </ul>"},{"location":"naomi/spacecraft__subsystem_8h/#classes","title":"Classes","text":"Type Name class spacecraft_subsystem class spacecraft_subsystem_state <p>The documentation for this class was generated from the following file <code>include/spacecraft/spacecraft_subsystem.h</code></p>"},{"location":"naomi/spacecraft__subsystem_8h_source/","title":"File spacecraft_subsystem.h","text":"<p>File List &gt; include &gt; spacecraft &gt; spacecraft_subsystem.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 7/24/2024.\n//\n\n#ifndef SPACECRAFT_SUBSYSTEM_H\n#define SPACECRAFT_SUBSYSTEM_H\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n\n#include \"attitude/attitude_provider.h\"\n#include \"spacecraft_state.h\"\n\nclass spacecraft_subsystem_state\n{\n\n};\n\nclass spacecraft_subsystem: simulation_component&lt;spacecraft_state&gt;\n{\n  std::string _name;\n\npublic:\n  ~spacecraft_subsystem() override = default;\n  explicit spacecraft_subsystem(std::string name): _name(std::move(name)){}\n  auto get_name() const -&gt; std::string\n  {\n    return _name;\n  }\n  virtual std::vector&lt;std::shared_ptr&lt;attitude::additional_state_provider&gt;&gt; get_additional_state_providers()\n  {\n    return {};\n  };\n};\n\n\n#endif //SPACECRAFT_SUBSYSTEM_H\n</code></pre>"},{"location":"naomi/state__provider_8h/","title":"File state_provider.h","text":"<p>FileList &gt; include &gt; spacecraft &gt; state_provider.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"forces/force_model.h\"</code></li> <li><code>#include \"pv_coordinates.h\"</code></li> </ul>"},{"location":"naomi/state__provider_8h/#classes","title":"Classes","text":"Type Name class integrated_provider class state_provider <p>The documentation for this class was generated from the following file <code>include/spacecraft/state_provider.h</code></p>"},{"location":"naomi/state__provider_8h_source/","title":"File state_provider.h","text":"<p>File List &gt; include &gt; spacecraft &gt; state_provider.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 7/31/2024.\n//\n\n#ifndef STATE_PROVIDER_H\n#define STATE_PROVIDER_H\n\n#include \"forces/force_model.h\"\n#include \"pv_coordinates.h\"\n\nclass state_provider\n{\npublic:\n  virtual ~state_provider() = default;\n  [[nodiscard]] virtual pv_coordinates get_pv_coordinates() = 0;\n  virtual void apply_control(const naomi::vector_type&amp; control) = 0;\n};\n\nclass integrated_provider\n{\npublic:\n  virtual ~integrated_provider() = default;\n  virtual std::shared_ptr&lt;naomi::forces::equations_of_motion&gt; get_eoms() = 0;\n  [[nodiscard]] virtual std::size_t get_size() = 0;\n  [[nodiscard]] virtual naomi::vector_type get_integrated_state() = 0;\n  virtual void set_integrated_state(const naomi::vector_type&amp; state) = 0;\n};\n\n\n\n#endif //STATE_PROVIDER_H\n</code></pre>"},{"location":"naomi/dir_3c04bc290434a2bfff240c0777e37105/","title":"Dir include/systems","text":"<p>FileList &gt; include &gt; systems</p>"},{"location":"naomi/dir_3c04bc290434a2bfff240c0777e37105/#files","title":"Files","text":"Type Name file system.h file two_body.h <p>The documentation for this class was generated from the following file <code>include/systems/</code></p>"},{"location":"naomi/system_8h/","title":"File system.h","text":"<p>FileList &gt; include &gt; systems &gt; system.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;spacecraft/spacecraft.h&gt;</code></li> <li><code>#include \"forces/force_model.h\"</code></li> <li><code>#include &lt;fmt/core.h&gt;</code></li> </ul>"},{"location":"naomi/system_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi"},{"location":"naomi/system_8h/#classes","title":"Classes","text":"Type Name class physical_system &lt;typename Propagator&gt;A <code>physical_system</code> contains the force model definitions of the system to be simulated, the spacecrafts that exist within the system, and the propagator that will be used to integrate the dynamics. <p>The documentation for this class was generated from the following file <code>include/systems/system.h</code></p>"},{"location":"naomi/system_8h_source/","title":"File system.h","text":"<p>File List &gt; include &gt; systems &gt; system.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 6/16/2024.\n//\n\n#ifndef SYSTEM_H\n#define SYSTEM_H\n\n#include &lt;utility&gt;\n#include &lt;spacecraft/spacecraft.h&gt;\n#include \"forces/force_model.h\"\n#include &lt;fmt/core.h&gt;\n\nnamespace naomi\n{\nusing namespace forces;\n\ntemplate &lt;typename Propagator&gt;\nclass physical_system\n{\n  std::map&lt;std::string, std::shared_ptr&lt;spacecraft&gt;&gt; m_spacecrafts;\n  std::shared_ptr&lt;equations_of_motion&gt; _system_eoms;\n  Propagator m_propagator;\n\n  double m_t = 0;\n  // A system is made up of a central body and some number of additional perturbing bodies\n  // It can have one or many spacecraft\n  // fidelity defined at the system level\npublic:\n  physical_system(const spacecraft&amp; spacecraft, const std::shared_ptr&lt;equations_of_motion&gt;&amp; system_eoms): physical_system({spacecraft}, system_eoms){\n  }\n\n  physical_system(const std::shared_ptr&lt;spacecraft&gt;&amp; spacecraft, const std::shared_ptr&lt;equations_of_motion&gt;&amp; system_eoms): physical_system({spacecraft}, system_eoms){\n  }\n\n  physical_system(const std::initializer_list&lt;spacecraft&gt;&amp; spacecrafts, const std::shared_ptr&lt;equations_of_motion&gt;&amp; system_eoms):\n    _system_eoms(system_eoms)\n  {\n    for (const spacecraft&amp; s: spacecrafts) {\n      m_spacecrafts[s.get_identifier()] = std::make_shared&lt;spacecraft&gt;(s);\n    }\n    m_propagator.initialize(_system_eoms, m_spacecrafts);\n  }\n\n  physical_system(const std::initializer_list&lt;std::shared_ptr&lt;spacecraft&gt;&gt;&amp; spacecrafts, const std::shared_ptr&lt;equations_of_motion&gt;&amp; system_eoms):\n  _system_eoms(system_eoms)\n  {\n    for (const std::shared_ptr&lt;spacecraft&gt;&amp; s: spacecrafts) {\n      m_spacecrafts[s-&gt;get_identifier()] = s;\n    }\n    m_propagator.initialize(_system_eoms, m_spacecrafts);\n  }\n\n  auto get_spacecraft(const std::string&amp; scid) -&gt; std::shared_ptr&lt;spacecraft&gt;\n  {\n    return m_spacecrafts[scid];\n  }\n\n  auto get_spacecrafts() -&gt; std::map&lt;std::string, std::shared_ptr&lt;spacecraft&gt;&gt;\n  {\n    return m_spacecrafts;\n  }\n\n  [[nodiscard]] auto get_current_time() const -&gt; double\n  {\n    return m_t;\n  }\n\n  void simulate_by(double dt)\n  {\n    m_t = m_propagator.propagate_by(dt);\n  }\n\n  double simulate_to(double dt)\n  {\n    // fmt::print(\"Simulating to: {}\\n\", dt);\n    m_t = m_propagator.propagate_to(dt);\n    return m_t;\n  }\n};\n}\n\n#endif //SYSTEM_H\n</code></pre>"},{"location":"naomi/two__body_8h/","title":"File two_body.h","text":"<p>FileList &gt; include &gt; systems &gt; two_body.h</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>include/systems/two_body.h</code></p>"},{"location":"naomi/two__body_8h_source/","title":"File two_body.h","text":"<p>File List &gt; include &gt; systems &gt; two_body.h</p> <p>Go to the documentation of this file</p> <pre><code>//\n// Created by alex_ on 5/28/2024.\n//\n\n#ifndef TWO_BODY_H\n#define TWO_BODY_H\n\n// #include \"spacecraft/state_vector.h\"\n// #include \"bodies/celestial_body.h\"\n// #include \"spacecraft/spacecraft.h\"\n//\n// class two_body_system\n// {\n//   std::vector&lt;spacecraft&gt; m_spacecraft;\n//   // combined_state_vector m_states;\n//   double m_mu;\n//   std::shared_ptr&lt;celestial_body&gt; m_central_body;\n//\n// public:\n//\n//   two_body_system(const spacecraft&amp; spacecraft, const double&amp; mu, std::shared_ptr&lt;celestial_body&gt;&amp; central_body):\n//     m_spacecraft({spacecraft}), m_mu(mu), m_central_body(central_body)\n//   {\n//     // for (auto &amp; i : m_spacecraft) {\n//     //   m_states.add_state_vector( i.get_state());\n//     // }\n//   }\n//\n//   two_body_system(const std::vector&lt;spacecraft&gt;&amp; spacecraft, const double&amp; mu, std::shared_ptr&lt;celestial_body&gt;&amp; central_body):\n//       m_spacecraft(spacecraft), m_mu(mu), m_central_body(central_body)\n//   {\n//     // for (int i = 0; i &lt; m_spacecraft.size(); ++i) {\n//     //   m_states.add_state_vector( m_spacecraft[i].get_state());\n//     // }\n//   }\n//\n//   auto get_state() -&gt; state_type&amp;\n//   {\n//     return m_spacecraft[0].get_state();\n//   }\n//\n//   auto set_state(state_type&amp; state)\n//   {\n//     m_spacecraft[0].set_state(state);\n//   }\n//\n//\n//   auto get_spacecrafts() -&gt; std::vector&lt;spacecraft&gt;\n//   {\n//     return m_spacecraft;\n//   }\n//\n//\n//   void operator()( const state_type&amp; x , state_type&amp; dxdt, const double t) const\n//   {\n//     arma::vec3 pos = x.subvec(0, 2);\n//     arma::vec3 vel = x.subvec(3, 5);\n//     arma::vec3 rddot = m_central_body-&gt;get_potential_partial(pos);\n//     for (std::size_t i = 0; i &lt; pos.size(); ++i) {\n//       rddot[i] *= -1.0;\n//     }\n//     dxdt(arma::span(0, 2)) = vel;\n//     dxdt(arma::span(3, 5)) = rddot;\n//   }\n// };\n#endif //TWO_BODY_H\n</code></pre>"},{"location":"naomi/naomi_8h/","title":"File naomi.h","text":"<p>FileList &gt; include &gt; naomi.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;Eigen/Core&gt;</code></li> <li><code>#include &lt;Eigen/Dense&gt;</code></li> <li><code>#include \"boost/numeric/odeint/stepper/runge_kutta4.hpp\"</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;armadillo&gt;</code></li> </ul>"},{"location":"naomi/naomi_8h/#namespaces","title":"Namespaces","text":"Type Name namespace naomi"},{"location":"naomi/naomi_8h/#macros","title":"Macros","text":"Type Name define NAOMI_EXPORT"},{"location":"naomi/naomi_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"naomi/naomi_8h/#define-naomi_export","title":"define NAOMI_EXPORT","text":"<pre><code>#define NAOMI_EXPORT \n</code></pre> <p>The documentation for this class was generated from the following file <code>include/naomi.h</code></p>"},{"location":"naomi/naomi_8h_source/","title":"File naomi.h","text":"<p>File List &gt; include &gt; naomi.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include &lt;Eigen/Core&gt;\n#include &lt;Eigen/Dense&gt;\n#include \"boost/numeric/odeint/stepper/runge_kutta4.hpp\"\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\n\n\n#ifdef _WIN32\n  #define NAOMI_EXPORT __declspec(dllexport)\n#else\n  #define NAOMI_EXPORT\n#endif\n\n// class state_vector;\n#include &lt;armadillo&gt;\n// NAOMI_EXPORT void naomi();\n// NAOMI_EXPORT void naomi_print_vector(const std::vector&lt;std::string&gt; &amp;strings);\n\nnamespace naomi\n{\ntypedef arma::vec vector_type;\ntypedef arma::vec6 pv_state_type;\ntypedef arma::vec9 pva_state_type;\ntypedef arma::vec4 quaternion_type;\ntypedef arma::vec::fixed&lt;10&gt; pv_rot_state_type;\ntypedef arma::vec::fixed&lt;13&gt; pva_rot_state_type;\n}\n</code></pre>"},{"location":"naomi/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace naomi <ul> <li>namespace attitude </li> <li>namespace bodies </li> <li>namespace constants </li> <li>namespace control </li> <li>namespace events </li> <li>namespace forces </li> <li>namespace frames </li> <li>namespace geometry </li> <li>namespace maneuvers </li> <li>namespace math <ul> <li>namespace quaternion </li> </ul> </li> <li>namespace numeric </li> <li>namespace observers </li> <li>namespace orbits </li> </ul> </li> </ul>"},{"location":"naomi/classes/","title":"Class Index","text":""},{"location":"naomi/classes/#a","title":"a","text":"<ul> <li>additional_state_provider (naomi::attitude)</li> <li>angular_coordinates</li> <li>apside_detector (naomi::events)</li> <li>attitude_provider (naomi::attitude)</li> </ul>"},{"location":"naomi/classes/#b","title":"b","text":"<ul> <li>bielliptic_hohmann_transfer (naomi::maneuvers)</li> <li>body_shape (naomi::geometry)</li> </ul>"},{"location":"naomi/classes/#c","title":"c","text":"<ul> <li>cartesian_orbit (naomi::orbits)</li> <li>celestial_body (naomi::bodies)</li> <li>constant_attitude_provider (naomi::attitude)</li> <li>control_input (naomi::control)</li> <li>controller (naomi::control)</li> </ul>"},{"location":"naomi/classes/#e","title":"e","text":"<ul> <li>earth (naomi::bodies)</li> <li>eccentric_anomaly_functor (naomi::orbits)</li> <li>equations_of_motion (naomi::forces)</li> <li>euler_angles (naomi::attitude)</li> <li>event (naomi::events)</li> <li>event_detector (naomi::events)</li> <li>event_detector_condition (naomi::events)</li> <li>event_handler (naomi::events)</li> </ul>"},{"location":"naomi/classes/#f","title":"f","text":"<ul> <li>face (naomi::geometry)</li> <li>force_model (naomi::forces)</li> <li>frame (naomi::frames)</li> </ul>"},{"location":"naomi/classes/#h","title":"h","text":"<ul> <li>hohmann_transfer (naomi::maneuvers)</li> </ul>"},{"location":"naomi/classes/#i","title":"i","text":"<ul> <li>integrated_provider</li> <li>integrator (naomi::numeric)</li> </ul>"},{"location":"naomi/classes/#k","title":"k","text":"<ul> <li>keplerian_orbit (naomi::orbits)</li> </ul>"},{"location":"naomi/classes/#m","title":"m","text":"<ul> <li>maneuver (naomi::maneuvers)</li> <li>maneuver_plan (naomi::maneuvers)</li> <li>mass_provider (naomi)</li> </ul>"},{"location":"naomi/classes/#n","title":"n","text":"<ul> <li>nadir_pointing_pid_controller (naomi::control)</li> <li>no_such_maneuver_exception (naomi::maneuvers)</li> <li>numerical_propagator (naomi::numeric)</li> </ul>"},{"location":"naomi/classes/#p","title":"p","text":"<ul> <li>physical_system (naomi)</li> <li>pid_controller (naomi::control)</li> <li>pv_coordinates</li> <li>pv_coordinates_provider</li> </ul>"},{"location":"naomi/classes/#r","title":"r","text":"<ul> <li>results_csv_writer_observer (naomi::observers)</li> <li>rotation (naomi::attitude)</li> </ul>"},{"location":"naomi/classes/#s","title":"s","text":"<ul> <li>simulation (naomi)</li> <li>simulation_component (naomi)</li> <li>simulation_observer (naomi::observers)</li> <li>spacecraft (naomi)</li> <li>spacecraft_attitude_subsystem</li> <li>spacecraft_state (naomi)</li> <li>spacecraft_subsystem</li> <li>spacecraft_subsystem_state</li> <li>state_provider</li> </ul>"},{"location":"naomi/classes/#t","title":"t","text":"<ul> <li>time_detector (naomi::events)</li> <li>torque_free_attitude_provider</li> <li>torque_free_eoms (naomi::attitude)</li> <li>two_body_force_model (naomi::forces)</li> <li>two_body_force_model_eoms (naomi::forces)</li> <li>two_body_rot_force_model (naomi::forces)</li> </ul>"},{"location":"naomi/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class angular_coordinates </li> <li>class integrated_provider <ul> <li>class pv_coordinates_provider </li> <li>class torque_free_attitude_provider </li> </ul> </li> <li>class naomi::attitude::additional_state_provider </li> <li>class naomi::attitude::attitude_provider <ul> <li>class naomi::attitude::constant_attitude_provider </li> <li>class torque_free_attitude_provider </li> </ul> </li> <li>class naomi::attitude::rotation <ul> <li>class naomi::attitude::euler_angles </li> </ul> </li> <li>class naomi::forces::equations_of_motion <ul> <li>class naomi::attitude::torque_free_eoms </li> <li>class naomi::forces::two_body_force_model_eoms </li> </ul> </li> <li>class naomi::bodies::celestial_body <ul> <li>class naomi::bodies::earth </li> </ul> </li> <li>class naomi::control::control_input </li> <li>class naomi::control::controller <ul> <li>class naomi::control::pid_controller <ul> <li>class naomi::control::nadir_pointing_pid_controller </li> </ul> </li> </ul> </li> <li>class naomi::events::event_detector <ul> <li>class naomi::events::apside_detector </li> <li>class naomi::events::time_detector </li> <li>class naomi::maneuvers::maneuver_plan </li> </ul> </li> <li>class naomi::events::event_handler </li> <li>class naomi::forces::force_model <ul> <li>class naomi::forces::two_body_force_model </li> <li>class naomi::forces::two_body_rot_force_model </li> </ul> </li> <li>class naomi::frames::frame </li> <li>class naomi::geometry::body_shape </li> <li>class naomi::maneuvers::bielliptic_hohmann_transfer </li> <li>class naomi::maneuvers::hohmann_transfer A class to compute the optimal burns for a Hohmann Transfer using equations as described by orbital-mechanics.space .</li> <li>class naomi::maneuvers::maneuver </li> <li>class naomi::mass_provider </li> <li>class naomi::numeric::integrator </li> <li>class naomi::numeric::numerical_propagator </li> <li>class naomi::observers::simulation_observer <ul> <li>class naomi::observers::results_csv_writer_observer </li> </ul> </li> <li>class naomi::orbits::cartesian_orbit </li> <li>class naomi::orbits::keplerian_orbit </li> <li>class naomi::physical_system A <code>physical_system</code> contains the force model definitions of the system to be simulated, the spacecrafts that exist within the system, and the propagator that will be used to integrate the dynamics.</li> <li>class naomi::simulation </li> <li>class naomi::simulation_component </li> <li>class naomi::spacecraft </li> <li>class naomi::spacecraft_state </li> <li>class pv_coordinates </li> <li>class state_provider <ul> <li>class pv_coordinates_provider </li> </ul> </li> <li>class spacecraft_subsystem_state </li> <li>struct naomi::events::event </li> <li>struct naomi::events::event_detector_condition </li> <li>struct naomi::geometry::face </li> <li>struct naomi::orbits::eccentric_anomaly_functor </li> <li>class std::exception <ul> <li>class naomi::maneuvers::no_such_maneuver_exception </li> </ul> </li> <li>class simulation_component&lt; spacecraft_state &gt; <ul> <li>class spacecraft_subsystem <ul> <li>class spacecraft_attitude_subsystem </li> </ul> </li> <li>class spacecraft_subsystem <ul> <li>class spacecraft_attitude_subsystem </li> </ul> </li> </ul> </li> </ul>"},{"location":"naomi/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"naomi/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"naomi/class_members/","title":"Class Members","text":""},{"location":"naomi/class_members/#a","title":"a","text":"<ul> <li>angular_coordinates (angular_coordinates)</li> <li>additional_state_provider (naomi::attitude::additional_state_provider)</li> <li>apply_force (naomi::attitude::attitude_provider, naomi::attitude::constant_attitude_provider, torque_free_attitude_provider)</li> <li>apply_to (naomi::attitude::euler_angles, naomi::attitude::rotation)</li> <li>a_j2 (naomi::bodies::earth)</li> <li>apside_detector (naomi::events::apside_detector)</li> <li>A (naomi::geometry::body_shape)</li> <li>apply_control (pv_coordinates_provider, state_provider)</li> </ul>"},{"location":"naomi/class_members/#b","title":"b","text":"<ul> <li>B (naomi::geometry::body_shape)</li> <li>body_shape (naomi::geometry::body_shape)</li> <li>bielliptic_hohmann_transfer (naomi::maneuvers::bielliptic_hohmann_transfer)</li> </ul>"},{"location":"naomi/class_members/#c","title":"c","text":"<ul> <li>constant_attitude_provider (naomi::attitude::constant_attitude_provider)</li> <li>celestial_body (naomi::bodies::celestial_body)</li> <li>control_input (naomi::control::control_input)</li> <li>C (naomi::geometry::body_shape)</li> <li>compute_face_integrals (naomi::geometry::body_shape)</li> <li>compute_projection_integrals (naomi::geometry::body_shape)</li> <li>compute_volume_integrals (naomi::geometry::body_shape)</li> <li>check_events (naomi::numeric::numerical_propagator)</li> <li>cartesian_orbit (naomi::orbits::cartesian_orbit)</li> <li>compute_eccentricity (naomi::orbits::keplerian_orbit)</li> <li>compute_angular_velocity (torque_free_attitude_provider)</li> </ul>"},{"location":"naomi/class_members/#d","title":"d","text":"<ul> <li>detector (naomi::events::event)</li> <li>deg2rad (naomi::orbits::keplerian_orbit)</li> </ul>"},{"location":"naomi/class_members/#e","title":"e","text":"<ul> <li>euler_angles (naomi::attitude::euler_angles)</li> <li>earth (naomi::bodies::earth)</li> <li>earth_j2 (naomi::bodies::earth)</li> <li>earth_radius (naomi::bodies::earth)</li> <li>event_detector (naomi::events::event_detector)</li> <li>event_detector_condition (naomi::events::event_detector_condition)</li> <li>execute_maneuver (naomi::maneuvers::maneuver_plan)</li> <li>eccentric_anomaly_functor (naomi::orbits::eccentric_anomaly_functor)</li> </ul>"},{"location":"naomi/class_members/#f","title":"f","text":"<ul> <li>Fa (naomi::geometry::body_shape)</li> <li>Faa (naomi::geometry::body_shape)</li> <li>Faaa (naomi::geometry::body_shape)</li> <li>Faab (naomi::geometry::body_shape)</li> <li>Fb (naomi::geometry::body_shape)</li> <li>Fbb (naomi::geometry::body_shape)</li> <li>Fbbb (naomi::geometry::body_shape)</li> <li>Fbbc (naomi::geometry::body_shape)</li> <li>Fc (naomi::geometry::body_shape)</li> <li>Fcc (naomi::geometry::body_shape)</li> <li>Fcca (naomi::geometry::body_shape)</li> <li>Fccc (naomi::geometry::body_shape)</li> <li>face (naomi::geometry::face)</li> <li>find_event_time (naomi::numeric::integrator)</li> <li>fn (naomi::orbits::keplerian_orbit)</li> <li>from_cartesian (naomi::orbits::keplerian_orbit)</li> </ul>"},{"location":"naomi/class_members/#g","title":"g","text":"<ul> <li>get_rotation (angular_coordinates, naomi::attitude::attitude_provider, naomi::attitude::constant_attitude_provider, torque_free_attitude_provider)</li> <li>get_eoms (integrated_provider, pv_coordinates_provider, torque_free_attitude_provider)</li> <li>get_integrated_state (integrated_provider, naomi::spacecraft_state, pv_coordinates_provider, torque_free_attitude_provider)</li> <li>get_size (integrated_provider, naomi::attitude::additional_state_provider, pv_coordinates_provider, torque_free_attitude_provider)</li> <li>get_derivative (naomi::attitude::additional_state_provider, naomi::attitude::torque_free_eoms, naomi::forces::equations_of_motion, naomi::forces::two_body_force_model_eoms)</li> <li>get_name (naomi::attitude::additional_state_provider, spacecraft_subsystem)</li> <li>get_state (naomi::attitude::additional_state_provider, naomi::spacecraft)</li> <li>get_angular_momentum (naomi::attitude::attitude_provider, naomi::attitude::constant_attitude_provider, torque_free_attitude_provider)</li> <li>get_angular_velocity (naomi::attitude::attitude_provider, naomi::attitude::constant_attitude_provider, torque_free_attitude_provider)</li> <li>get_axis_rotation (naomi::attitude::euler_angles)</li> <li>get_dcm (naomi::attitude::euler_angles, naomi::attitude::rotation)</li> <li>get_mu (naomi::bodies::celestial_body)</li> <li>get_potential (naomi::bodies::celestial_body)</li> <li>get_potential_partial (naomi::bodies::celestial_body)</li> <li>get_potential_partial_derivative (naomi::bodies::celestial_body, naomi::bodies::earth)</li> <li>get_sphere_of_influence (naomi::bodies::celestial_body)</li> <li>get_control_input (naomi::control::controller, naomi::control::pid_controller, naomi::maneuvers::maneuver, naomi::maneuvers::maneuver_plan)</li> <li>get_desired_state (naomi::control::controller, naomi::control::nadir_pointing_pid_controller)</li> <li>g (naomi::events::apside_detector, naomi::events::event_detector, naomi::events::time_detector, naomi::maneuvers::maneuver_plan)</li> <li>get_transform_to (naomi::frames::frame)</li> <li>get_center_of_mass (naomi::geometry::body_shape)</li> <li>get_inertia_tensor (naomi::geometry::body_shape)</li> <li>get_dvs (naomi::maneuvers::bielliptic_hohmann_transfer, naomi::maneuvers::hohmann_transfer)</li> <li>get_maneuver_plan (naomi::maneuvers::bielliptic_hohmann_transfer, naomi::maneuvers::hohmann_transfer, naomi::spacecraft)</li> <li>get_total_dv (naomi::maneuvers::bielliptic_hohmann_transfer, naomi::maneuvers::hohmann_transfer)</li> <li>get_transit_time (naomi::maneuvers::bielliptic_hohmann_transfer, naomi::maneuvers::hohmann_transfer)</li> <li>get_delta_v (naomi::maneuvers::maneuver)</li> <li>get_delta_v_mag (naomi::maneuvers::maneuver)</li> <li>get_direction (naomi::maneuvers::maneuver)</li> <li>get_trigger (naomi::maneuvers::maneuver)</li> <li>get_maneuvers (naomi::maneuvers::maneuver_plan)</li> <li>get_total_delta_v (naomi::maneuvers::maneuver_plan)</li> <li>get_integration_times (naomi::numeric::numerical_propagator)</li> <li>get_next_update (naomi::observers::simulation_observer, naomi::simulation)</li> <li>get_position (naomi::orbits::cartesian_orbit, pv_coordinates)</li> <li>get_velocity (naomi::orbits::cartesian_orbit, pv_coordinates)</li> <li>get_a (naomi::orbits::keplerian_orbit)</li> <li>get_anomaly (naomi::orbits::keplerian_orbit)</li> <li>get_aop (naomi::orbits::keplerian_orbit)</li> <li>get_e (naomi::orbits::keplerian_orbit)</li> <li>get_eccentric_anomaly (naomi::orbits::keplerian_orbit)</li> <li>get_i (naomi::orbits::keplerian_orbit)</li> <li>get_orbital_period (naomi::orbits::keplerian_orbit)</li> <li>get_raan (naomi::orbits::keplerian_orbit)</li> <li>get_current_time (naomi::physical_system)</li> <li>get_spacecraft (naomi::physical_system)</li> <li>get_spacecrafts (naomi::physical_system)</li> <li>get_attitude (naomi::spacecraft)</li> <li>get_identifier (naomi::spacecraft)</li> <li>get_inertia_matrix (naomi::spacecraft)</li> <li>get_pv_coordinates (naomi::spacecraft, pv_coordinates_provider, state_provider)</li> <li>get_attitude_provider (naomi::spacecraft_state)</li> <li>get_integrated_providers (naomi::spacecraft_state)</li> <li>get_provider_mapping (naomi::spacecraft_state)</li> <li>get_state_provider (naomi::spacecraft_state)</li> <li>get_acceleration (pv_coordinates)</li> <li>get_additional_state_providers (spacecraft_attitude_subsystem, spacecraft_subsystem)</li> </ul>"},{"location":"naomi/class_members/#h","title":"h","text":"<ul> <li>handle_event (naomi::events::event_detector, naomi::events::event_handler, naomi::maneuvers::maneuver_plan)</li> <li>hohmann_transfer (naomi::maneuvers::hohmann_transfer)</li> <li>handle_observe_state (naomi::observers::results_csv_writer_observer, naomi::observers::simulation_observer)</li> </ul>"},{"location":"naomi/class_members/#i","title":"i","text":"<ul> <li>identity (angular_coordinates)</li> <li>initialize (naomi::control::controller, naomi::control::pid_controller, naomi::numeric::numerical_propagator, naomi::observers::results_csv_writer_observer, naomi::observers::simulation_observer, naomi::simulation_component, spacecraft_attitude_subsystem)</li> <li>integrate (naomi::numeric::integrator)</li> <li>integrator (naomi::numeric::integrator)</li> </ul>"},{"location":"naomi/class_members/#k","title":"k","text":"<ul> <li>keplerian_orbit (naomi::orbits::keplerian_orbit)</li> </ul>"},{"location":"naomi/class_members/#m","title":"m","text":"<ul> <li>m_state (naomi::attitude::additional_state_provider)</li> <li>m_alpha (naomi::attitude::euler_angles)</li> <li>m_beta (naomi::attitude::euler_angles)</li> <li>m_gamma (naomi::attitude::euler_angles)</li> <li>m_rotation_order (naomi::attitude::euler_angles)</li> <li>m_rotation_order_map (naomi::attitude::euler_angles)</li> <li>m_eq_radius (naomi::bodies::celestial_body)</li> <li>m_higher_order_terms (naomi::bodies::celestial_body)</li> <li>m_mu (naomi::bodies::celestial_body)</li> <li>m_potential_exp (naomi::bodies::celestial_body)</li> <li>m_potential_partial_x (naomi::bodies::celestial_body)</li> <li>m_potential_partial_x_visitor (naomi::bodies::celestial_body)</li> <li>m_potential_partial_y (naomi::bodies::celestial_body)</li> <li>m_potential_partial_y_visitor (naomi::bodies::celestial_body)</li> <li>m_potential_partial_z (naomi::bodies::celestial_body)</li> <li>m_potential_partial_z_visitor (naomi::bodies::celestial_body)</li> <li>m_soi (naomi::bodies::celestial_body)</li> <li>m_attitude_control_input (naomi::control::control_input)</li> <li>m_position_control_input (naomi::control::control_input)</li> <li>m_e (naomi::control::pid_controller)</li> <li>m_integral (naomi::control::pid_controller)</li> <li>m_kd (naomi::control::pid_controller)</li> <li>m_ki (naomi::control::pid_controller)</li> <li>m_kp (naomi::control::pid_controller)</li> <li>m_t (naomi::control::pid_controller, naomi::numeric::numerical_propagator, naomi::physical_system, naomi::simulation)</li> <li>m_abs_tol (naomi::events::event_detector)</li> <li>m_handlers (naomi::events::event_detector)</li> <li>m_is_active (naomi::events::event_detector)</li> <li>m_max_check_interval (naomi::events::event_detector)</li> <li>m_rel_tol (naomi::events::event_detector)</li> <li>m_trigger (naomi::events::event_detector, naomi::maneuvers::maneuver)</li> <li>m_detector_g (naomi::events::event_detector_condition)</li> <li>m_detectors (naomi::events::event_detector_condition)</li> <li>m_time (naomi::events::time_detector)</li> <li>m_central_body (naomi::forces::two_body_force_model, naomi::forces::two_body_force_model_eoms, naomi::forces::two_body_rot_force_model)</li> <li>m_density (naomi::geometry::body_shape)</li> <li>m_faces (naomi::geometry::body_shape)</li> <li>m_mass (naomi::geometry::body_shape)</li> <li>m_verts (naomi::geometry::body_shape)</li> <li>make_polyhedron (naomi::geometry::body_shape)</li> <li>make_rectangle (naomi::geometry::body_shape)</li> <li>m_dvs (naomi::maneuvers::bielliptic_hohmann_transfer, naomi::maneuvers::hohmann_transfer)</li> <li>m_initial_sma (naomi::maneuvers::bielliptic_hohmann_transfer)</li> <li>m_target_sma (naomi::maneuvers::bielliptic_hohmann_transfer)</li> <li>m_transfer_magnitude (naomi::maneuvers::bielliptic_hohmann_transfer)</li> <li>m_transit_time (naomi::maneuvers::bielliptic_hohmann_transfer, naomi::maneuvers::hohmann_transfer)</li> <li>m_initial_state (naomi::maneuvers::hohmann_transfer)</li> <li>m_target_radius (naomi::maneuvers::hohmann_transfer)</li> <li>m_delta_v (naomi::maneuvers::maneuver)</li> <li>m_direction (naomi::maneuvers::maneuver)</li> <li>maneuver (naomi::maneuvers::maneuver)</li> <li>m_maneuvers (naomi::maneuvers::maneuver_plan)</li> <li>m_start_time (naomi::maneuvers::maneuver_plan)</li> <li>maneuver_plan (naomi::maneuvers::maneuver_plan)</li> <li>m_stepper (naomi::numeric::integrator)</li> <li>m_event_detectors (naomi::numeric::numerical_propagator)</li> <li>m_integrator (naomi::numeric::numerical_propagator)</li> <li>m_spacecrafts (naomi::numeric::numerical_propagator, naomi::physical_system)</li> <li>m_system (naomi::numeric::numerical_propagator, naomi::simulation)</li> <li>make_system (naomi::numeric::numerical_propagator)</li> <li>map_providers (naomi::numeric::numerical_propagator)</li> <li>m_filepath (naomi::observers::results_csv_writer_observer)</li> <li>m_fout (naomi::observers::results_csv_writer_observer)</li> <li>m_openmode (naomi::observers::results_csv_writer_observer)</li> <li>m_next_obs_time (naomi::observers::simulation_observer)</li> <li>m_obs_interval (naomi::observers::simulation_observer)</li> <li>m_prev_obs_time (naomi::observers::simulation_observer)</li> <li>m_pos (naomi::orbits::cartesian_orbit)</li> <li>m_vel (naomi::orbits::cartesian_orbit)</li> <li>m_ecc (naomi::orbits::eccentric_anomaly_functor, naomi::orbits::keplerian_orbit)</li> <li>m_ma (naomi::orbits::eccentric_anomaly_functor, naomi::orbits::keplerian_orbit)</li> <li>m_anomaly (naomi::orbits::keplerian_orbit)</li> <li>m_anomaly_type (naomi::orbits::keplerian_orbit)</li> <li>m_aop (naomi::orbits::keplerian_orbit)</li> <li>m_ea (naomi::orbits::keplerian_orbit)</li> <li>m_inc (naomi::orbits::keplerian_orbit)</li> <li>m_raan (naomi::orbits::keplerian_orbit)</li> <li>m_sma (naomi::orbits::keplerian_orbit)</li> <li>m_propagator (naomi::physical_system)</li> <li>m_observers (naomi::simulation)</li> <li>m_attitude (naomi::spacecraft)</li> <li>m_body_shape (naomi::spacecraft)</li> <li>m_identifier (naomi::spacecraft)</li> <li>m_maneuver_plan (naomi::spacecraft)</li> <li>m_pv_coordinates (naomi::spacecraft)</li> </ul>"},{"location":"naomi/class_members/#n","title":"n","text":"<ul> <li>nadir_pointing_pid_controller (naomi::control::nadir_pointing_pid_controller)</li> <li>norm (naomi::geometry::face)</li> <li>numerical_propagator (naomi::numeric::numerical_propagator)</li> </ul>"},{"location":"naomi/class_members/#o","title":"o","text":"<ul> <li>operator() (naomi::events::event_detector, naomi::forces::force_model, naomi::forces::two_body_force_model, naomi::forces::two_body_rot_force_model, naomi::orbits::eccentric_anomaly_functor)</li> <li>operator= (naomi::maneuvers::maneuver_plan, naomi::numeric::integrator, naomi::numeric::numerical_propagator)</li> <li>observe_event (naomi::observers::simulation_observer)</li> <li>observe_state (naomi::observers::simulation_observer)</li> <li>operator== (naomi::orbits::keplerian_orbit)</li> </ul>"},{"location":"naomi/class_members/#p","title":"p","text":"<ul> <li>pid_controller (naomi::control::pid_controller)</li> <li>P1 (naomi::geometry::body_shape)</li> <li>Pa (naomi::geometry::body_shape)</li> <li>Paa (naomi::geometry::body_shape)</li> <li>Paaa (naomi::geometry::body_shape)</li> <li>Paab (naomi::geometry::body_shape)</li> <li>Pab (naomi::geometry::body_shape)</li> <li>Pabb (naomi::geometry::body_shape)</li> <li>Pb (naomi::geometry::body_shape)</li> <li>Pbb (naomi::geometry::body_shape)</li> <li>Pbbb (naomi::geometry::body_shape)</li> <li>pop_stage (naomi::maneuvers::maneuver_plan)</li> <li>propagate_by (naomi::numeric::numerical_propagator)</li> <li>propagate_to (naomi::numeric::numerical_propagator)</li> <li>physical_system (naomi::physical_system)</li> <li>pv_coordinates (pv_coordinates)</li> <li>pv_coordinates_provider (pv_coordinates_provider)</li> </ul>"},{"location":"naomi/class_members/#r","title":"r","text":"<ul> <li>results_csv_writer_observer (naomi::observers::results_csv_writer_observer)</li> <li>rad2deg (naomi::orbits::keplerian_orbit)</li> </ul>"},{"location":"naomi/class_members/#s","title":"s","text":"<ul> <li>set_integrated_state (integrated_provider, naomi::spacecraft_state, pv_coordinates_provider, torque_free_attitude_provider)</li> <li>stage (naomi::maneuvers::maneuver_plan)</li> <li>simulation_observer (naomi::observers::simulation_observer)</li> <li>simulate_by (naomi::physical_system)</li> <li>simulate_to (naomi::physical_system)</li> <li>simulate (naomi::simulation)</li> <li>simulation (naomi::simulation)</li> <li>set_attitude (naomi::spacecraft)</li> <li>spacecraft (naomi::spacecraft)</li> <li>spacecraft_state (naomi::spacecraft_state)</li> <li>spacecraft_attitude_subsystem (spacecraft_attitude_subsystem)</li> <li>spacecraft_subsystem (spacecraft_subsystem)</li> </ul>"},{"location":"naomi/class_members/#t","title":"t","text":"<ul> <li>to_vec (angular_coordinates, naomi::orbits::keplerian_orbit, pv_coordinates)</li> <li>torque_free_eoms (naomi::attitude::torque_free_eoms)</li> <li>time_occurred (naomi::events::event)</li> <li>time_detector (naomi::events::time_detector)</li> <li>two_body_force_model (naomi::forces::two_body_force_model)</li> <li>two_body_force_model_eoms (naomi::forces::two_body_force_model_eoms)</li> <li>two_body_rot_force_model (naomi::forces::two_body_rot_force_model)</li> <li>T0 (naomi::geometry::body_shape)</li> <li>T1 (naomi::geometry::body_shape)</li> <li>T2 (naomi::geometry::body_shape)</li> <li>TP (naomi::geometry::body_shape)</li> <li>terminate (naomi::observers::results_csv_writer_observer, naomi::observers::simulation_observer, naomi::simulation_component, spacecraft_attitude_subsystem)</li> <li>to_cartesian (naomi::orbits::keplerian_orbit)</li> <li>torque_free_attitude_provider (torque_free_attitude_provider)</li> </ul>"},{"location":"naomi/class_members/#u","title":"u","text":"<ul> <li>update (naomi::simulation_component, naomi::spacecraft, spacecraft_attitude_subsystem)</li> </ul>"},{"location":"naomi/class_members/#v","title":"v","text":"<ul> <li>verts (naomi::geometry::face)</li> <li>v_norm (naomi::orbits::keplerian_orbit)</li> </ul>"},{"location":"naomi/class_members/#w","title":"w","text":"<ul> <li>w (naomi::geometry::face)</li> <li>what (naomi::maneuvers::no_such_maneuver_exception)</li> </ul>"},{"location":"naomi/class_members/#_1","title":"~","text":"<ul> <li>~integrated_provider (integrated_provider)</li> <li>~additional_state_provider (naomi::attitude::additional_state_provider)</li> <li>~attitude_provider (naomi::attitude::attitude_provider)</li> <li>~constant_attitude_provider (naomi::attitude::constant_attitude_provider)</li> <li>~euler_angles (naomi::attitude::euler_angles)</li> <li>~rotation (naomi::attitude::rotation)</li> <li>~torque_free_eoms (naomi::attitude::torque_free_eoms)</li> <li>~celestial_body (naomi::bodies::celestial_body)</li> <li>~earth (naomi::bodies::earth)</li> <li>~controller (naomi::control::controller)</li> <li>~pid_controller (naomi::control::pid_controller)</li> <li>~event_detector (naomi::events::event_detector)</li> <li>~event_handler (naomi::events::event_handler)</li> <li>~equations_of_motion (naomi::forces::equations_of_motion)</li> <li>~force_model (naomi::forces::force_model)</li> <li>~two_body_force_model (naomi::forces::two_body_force_model)</li> <li>~two_body_force_model_eoms (naomi::forces::two_body_force_model_eoms)</li> <li>~two_body_rot_force_model (naomi::forces::two_body_rot_force_model)</li> <li>~integrator (naomi::numeric::integrator)</li> <li>~numerical_propagator (naomi::numeric::numerical_propagator)</li> <li>~simulation_observer (naomi::observers::simulation_observer)</li> <li>~simulation_component (naomi::simulation_component)</li> <li>~pv_coordinates_provider (pv_coordinates_provider)</li> <li>~spacecraft_attitude_subsystem (spacecraft_attitude_subsystem)</li> <li>~spacecraft_subsystem (spacecraft_subsystem)</li> <li>~state_provider (state_provider)</li> </ul>"},{"location":"naomi/class_members/#_","title":"_","text":"<ul> <li>_rotation (angular_coordinates)</li> <li>_name (naomi::attitude::additional_state_provider, spacecraft_subsystem)</li> <li>_attitude (naomi::attitude::constant_attitude_provider)</li> <li>_inertia_matrix (naomi::attitude::torque_free_eoms, torque_free_attitude_provider)</li> <li>_active_maneuvers (naomi::maneuvers::maneuver_plan)</li> <li>_system_eoms (naomi::numeric::numerical_propagator, naomi::physical_system)</li> <li>_attitude_provider (naomi::spacecraft, naomi::spacecraft_state)</li> <li>_state (naomi::spacecraft, pv_coordinates_provider)</li> <li>_integrated_state_idxs (naomi::spacecraft_state)</li> <li>_mass (naomi::spacecraft_state)</li> <li>_state_provider (naomi::spacecraft_state)</li> <li>_acc (pv_coordinates)</li> <li>_pos (pv_coordinates)</li> <li>_vel (pv_coordinates)</li> <li>_eoms (pv_coordinates_provider, torque_free_attitude_provider)</li> <li>_provider (spacecraft_attitude_subsystem)</li> <li>_q (torque_free_attitude_provider)</li> <li>_w (torque_free_attitude_provider)</li> <li>_wdot (torque_free_attitude_provider)</li> </ul>"},{"location":"naomi/class_member_functions/","title":"Class Member Functions","text":""},{"location":"naomi/class_member_functions/#a","title":"a","text":"<ul> <li>angular_coordinates (angular_coordinates)</li> <li>additional_state_provider (naomi::attitude::additional_state_provider)</li> <li>apply_force (naomi::attitude::attitude_provider, naomi::attitude::constant_attitude_provider, torque_free_attitude_provider)</li> <li>apply_to (naomi::attitude::euler_angles, naomi::attitude::rotation)</li> <li>apside_detector (naomi::events::apside_detector)</li> <li>apply_control (pv_coordinates_provider, state_provider)</li> </ul>"},{"location":"naomi/class_member_functions/#b","title":"b","text":"<ul> <li>body_shape (naomi::geometry::body_shape)</li> <li>bielliptic_hohmann_transfer (naomi::maneuvers::bielliptic_hohmann_transfer)</li> </ul>"},{"location":"naomi/class_member_functions/#c","title":"c","text":"<ul> <li>constant_attitude_provider (naomi::attitude::constant_attitude_provider)</li> <li>celestial_body (naomi::bodies::celestial_body)</li> <li>control_input (naomi::control::control_input)</li> <li>compute_face_integrals (naomi::geometry::body_shape)</li> <li>compute_projection_integrals (naomi::geometry::body_shape)</li> <li>compute_volume_integrals (naomi::geometry::body_shape)</li> <li>check_events (naomi::numeric::numerical_propagator)</li> <li>cartesian_orbit (naomi::orbits::cartesian_orbit)</li> <li>compute_eccentricity (naomi::orbits::keplerian_orbit)</li> <li>compute_angular_velocity (torque_free_attitude_provider)</li> </ul>"},{"location":"naomi/class_member_functions/#d","title":"d","text":"<ul> <li>deg2rad (naomi::orbits::keplerian_orbit)</li> </ul>"},{"location":"naomi/class_member_functions/#e","title":"e","text":"<ul> <li>euler_angles (naomi::attitude::euler_angles)</li> <li>earth (naomi::bodies::earth)</li> <li>event_detector (naomi::events::event_detector)</li> <li>event_detector_condition (naomi::events::event_detector_condition)</li> <li>execute_maneuver (naomi::maneuvers::maneuver_plan)</li> <li>eccentric_anomaly_functor (naomi::orbits::eccentric_anomaly_functor)</li> </ul>"},{"location":"naomi/class_member_functions/#f","title":"f","text":"<ul> <li>face (naomi::geometry::face)</li> <li>find_event_time (naomi::numeric::integrator)</li> <li>fn (naomi::orbits::keplerian_orbit)</li> <li>from_cartesian (naomi::orbits::keplerian_orbit)</li> </ul>"},{"location":"naomi/class_member_functions/#g","title":"g","text":"<ul> <li>get_rotation (angular_coordinates, naomi::attitude::attitude_provider, naomi::attitude::constant_attitude_provider, torque_free_attitude_provider)</li> <li>get_eoms (integrated_provider, pv_coordinates_provider, torque_free_attitude_provider)</li> <li>get_integrated_state (integrated_provider, naomi::spacecraft_state, pv_coordinates_provider, torque_free_attitude_provider)</li> <li>get_size (integrated_provider, naomi::attitude::additional_state_provider, pv_coordinates_provider, torque_free_attitude_provider)</li> <li>get_derivative (naomi::attitude::additional_state_provider, naomi::attitude::torque_free_eoms, naomi::forces::equations_of_motion, naomi::forces::two_body_force_model_eoms)</li> <li>get_name (naomi::attitude::additional_state_provider, spacecraft_subsystem)</li> <li>get_state (naomi::attitude::additional_state_provider, naomi::spacecraft)</li> <li>get_angular_momentum (naomi::attitude::attitude_provider, naomi::attitude::constant_attitude_provider, torque_free_attitude_provider)</li> <li>get_angular_velocity (naomi::attitude::attitude_provider, naomi::attitude::constant_attitude_provider, torque_free_attitude_provider)</li> <li>get_axis_rotation (naomi::attitude::euler_angles)</li> <li>get_dcm (naomi::attitude::euler_angles, naomi::attitude::rotation)</li> <li>get_mu (naomi::bodies::celestial_body)</li> <li>get_potential (naomi::bodies::celestial_body)</li> <li>get_potential_partial (naomi::bodies::celestial_body)</li> <li>get_potential_partial_derivative (naomi::bodies::celestial_body, naomi::bodies::earth)</li> <li>get_sphere_of_influence (naomi::bodies::celestial_body)</li> <li>get_control_input (naomi::control::controller, naomi::control::pid_controller, naomi::maneuvers::maneuver, naomi::maneuvers::maneuver_plan)</li> <li>get_desired_state (naomi::control::controller, naomi::control::nadir_pointing_pid_controller)</li> <li>g (naomi::events::apside_detector, naomi::events::event_detector, naomi::events::time_detector, naomi::maneuvers::maneuver_plan)</li> <li>get_transform_to (naomi::frames::frame)</li> <li>get_center_of_mass (naomi::geometry::body_shape)</li> <li>get_inertia_tensor (naomi::geometry::body_shape)</li> <li>get_dvs (naomi::maneuvers::bielliptic_hohmann_transfer, naomi::maneuvers::hohmann_transfer)</li> <li>get_maneuver_plan (naomi::maneuvers::bielliptic_hohmann_transfer, naomi::maneuvers::hohmann_transfer, naomi::spacecraft)</li> <li>get_total_dv (naomi::maneuvers::bielliptic_hohmann_transfer, naomi::maneuvers::hohmann_transfer)</li> <li>get_transit_time (naomi::maneuvers::bielliptic_hohmann_transfer, naomi::maneuvers::hohmann_transfer)</li> <li>get_delta_v (naomi::maneuvers::maneuver)</li> <li>get_delta_v_mag (naomi::maneuvers::maneuver)</li> <li>get_direction (naomi::maneuvers::maneuver)</li> <li>get_trigger (naomi::maneuvers::maneuver)</li> <li>get_maneuvers (naomi::maneuvers::maneuver_plan)</li> <li>get_total_delta_v (naomi::maneuvers::maneuver_plan)</li> <li>get_integration_times (naomi::numeric::numerical_propagator)</li> <li>get_next_update (naomi::observers::simulation_observer, naomi::simulation)</li> <li>get_position (naomi::orbits::cartesian_orbit, pv_coordinates)</li> <li>get_velocity (naomi::orbits::cartesian_orbit, pv_coordinates)</li> <li>get_a (naomi::orbits::keplerian_orbit)</li> <li>get_anomaly (naomi::orbits::keplerian_orbit)</li> <li>get_aop (naomi::orbits::keplerian_orbit)</li> <li>get_e (naomi::orbits::keplerian_orbit)</li> <li>get_eccentric_anomaly (naomi::orbits::keplerian_orbit)</li> <li>get_i (naomi::orbits::keplerian_orbit)</li> <li>get_orbital_period (naomi::orbits::keplerian_orbit)</li> <li>get_raan (naomi::orbits::keplerian_orbit)</li> <li>get_current_time (naomi::physical_system)</li> <li>get_spacecraft (naomi::physical_system)</li> <li>get_spacecrafts (naomi::physical_system)</li> <li>get_attitude (naomi::spacecraft)</li> <li>get_identifier (naomi::spacecraft)</li> <li>get_inertia_matrix (naomi::spacecraft)</li> <li>get_pv_coordinates (naomi::spacecraft, pv_coordinates_provider, state_provider)</li> <li>get_attitude_provider (naomi::spacecraft_state)</li> <li>get_integrated_providers (naomi::spacecraft_state)</li> <li>get_provider_mapping (naomi::spacecraft_state)</li> <li>get_state_provider (naomi::spacecraft_state)</li> <li>get_acceleration (pv_coordinates)</li> <li>get_additional_state_providers (spacecraft_attitude_subsystem, spacecraft_subsystem)</li> </ul>"},{"location":"naomi/class_member_functions/#h","title":"h","text":"<ul> <li>handle_event (naomi::events::event_detector, naomi::events::event_handler, naomi::maneuvers::maneuver_plan)</li> <li>hohmann_transfer (naomi::maneuvers::hohmann_transfer)</li> <li>handle_observe_state (naomi::observers::results_csv_writer_observer, naomi::observers::simulation_observer)</li> </ul>"},{"location":"naomi/class_member_functions/#i","title":"i","text":"<ul> <li>identity (angular_coordinates)</li> <li>initialize (naomi::control::controller, naomi::control::pid_controller, naomi::numeric::numerical_propagator, naomi::observers::results_csv_writer_observer, naomi::observers::simulation_observer, naomi::simulation_component, spacecraft_attitude_subsystem)</li> <li>integrate (naomi::numeric::integrator)</li> <li>integrator (naomi::numeric::integrator)</li> </ul>"},{"location":"naomi/class_member_functions/#k","title":"k","text":"<ul> <li>keplerian_orbit (naomi::orbits::keplerian_orbit)</li> </ul>"},{"location":"naomi/class_member_functions/#m","title":"m","text":"<ul> <li>make_polyhedron (naomi::geometry::body_shape)</li> <li>make_rectangle (naomi::geometry::body_shape)</li> <li>maneuver (naomi::maneuvers::maneuver)</li> <li>maneuver_plan (naomi::maneuvers::maneuver_plan)</li> <li>make_system (naomi::numeric::numerical_propagator)</li> <li>map_providers (naomi::numeric::numerical_propagator)</li> </ul>"},{"location":"naomi/class_member_functions/#n","title":"n","text":"<ul> <li>nadir_pointing_pid_controller (naomi::control::nadir_pointing_pid_controller)</li> <li>numerical_propagator (naomi::numeric::numerical_propagator)</li> </ul>"},{"location":"naomi/class_member_functions/#o","title":"o","text":"<ul> <li>operator() (naomi::events::event_detector, naomi::forces::force_model, naomi::forces::two_body_force_model, naomi::forces::two_body_rot_force_model, naomi::orbits::eccentric_anomaly_functor)</li> <li>operator= (naomi::maneuvers::maneuver_plan, naomi::numeric::integrator, naomi::numeric::numerical_propagator)</li> <li>observe_event (naomi::observers::simulation_observer)</li> <li>observe_state (naomi::observers::simulation_observer)</li> <li>operator== (naomi::orbits::keplerian_orbit)</li> </ul>"},{"location":"naomi/class_member_functions/#p","title":"p","text":"<ul> <li>pid_controller (naomi::control::pid_controller)</li> <li>pop_stage (naomi::maneuvers::maneuver_plan)</li> <li>propagate_by (naomi::numeric::numerical_propagator)</li> <li>propagate_to (naomi::numeric::numerical_propagator)</li> <li>physical_system (naomi::physical_system)</li> <li>pv_coordinates (pv_coordinates)</li> <li>pv_coordinates_provider (pv_coordinates_provider)</li> </ul>"},{"location":"naomi/class_member_functions/#r","title":"r","text":"<ul> <li>results_csv_writer_observer (naomi::observers::results_csv_writer_observer)</li> <li>rad2deg (naomi::orbits::keplerian_orbit)</li> </ul>"},{"location":"naomi/class_member_functions/#s","title":"s","text":"<ul> <li>set_integrated_state (integrated_provider, naomi::spacecraft_state, pv_coordinates_provider, torque_free_attitude_provider)</li> <li>simulation_observer (naomi::observers::simulation_observer)</li> <li>simulate_by (naomi::physical_system)</li> <li>simulate_to (naomi::physical_system)</li> <li>simulate (naomi::simulation)</li> <li>simulation (naomi::simulation)</li> <li>set_attitude (naomi::spacecraft)</li> <li>spacecraft (naomi::spacecraft)</li> <li>spacecraft_state (naomi::spacecraft_state)</li> <li>spacecraft_attitude_subsystem (spacecraft_attitude_subsystem)</li> <li>spacecraft_subsystem (spacecraft_subsystem)</li> </ul>"},{"location":"naomi/class_member_functions/#t","title":"t","text":"<ul> <li>to_vec (angular_coordinates, naomi::orbits::keplerian_orbit, pv_coordinates)</li> <li>torque_free_eoms (naomi::attitude::torque_free_eoms)</li> <li>time_detector (naomi::events::time_detector)</li> <li>two_body_force_model (naomi::forces::two_body_force_model)</li> <li>two_body_force_model_eoms (naomi::forces::two_body_force_model_eoms)</li> <li>two_body_rot_force_model (naomi::forces::two_body_rot_force_model)</li> <li>terminate (naomi::observers::results_csv_writer_observer, naomi::observers::simulation_observer, naomi::simulation_component, spacecraft_attitude_subsystem)</li> <li>to_cartesian (naomi::orbits::keplerian_orbit)</li> <li>torque_free_attitude_provider (torque_free_attitude_provider)</li> </ul>"},{"location":"naomi/class_member_functions/#u","title":"u","text":"<ul> <li>update (naomi::simulation_component, naomi::spacecraft, spacecraft_attitude_subsystem)</li> </ul>"},{"location":"naomi/class_member_functions/#v","title":"v","text":"<ul> <li>v_norm (naomi::orbits::keplerian_orbit)</li> </ul>"},{"location":"naomi/class_member_functions/#w","title":"w","text":"<ul> <li>what (naomi::maneuvers::no_such_maneuver_exception)</li> </ul>"},{"location":"naomi/class_member_functions/#_1","title":"~","text":"<ul> <li>~integrated_provider (integrated_provider)</li> <li>~additional_state_provider (naomi::attitude::additional_state_provider)</li> <li>~attitude_provider (naomi::attitude::attitude_provider)</li> <li>~constant_attitude_provider (naomi::attitude::constant_attitude_provider)</li> <li>~euler_angles (naomi::attitude::euler_angles)</li> <li>~rotation (naomi::attitude::rotation)</li> <li>~torque_free_eoms (naomi::attitude::torque_free_eoms)</li> <li>~celestial_body (naomi::bodies::celestial_body)</li> <li>~earth (naomi::bodies::earth)</li> <li>~controller (naomi::control::controller)</li> <li>~pid_controller (naomi::control::pid_controller)</li> <li>~event_detector (naomi::events::event_detector)</li> <li>~event_handler (naomi::events::event_handler)</li> <li>~equations_of_motion (naomi::forces::equations_of_motion)</li> <li>~force_model (naomi::forces::force_model)</li> <li>~two_body_force_model (naomi::forces::two_body_force_model)</li> <li>~two_body_force_model_eoms (naomi::forces::two_body_force_model_eoms)</li> <li>~two_body_rot_force_model (naomi::forces::two_body_rot_force_model)</li> <li>~integrator (naomi::numeric::integrator)</li> <li>~numerical_propagator (naomi::numeric::numerical_propagator)</li> <li>~simulation_observer (naomi::observers::simulation_observer)</li> <li>~simulation_component (naomi::simulation_component)</li> <li>~pv_coordinates_provider (pv_coordinates_provider)</li> <li>~spacecraft_attitude_subsystem (spacecraft_attitude_subsystem)</li> <li>~spacecraft_subsystem (spacecraft_subsystem)</li> <li>~state_provider (state_provider)</li> </ul>"},{"location":"naomi/class_member_variables/","title":"Class Member Variables","text":""},{"location":"naomi/class_member_variables/#a","title":"a","text":"<ul> <li>a_j2 (naomi::bodies::earth)</li> <li>A (naomi::geometry::body_shape)</li> </ul>"},{"location":"naomi/class_member_variables/#b","title":"b","text":"<ul> <li>B (naomi::geometry::body_shape)</li> </ul>"},{"location":"naomi/class_member_variables/#c","title":"c","text":"<ul> <li>C (naomi::geometry::body_shape)</li> </ul>"},{"location":"naomi/class_member_variables/#d","title":"d","text":"<ul> <li>detector (naomi::events::event)</li> </ul>"},{"location":"naomi/class_member_variables/#e","title":"e","text":"<ul> <li>earth_j2 (naomi::bodies::earth)</li> <li>earth_radius (naomi::bodies::earth)</li> </ul>"},{"location":"naomi/class_member_variables/#f","title":"f","text":"<ul> <li>Fa (naomi::geometry::body_shape)</li> <li>Faa (naomi::geometry::body_shape)</li> <li>Faaa (naomi::geometry::body_shape)</li> <li>Faab (naomi::geometry::body_shape)</li> <li>Fb (naomi::geometry::body_shape)</li> <li>Fbb (naomi::geometry::body_shape)</li> <li>Fbbb (naomi::geometry::body_shape)</li> <li>Fbbc (naomi::geometry::body_shape)</li> <li>Fc (naomi::geometry::body_shape)</li> <li>Fcc (naomi::geometry::body_shape)</li> <li>Fcca (naomi::geometry::body_shape)</li> <li>Fccc (naomi::geometry::body_shape)</li> </ul>"},{"location":"naomi/class_member_variables/#m","title":"m","text":"<ul> <li>m_state (naomi::attitude::additional_state_provider)</li> <li>m_alpha (naomi::attitude::euler_angles)</li> <li>m_beta (naomi::attitude::euler_angles)</li> <li>m_gamma (naomi::attitude::euler_angles)</li> <li>m_rotation_order (naomi::attitude::euler_angles)</li> <li>m_rotation_order_map (naomi::attitude::euler_angles)</li> <li>m_eq_radius (naomi::bodies::celestial_body)</li> <li>m_higher_order_terms (naomi::bodies::celestial_body)</li> <li>m_mu (naomi::bodies::celestial_body)</li> <li>m_potential_exp (naomi::bodies::celestial_body)</li> <li>m_potential_partial_x (naomi::bodies::celestial_body)</li> <li>m_potential_partial_x_visitor (naomi::bodies::celestial_body)</li> <li>m_potential_partial_y (naomi::bodies::celestial_body)</li> <li>m_potential_partial_y_visitor (naomi::bodies::celestial_body)</li> <li>m_potential_partial_z (naomi::bodies::celestial_body)</li> <li>m_potential_partial_z_visitor (naomi::bodies::celestial_body)</li> <li>m_soi (naomi::bodies::celestial_body)</li> <li>m_attitude_control_input (naomi::control::control_input)</li> <li>m_position_control_input (naomi::control::control_input)</li> <li>m_e (naomi::control::pid_controller)</li> <li>m_integral (naomi::control::pid_controller)</li> <li>m_kd (naomi::control::pid_controller)</li> <li>m_ki (naomi::control::pid_controller)</li> <li>m_kp (naomi::control::pid_controller)</li> <li>m_t (naomi::control::pid_controller, naomi::numeric::numerical_propagator, naomi::physical_system, naomi::simulation)</li> <li>m_abs_tol (naomi::events::event_detector)</li> <li>m_handlers (naomi::events::event_detector)</li> <li>m_is_active (naomi::events::event_detector)</li> <li>m_max_check_interval (naomi::events::event_detector)</li> <li>m_rel_tol (naomi::events::event_detector)</li> <li>m_trigger (naomi::events::event_detector, naomi::maneuvers::maneuver)</li> <li>m_detector_g (naomi::events::event_detector_condition)</li> <li>m_detectors (naomi::events::event_detector_condition)</li> <li>m_time (naomi::events::time_detector)</li> <li>m_central_body (naomi::forces::two_body_force_model, naomi::forces::two_body_force_model_eoms, naomi::forces::two_body_rot_force_model)</li> <li>m_density (naomi::geometry::body_shape)</li> <li>m_faces (naomi::geometry::body_shape)</li> <li>m_mass (naomi::geometry::body_shape)</li> <li>m_verts (naomi::geometry::body_shape)</li> <li>m_dvs (naomi::maneuvers::bielliptic_hohmann_transfer, naomi::maneuvers::hohmann_transfer)</li> <li>m_initial_sma (naomi::maneuvers::bielliptic_hohmann_transfer)</li> <li>m_target_sma (naomi::maneuvers::bielliptic_hohmann_transfer)</li> <li>m_transfer_magnitude (naomi::maneuvers::bielliptic_hohmann_transfer)</li> <li>m_transit_time (naomi::maneuvers::bielliptic_hohmann_transfer, naomi::maneuvers::hohmann_transfer)</li> <li>m_initial_state (naomi::maneuvers::hohmann_transfer)</li> <li>m_target_radius (naomi::maneuvers::hohmann_transfer)</li> <li>m_delta_v (naomi::maneuvers::maneuver)</li> <li>m_direction (naomi::maneuvers::maneuver)</li> <li>m_maneuvers (naomi::maneuvers::maneuver_plan)</li> <li>m_start_time (naomi::maneuvers::maneuver_plan)</li> <li>m_stepper (naomi::numeric::integrator)</li> <li>m_event_detectors (naomi::numeric::numerical_propagator)</li> <li>m_integrator (naomi::numeric::numerical_propagator)</li> <li>m_spacecrafts (naomi::numeric::numerical_propagator, naomi::physical_system)</li> <li>m_system (naomi::numeric::numerical_propagator, naomi::simulation)</li> <li>m_filepath (naomi::observers::results_csv_writer_observer)</li> <li>m_fout (naomi::observers::results_csv_writer_observer)</li> <li>m_openmode (naomi::observers::results_csv_writer_observer)</li> <li>m_next_obs_time (naomi::observers::simulation_observer)</li> <li>m_obs_interval (naomi::observers::simulation_observer)</li> <li>m_prev_obs_time (naomi::observers::simulation_observer)</li> <li>m_pos (naomi::orbits::cartesian_orbit)</li> <li>m_vel (naomi::orbits::cartesian_orbit)</li> <li>m_ecc (naomi::orbits::eccentric_anomaly_functor, naomi::orbits::keplerian_orbit)</li> <li>m_ma (naomi::orbits::eccentric_anomaly_functor, naomi::orbits::keplerian_orbit)</li> <li>m_anomaly (naomi::orbits::keplerian_orbit)</li> <li>m_anomaly_type (naomi::orbits::keplerian_orbit)</li> <li>m_aop (naomi::orbits::keplerian_orbit)</li> <li>m_ea (naomi::orbits::keplerian_orbit)</li> <li>m_inc (naomi::orbits::keplerian_orbit)</li> <li>m_raan (naomi::orbits::keplerian_orbit)</li> <li>m_sma (naomi::orbits::keplerian_orbit)</li> <li>m_propagator (naomi::physical_system)</li> <li>m_observers (naomi::simulation)</li> <li>m_attitude (naomi::spacecraft)</li> <li>m_body_shape (naomi::spacecraft)</li> <li>m_identifier (naomi::spacecraft)</li> <li>m_maneuver_plan (naomi::spacecraft)</li> <li>m_pv_coordinates (naomi::spacecraft)</li> </ul>"},{"location":"naomi/class_member_variables/#n","title":"n","text":"<ul> <li>norm (naomi::geometry::face)</li> </ul>"},{"location":"naomi/class_member_variables/#p","title":"p","text":"<ul> <li>P1 (naomi::geometry::body_shape)</li> <li>Pa (naomi::geometry::body_shape)</li> <li>Paa (naomi::geometry::body_shape)</li> <li>Paaa (naomi::geometry::body_shape)</li> <li>Paab (naomi::geometry::body_shape)</li> <li>Pab (naomi::geometry::body_shape)</li> <li>Pabb (naomi::geometry::body_shape)</li> <li>Pb (naomi::geometry::body_shape)</li> <li>Pbb (naomi::geometry::body_shape)</li> <li>Pbbb (naomi::geometry::body_shape)</li> </ul>"},{"location":"naomi/class_member_variables/#s","title":"s","text":"<ul> <li>stage (naomi::maneuvers::maneuver_plan)</li> </ul>"},{"location":"naomi/class_member_variables/#t","title":"t","text":"<ul> <li>time_occurred (naomi::events::event)</li> <li>T0 (naomi::geometry::body_shape)</li> <li>T1 (naomi::geometry::body_shape)</li> <li>T2 (naomi::geometry::body_shape)</li> <li>TP (naomi::geometry::body_shape)</li> </ul>"},{"location":"naomi/class_member_variables/#v","title":"v","text":"<ul> <li>verts (naomi::geometry::face)</li> </ul>"},{"location":"naomi/class_member_variables/#w","title":"w","text":"<ul> <li>w (naomi::geometry::face)</li> </ul>"},{"location":"naomi/class_member_variables/#_","title":"_","text":"<ul> <li>_rotation (angular_coordinates)</li> <li>_name (naomi::attitude::additional_state_provider, spacecraft_subsystem)</li> <li>_attitude (naomi::attitude::constant_attitude_provider)</li> <li>_inertia_matrix (naomi::attitude::torque_free_eoms, torque_free_attitude_provider)</li> <li>_active_maneuvers (naomi::maneuvers::maneuver_plan)</li> <li>_system_eoms (naomi::numeric::numerical_propagator, naomi::physical_system)</li> <li>_attitude_provider (naomi::spacecraft, naomi::spacecraft_state)</li> <li>_state (naomi::spacecraft, pv_coordinates_provider)</li> <li>_integrated_state_idxs (naomi::spacecraft_state)</li> <li>_mass (naomi::spacecraft_state)</li> <li>_state_provider (naomi::spacecraft_state)</li> <li>_acc (pv_coordinates)</li> <li>_pos (pv_coordinates)</li> <li>_vel (pv_coordinates)</li> <li>_eoms (pv_coordinates_provider, torque_free_attitude_provider)</li> <li>_provider (spacecraft_attitude_subsystem)</li> <li>_q (torque_free_attitude_provider)</li> <li>_w (torque_free_attitude_provider)</li> <li>_wdot (torque_free_attitude_provider)</li> </ul>"},{"location":"naomi/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"naomi/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"naomi/namespace_members/","title":"Namespace Members","text":""},{"location":"naomi/namespace_members/#a","title":"a","text":"<ul> <li>AnomalyType (naomi::orbits)</li> </ul>"},{"location":"naomi/namespace_members/#c","title":"c","text":"<ul> <li>conjugate (naomi::math::quaternion)</li> </ul>"},{"location":"naomi/namespace_members/#e","title":"e","text":"<ul> <li>EARTH_MU (naomi::constants)</li> <li>EARTH_MU_KM (naomi::constants)</li> <li>EventDetectorTrigger (naomi::events)</li> </ul>"},{"location":"naomi/namespace_members/#g","title":"g","text":"<ul> <li>get_circular_orbit (naomi::orbits)</li> </ul>"},{"location":"naomi/namespace_members/#m","title":"m","text":"<ul> <li>MINUS_I (naomi::constants)</li> <li>MINUS_J (naomi::constants)</li> <li>MINUS_K (naomi::constants)</li> </ul>"},{"location":"naomi/namespace_members/#p","title":"p","text":"<ul> <li>PLUS_I (naomi::constants)</li> <li>PLUS_J (naomi::constants)</li> <li>PLUS_K (naomi::constants)</li> <li>product (naomi::math::quaternion)</li> <li>pv_rot_state_type (naomi)</li> <li>pv_state_type (naomi)</li> <li>pva_rot_state_type (naomi)</li> <li>pva_state_type (naomi)</li> </ul>"},{"location":"naomi/namespace_members/#q","title":"q","text":"<ul> <li>quaternion_type (naomi::math::quaternion, naomi)</li> <li>q_skew (naomi::math)</li> </ul>"},{"location":"naomi/namespace_members/#r","title":"r","text":"<ul> <li>rotation_order (naomi::attitude)</li> <li>rk_dopri5_stepper (naomi::numeric)</li> </ul>"},{"location":"naomi/namespace_members/#s","title":"s","text":"<ul> <li>state_and_time_type (naomi::events)</li> <li>skew (naomi::math)</li> <li>system_t (naomi::numeric)</li> </ul>"},{"location":"naomi/namespace_members/#v","title":"v","text":"<ul> <li>vis_viva (naomi::orbits)</li> <li>vector_type (naomi)</li> </ul>"},{"location":"naomi/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"naomi/namespace_member_functions/#c","title":"c","text":"<ul> <li>conjugate (naomi::math::quaternion)</li> </ul>"},{"location":"naomi/namespace_member_functions/#g","title":"g","text":"<ul> <li>get_circular_orbit (naomi::orbits)</li> </ul>"},{"location":"naomi/namespace_member_functions/#m","title":"m","text":"<ul> <li>MINUS_I (naomi::constants)</li> <li>MINUS_J (naomi::constants)</li> <li>MINUS_K (naomi::constants)</li> </ul>"},{"location":"naomi/namespace_member_functions/#p","title":"p","text":"<ul> <li>PLUS_I (naomi::constants)</li> <li>PLUS_J (naomi::constants)</li> <li>PLUS_K (naomi::constants)</li> <li>product (naomi::math::quaternion)</li> </ul>"},{"location":"naomi/namespace_member_functions/#q","title":"q","text":"<ul> <li>q_skew (naomi::math)</li> </ul>"},{"location":"naomi/namespace_member_functions/#s","title":"s","text":"<ul> <li>skew (naomi::math)</li> </ul>"},{"location":"naomi/namespace_member_functions/#v","title":"v","text":"<ul> <li>vis_viva (naomi::orbits)</li> </ul>"},{"location":"naomi/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"naomi/namespace_member_variables/#e","title":"e","text":"<ul> <li>EARTH_MU (naomi::constants)</li> <li>EARTH_MU_KM (naomi::constants)</li> </ul>"},{"location":"naomi/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"naomi/namespace_member_typedefs/#p","title":"p","text":"<ul> <li>pv_rot_state_type (naomi)</li> <li>pv_state_type (naomi)</li> <li>pva_rot_state_type (naomi)</li> <li>pva_state_type (naomi)</li> </ul>"},{"location":"naomi/namespace_member_typedefs/#q","title":"q","text":"<ul> <li>quaternion_type (naomi::math::quaternion, naomi)</li> </ul>"},{"location":"naomi/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>rk_dopri5_stepper (naomi::numeric)</li> </ul>"},{"location":"naomi/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>state_and_time_type (naomi::events)</li> <li>system_t (naomi::numeric)</li> </ul>"},{"location":"naomi/namespace_member_typedefs/#v","title":"v","text":"<ul> <li>vector_type (naomi)</li> </ul>"},{"location":"naomi/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"naomi/namespace_member_enums/#a","title":"a","text":"<ul> <li>AnomalyType (naomi::orbits)</li> </ul>"},{"location":"naomi/namespace_member_enums/#e","title":"e","text":"<ul> <li>EventDetectorTrigger (naomi::events)</li> </ul>"},{"location":"naomi/namespace_member_enums/#r","title":"r","text":"<ul> <li>rotation_order (naomi::attitude)</li> </ul>"},{"location":"naomi/functions/","title":"Functions","text":""},{"location":"naomi/functions/#e","title":"e","text":"<ul> <li>eci2ric (transforms.h)</li> </ul>"},{"location":"naomi/macros/","title":"Macros","text":""},{"location":"naomi/macros/#c","title":"c","text":"<ul> <li>CUBE (body_shape.h)</li> </ul>"},{"location":"naomi/macros/#e","title":"e","text":"<ul> <li>EARTH_EQ_RADIUS (earth.h)</li> <li>EARTH_J2 (earth.h)</li> <li>EARTH_SOI (earth.h)</li> </ul>"},{"location":"naomi/macros/#g","title":"g","text":"<ul> <li>GRAVITATIONAL_CONSTANT (constants.h)</li> </ul>"},{"location":"naomi/macros/#m","title":"m","text":"<ul> <li>MAX_FACES (body_shape.h)</li> <li>MAX_POLYGON_SZ (body_shape.h)</li> <li>MAX_VERTS (body_shape.h)</li> </ul>"},{"location":"naomi/macros/#n","title":"n","text":"<ul> <li>NAOMI_EXPORT (naomi.h)</li> </ul>"},{"location":"naomi/macros/#s","title":"s","text":"<ul> <li>SQR (body_shape.h)</li> </ul>"},{"location":"naomi/variables/","title":"Variables","text":""},{"location":"naomi/variables/#x","title":"x","text":"<ul> <li>X (body_shape.h)</li> </ul>"},{"location":"naomi/variables/#y","title":"y","text":"<ul> <li>Y (body_shape.h)</li> </ul>"},{"location":"naomi/variables/#z","title":"z","text":"<ul> <li>Z (body_shape.h)</li> </ul>"},{"location":"naomi/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}